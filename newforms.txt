===================
newforms ライブラリ
===================

:revision-up-to: 5613 (0.97pre SVN)

``django.newforms`` は， Django に新たに導入された画期的なフォーム処理ライ
ブラリで，従来のフォーム／マニピュレータ／バリデータフレームワークである
``django.forms`` を置き換えるものです．このドキュメントでは，新たなフォーム
ライブラリの使い方について解説します．

.. _Migration plan:

移行の計画
==========

``django.newforms`` はリリース 0.96 で新たに採り入れられた機能ですが，もう
「新しい(new)」機能ではなくなったので，将来 ``django.forms`` に名前を変更す
る予定です．現在の ``django.forms`` は Django 1.0 までの間
``django.oldforms`` という名前で利用でき，その後削除するのが適当だと考えて
います．

この変更は，現在皆さんが利用しているコードの将来のバージョンに対する互換性
に直接的に関わってきます．以下の移行計画を良く読んで，それに沿ったコードを
書くようにしてください:

    * 従来のフォームフレームワーク (現在の ``django.forms``) は
      ``django.oldforms`` にコピーされています．従って，互換性のない変更を
      座して待つことなく， *今すぐ* コードの修正に取り掛かれます．修正は，
      各アプリケーションのコードを以下のように書き換えるだけです::

          from django import forms             # 移行前
          from django import oldforms as forms # 移行後

    * 次の Django リリース (0.97) では，現在の ``django.newforms`` を
      ``django.forms`` に移動します．これは互換性のない変更なので，以前の
      ``django.forms`` を使い続けたい人は，上記に従って import 文を変更する
      必要があります．

    * 次の Django リリース，すなわち新たな ``django.forms`` が導入されたリ
      リースの *後* ， 0.98 か 1.0 のいずれか先に出たバージョンで，
      ``django.oldforms`` をコードから除去します．

この移行計画を念頭に， ``django.newforms`` を使う場合には以下のような
import 文を使うように勧めます::

    from django import newforms as forms

こうしておけば，フォームライブラリを ``forms`` モジュールとして参照でき，
``django.newforms`` が ``django.forms`` になったときに ``import`` 文を書き
換えるだけで済みます．

「 ``import *`` 」構文を使いたければ以下のようにできます::

    from django.newforms import *

上の命令は，全てのフィールド，ウィジェット，フォームクラスと検証のためのユー
ティリティをローカルな名前空間に import します．便利と考える人も，美しくな
いと考える人もいるでしょう．

.. _Overview:

概要
====

``django.newforms`` は，以前の ``django.forms`` (「マニピュレータ」) システ
ムと同じく， HTML フォームを表示し，データ処理 (検証) を行って再表示するた
めのライブラリです．HTML フォームをサーバ側で検証する場合に使います．

例えば， Web サイトに連絡用フォームを設置し，訪問者が電子メールでメッセージ
を送信できるようにしたいなら，このライブラリを使って HTML フォームフィール
ドを表示し，フォームの値を検証できます．このライブラリは， HTML の
``<form>`` タグが必要になるような状況で利用できるわけです．

このライブラリでは，以下のような概念を扱います:

    * **ウィジェット (Widget)** -- ``<input type="text">`` や
      ``<textarea>`` のような， HTML フォームウィジェットに対応するクラスで
      す．ウィジェットから HTML へのレンダリングもこのクラスで行われます．

    * **フィールド (Field)** -- データの検証を行うためのクラスです．例えば，
      ``EmailField`` はデータが有効な電子メールアドレスかどうか検証します．

    * **フォーム (Form)** -- フィールドの集まりで，データの検証や HTML への
      表示方法が実装されたものです．

このライブラリは，データベースレイヤやビュー，テンプレートといった他の
Django コンポーネントに対してカップリングしていません． newforms ライブラリ
が依存しているのは settings と ``django.utils`` の二つのヘルパ関数，そして
国際化のためのフック (ただし，このライブラリを使うために国際化の機能を使わ
ねばならないわけではありません) だけです．

.. _Form objects:

フォームオブジェクト
====================

``newforms`` ライブラリの第一の用途はフォームオブジェクト (form object) の
作成にあります．フォームオブジェクトは， ``django.newforms.Form`` クラスを
サブクラス化して，フォームのフィールドを定義して作成します．フォームのフィー
ルド定義は Django のデータベースモデルで親しんでいるあの記述方法で行えます．
この節では，自分のウェブサイトに「連絡フォーム (contact me)」の機能を実装す
るためのフォームオブジェクトを逐次開発してゆきます．

まずは ``ContactForm`` という名前で ``Form`` のサブクラスを作成するところか
らはじめましょう::

    from django import newforms as forms

    class ContactForm(forms.Form):
        subject = forms.CharField(max_length=100)
        message = forms.CharField()
        sender = forms.EmailField()
        cc_myself = forms.BooleanField()

フォームは ``Field`` オブジェクトの組み合わせでできています．今回の例では，
``subject`` (題名)， ``message`` (メッセージ)， ``sender`` (送信者)，そして
``cc_myself`` (自分に CC する)，の 4 つのフィールドをフォームに持たせます．
``CharField`` や ``EmailField`` といったフィールド型については，また後で説
明する予定です．

.. _Creating Form instances:

``Form`` のインスタンスを生成する
---------------------------------

``Form`` のインスタンスには，何らかのデータの集まりをコンストラクタに渡して
結び付けたもの (**束縛 (bound) フォーム**) と，そうでないもの 
(**非束縛 (unbound) フォーム**) があります．

    * データと **結び付いている** フォームは，データを検証機能する機能と， 
      フォームを HTML にレンダリングするときにデータを HTML 形式で表示する
      機能をあわせ持っています．

    * データと **結び付いていない** フォームには検証機能はありません (検証
      すべきデータがないから当然ですね!) が，空のフォームを HTML としてレン
      ダリングする機能は備えています．

非束縛フォームのインスタンスを生成するには，単にフォームクラスのインスタン
ス化を行います::

    >>> f = ContactForm()

フォームにデータを結び付けるには，データの入った辞書をフォームクラスのコン
ストラクタの第一引数に渡します::

    >>> data = {'subject': 'hello',
    ...         'message': 'Hi there',
    ...         'sender': 'foo@example.com',
    ...         'cc_myself': True}
    >>> f = ContactForm(data)

この辞書の中では，キーは各フィールドの名前であり，フォームクラスの各属性に
対応しています．値は検証すべきデータです．通常，値は文字列にしますが，必ず
しも文字列でなくてかまいません．値にどんなデータ型を指定指定できるかは，フィー
ルドの型に依存します．

実行時に束縛フォームと非束縛フォームを区別したければ，フォームの
``is_bound`` 属性を調べてください::

    >>> f = ContactForm()
    >>> f.is_bound
    False
    >>> f = ContactForm({'subject': 'hello'})
    >>> f.is_bound
    True

空の辞書を渡すと，空のデータの入った *束縛フォーム* を返します::

    >>> f = ContactForm({})
    >>> f.is_bound
    True

束縛フォームのインスタンスに入っているデータに何らかの変更を加えたい場合や，
束縛フォームを変換して，何らかのデータの入った非束縛フォームにしたい場合に
は，新たにフォームインスタンスを生成してください．フォームインスタンス内の
データを変更する方法はありません．一度フォームインスタンスを生成したら，デー
タの有無に関わらず，インスタンス内のデータは変更不能だと考えてください．

.. _Using forms to validate data:

フォームを使ってデータを検証する
--------------------------------

フォームオブジェクトの主要な役割はデータの検証です．束縛フォームのインスタ
ンスに対して ``is_valid()`` メソッドを呼び出すと，データの検証を行って，そ
の結果をブール値で返します::

    >>> data = {'subject': 'hello',
    ...         'message': 'Hi there',
    ...         'sender': 'foo@example.com',
    ...         'cc_myself': True}
    >>> f = ContactForm(data)
    >>> f.is_valid()
    True

無効なデータを入れてみましょう．例えば， ``subject`` を空にしてみます
(フィールドは全てデフォルトで必須なためエラーになります)．また，
``sender`` に不正なメールアドレス情報を入れてみます::

    >>> data = {'subject': '',
    ...         'message': 'Hi there',
    ...         'sender': 'invalid e-mail address',
    ...         'cc_myself': True}
    >>> f = ContactForm(data)
    >>> f.is_valid()
    False

``errors`` という属性にアクセスすると，エラーメッセージの入った辞書を参照で
きます::

    >>> f.errors
    {'sender': [u'Enter a valid e-mail address.'], 'subject': [u'This field is required.']}

この辞書は，フィールド名がキーに，エラーメッセージを表す Unicode 文字列のリ
ストが値になっています．エラーメッセージがリストになっているのは，一つのフィー
ルドに対して複数のエラーが存在し得るからです．

``is_valid()`` を呼ばなくても ``errors`` にはアクセスできます．
``is_valid()`` を呼び出すか， ``errors`` にアクセスすると，フォームのデータ
は自動的に検証されます．

``errors`` や ``is_invalid()`` に何度アクセスしても，検証のルーチンはたった
一度しか呼ばれません．別の見方をすれば，検証の処理には副作用があり，その副
作用はたった一度しか呼び出されないということです．

``cleaned_data`` には， ``Form`` 内で定義されている *全ての* フィールドのキー
と値が入ります．フォームに渡したデータに，必須でないフィールドの値が入って
いない場合でもです．下の例では，データ辞書には ``nick_name`` フィールドの値
が入っていませんが， ``cleaned_data`` には空の値が入っています::

    >>> class OptionalPersonForm(Form):
    ...     first_name = CharField()
    ...     last_name = CharField()
    ...     nick_name = CharField(required=False)
    >>> data = {'first_name': u'John', 'last_name': u'Lennon'}
    >>> f = OptionalPersonForm(data)
    >>> f.is_valid()
    True
    >>> f.cleaned_data
    {'nick_name': u'', 'first_name': u'John', 'last_name': u'Lennon'}

この例で， ``cleaned_data`` の中の ``nick_name`` は空文字列なのは，
``nick_name`` が ``CharField`` であり， ``CharField`` は空の値を空文字列と
みなすからです．各フィールドタイプは「空の」値が設定されています．例えば，
``DateField`` の場合，空の値は空文字列ではなく ``None`` になります．
空の値を持ったフィールドの詳しい挙動は，「組み込みフィールドクラス」の節の
各フィールドの説明中の「空のフォームデータに対する値」の項目を参照してくだ
さい．

個別のフォームフィールド (フィールド名ごと) やフォーム全体 (複数フィールド
の組み合わせ) に対してバリデーションを実現するコードを書けます．詳しくは，
後述の `フォームやフィールドのバリデーションコードを自作する`_ の節を参照し
てください．

.. _Behavior of unbound forms:

非束縛フォームの動作
~~~~~~~~~~~~~~~~~~~~

データを含まないフォームに対して "cleaned" を実行しても無意味でしかありませ
んが，参考までに非束縛フォームに対して行ったときの動作を示しておきます::

    >>> f = ContactForm()
    >>> f.is_valid()
    False
    >>> f.errors
    {}

.. _Accessing "clean" data:

「クリーニング済み」のデータにアクセスする
------------------------------------------

フォームクラスの各フィールドには，データの検証だけでなく，「クリーニング」
を行う役割もあります．データのクリーニングとは，データを一貫性のある書式に
正規化することです．データのクリーニングはとても素晴らしい機能で，クリーニ
ングを行うと，ユーザがフィールドに色々な形式でデータを入力しても，常に一貫
性を持った出力を得られます．

例えば， ``DateField`` はデータを Python の ``datetime.date`` オブジェクト
に正規化します．フィールドの値は， ``'1994-07-15'`` のような形式の文字列で
も， ``datetime.date`` オブジェクトでも，その他の形式でも， ``DateField``
は有効なデータであるかぎり，常に出力を ``datetime.date`` オブジェクトで正規
化します．

データセットの入ったフォームインスタンスを生成して検証を行うと， 
``cleaned_data`` 属性を介してクリーニング済みのデータにアクセスできるようにな
ります::

    >>> data = {'subject': 'hello',
    ...         'message': 'Hi there',
    ...         'sender': 'foo@example.com',
    ...         'cc_myself': True}
    >>> f = ContactForm(data)
    >>> f.is_valid()
    True
    >>> f.cleaned_data
    {'cc_myself': True, 'message': u'Hi there', 'sender': u'foo@example.com', 'subject': u'hello'}

``CharField`` や ``EmailField`` のようなテキストベースのフィールドは，常に
入力を Unicode 文字列に変換します．エンコーディングに関する解説は，このドキュ
メントの後の方でカバーする予定です．

データが *まだ検証されていない* 場合，フォームインスタンスには
``cleaned_data`` 属性がありません::

    >>> data = {'subject': '',
    ...         'message': 'Hi there',
    ...         'sender': 'invalid e-mail address',
    ...         'cc_myself': True}
    >>> f = ContactForm(data)
    >>> f.is_valid()
    False
    >>> f.cleaned_data
    Traceback (most recent call last):
    ...
    AttributeError: 'ContactForm' object has no attribute 'cleaned_data'

フォームを生成するときに追加の値を渡した場合でも， ``cleaned_data`` の中に
入るキーは，フォーム内で定義されているフィールド *だけ* です．以下の例でも，
``ContactForm`` のコンストラクタに追加のフィールドデータを渡していますが，
``cleaned_data`` が返すのは ``ContactForm`` で定義されているフィールドだけで
す::

    >>> data = {'subject': 'hello',
    ...         'message': 'Hi there',
    ...         'sender': 'foo@example.com',
    ...         'cc_myself': True,
    ...         'extra_field_1': 'foo',
    ...         'extra_field_2': 'bar',
    ...         'extra_field_3': 'baz'}
    >>> f = ContactForm(data)
    >>> f.is_valid()
    True
    >>> f.cleaned_data # Doesn't contain extra_field_1, etc.
    {'cc_myself': True, 'message': u'Hi there', 'sender': u'foo@example.com', 'subject': u'hello'}


.. .. _Behavior of unbound forms:

非束縛フォームの動作
~~~~~~~~~~~~~~~~~~~~

データの入っていないフォームをクリーニングしても無意味ですが，参考までに非
束縛フォームでの挙動を示します::

    >>> f = ContactForm()
    >>> f.cleaned_data
    Traceback (most recent call last):
    ...
    AttributeError: 'ContactForm' object has no attribute 'cleaned_data'


.. _Example View:

ビューの実装例
~~~~~~~~~~~~~~

これまでに紹介した内容をまとめる意味で，簡単な連絡フォームのビューメソッド
の例を以下に示します::

    from django.shortcuts import render_to_response
    from django.http import HttpResponseRedirect
    from django import newforms as forms

    class ContactForm(forms.Form):
        subject = forms.CharField(max_length=100)
        message = forms.CharField()
        sender = forms.EmailField()
        cc_myself = forms.BooleanField()

    def contact(request):
        if request.POST:
            f = ContactForm(request.POST)
            if f.is_valid:
                # ... do something with f.cleaned_data
  		return HttpResponseRedirect('/url/on/success/')
        else:
            f = ContactForm()
        return render_to_response('contact.html', {'form': f})

.. _Outputting forms as HTML:

フォームを HTML として出力する
------------------------------

フォームオブジェクトの二つ目の仕事は，フォームの HTML へのレンダリングです．
フォームを HTML として出力するには，フォームをインスタンス化して，
``print`` で出力します::

    >>> f = ContactForm()
    >>> print f
    <tr><th><label for="id_subject">Subject:</label></th><td><input id="id_subject" type="text" name="subject" maxlength="100" /></td></tr>
    <tr><th><label for="id_message">Message:</label></th><td><input type="text" name="message" id="id_message" /></td></tr>
    <tr><th><label for="id_sender">Sender:</label></th><td><input type="text" name="sender" id="id_sender" /></td></tr>
    <tr><th><label for="id_cc_myself">Cc myself:</label></th><td><input type="checkbox" name="cc_myself" id="id_cc_myself" /></td></tr>

束縛フォームの場合，フォームのデータは適切な形で HTML 出力されます．例えば，
フィールドが ``<input type="text">`` で表される場合，データは ``value`` 属
性の中に出力されます．フィールドが ``<input type="checkbox">`` であれば，
必要に応じて ``checked="checked"`` が入ります::

    >>> data = {'subject': 'hello',
    ...         'message': 'Hi there',
    ...         'sender': 'foo@example.com',
    ...         'cc_myself': True}
    >>> f = ContactForm(data)
    >>> print f
    <tr><th><label for="id_subject">Subject:</label></th><td><input id="id_subject" type="text" name="subject" maxlength="100" value="hello" /></td></tr>
    <tr><th><label for="id_message">Message:</label></th><td><input type="text" name="message" id="id_message" value="Hi there" /></td></tr>
    <tr><th><label for="id_sender">Sender:</label></th><td><input type="text" name="sender" id="id_sender" value="foo@example.com" /></td></tr>
    <tr><th><label for="id_cc_myself">Cc myself:</label></th><td><input type="checkbox" name="cc_myself" id="id_cc_myself" checked="checked" /></td></tr>

デフォルトの出力は 2 カラムの HTML テーブルになり，各フィールドが一つの
``<tr>`` タグの中に収まります．以下の点に注意してください:

    * 柔軟性をもたせるために，出力中には ``<table>`` と ``</table>`` タグが
      入っていません．また， ``<form>`` と ``</form>`` や， 
      ``<input type="submit">`` もありません．これらのタグは自分で入れる必
      要があります．

    * 各フィールドタイプには，それぞれデフォルトの HTML 表現があります．
      ``CharField`` や ``EmailField`` は ``<input type="text">`` で表され，
      ``BooleanField`` は ``<input type="checkbox">`` になります．とはいえ，
      これらは便利なデフォルト値にすぎません．ウィジェット (widget) を使え
      ば，フィールドの表現にどのような HTML を使うかを指定できます．これに
      ついては後で説明する予定です．

    * 各タグの ``name`` 属性は ``ContactForm`` クラスの属性名から直接取り出
      して使われます．

    * ``'Subject:'``, ``'Message:'``, ``'Cc myself:'``  といった各フィール
      ドのテキストラベルは，フィールド名のアンダースコアを全てスペースに変
      換し，先頭の文字を大文字にして生成します．これもまたデフォルト値にす
      ぎず，手動でもラベルを設定できるようになっています．

    * 各テキストラベルは HTML の ``<label>`` タグで囲われています．このタグ
      には ``for`` 属性が付いていて，対応するフォームフィールドの ``id`` 属
      性に対応しています．属性の値はフィールド名の前に ``'id_'`` を付けたも
      のになります． ``id`` 属性や ``<label>`` タグはフォーム生成の定石に従っ
      て組み込まれているものですが，この振舞は自分で変更できます．

テーブル組みによる出力は ``print`` した時に出力されるデフォルトで，他にもい
くつか出力スタイルがあります．各スタイルはフォームオブジェクトのメソッドと
して利用でき，各々のレンダリングメソッドは Unicode オブジェクトを返すように
なっています．

``as_p()``
~~~~~~~~~~

``Form.as_p()`` はフォームを一連の ``<p>`` タグの集まりで組みます．各
``<p>`` タグの中に一つのフィールドが入ります::

    >>> f = ContactForm()
    >>> f.as_p()
    u'<p><label for="id_subject">Subject:</label> <input id="id_subject" type="text" name="subject" maxlength="100" /></p>\n<p><label for="id_message">Message:</label> <input type="text" name="message" id="id_message" /></p>\n<p><label for="id_sender">Sender:</label> <input type="text" name="sender" id="id_sender" /></p>\n<p><label for="id_cc_myself">Cc myself:</label> <input type="checkbox" name="cc_myself" id="id_cc_myself" /></p>'
    >>> print f.as_p()
    <p><label for="id_subject">Subject:</label> <input id="id_subject" type="text" name="subject" maxlength="100" /></p>
    <p><label for="id_message">Message:</label> <input type="text" name="message" id="id_message" /></p>
    <p><label for="id_sender">Sender:</label> <input type="text" name="sender" id="id_sender" /></p>
    <p><label for="id_cc_myself">Cc myself:</label> <input type="checkbox" name="cc_myself" id="id_cc_myself" /></p>

``form`` をコンテキストに入れていれば，テンプレート上では以下のようにして出
力できます::

    {{ f.as_p }}


``as_ul()``
~~~~~~~~~~~

``Form.as_ul()`` はフォームを一連の ``<li>`` タグで組みます．各 ``<li>`` タ
グの中に一つのフィールドが入ります． ``as_ul()`` は ``<ul>`` や ``</ul>``
を出力に *含めません* ．これは，ユーザが ``<ul>`` タグの HTML 属性を好きに
指定できるようにするためです::

    >>> f = ContactForm()
    >>> f.as_ul()
    u'<li><label for="id_subject">Subject:</label> <input id="id_subject" type="text" name="subject" maxlength="100" /></li>\n<li><label for="id_message">Message:</label> <input type="text" name="message" id="id_message" /></li>\n<li><label for="id_sender">Sender:</label> <input type="text" name="sender" id="id_sender" /></li>\n<li><label for="id_cc_myself">Cc myself:</label> <input type="checkbox" name="cc_myself" id="id_cc_myself" /></li>'
    >>> print f.as_ul()
    <li><label for="id_subject">Subject:</label> <input id="id_subject" type="text" name="subject" maxlength="100" /></li>
    <li><label for="id_message">Message:</label> <input type="text" name="message" id="id_message" /></li>
    <li><label for="id_sender">Sender:</label> <input type="text" name="sender" id="id_sender" /></li>
    <li><label for="id_cc_myself">Cc myself:</label> <input type="checkbox" name="cc_myself" id="id_cc_myself" /></li>

``form`` をコンテキストに入れていれば，テンプレート上では以下のようにして出
力できます::

    {{ f.as_ul }}

``as_table()``
~~~~~~~~~~~~~~

最後に， ``Form.as_table()`` はフォームを ``<table>`` で組みます．これは
``print`` で出力したときに使われる形式と同じです．実際，フォームオブジェク
トを ``print`` すると，背後では ``as_table()`` が呼び出されるようになってい
ます::

    >>> f = ContactForm()
    >>> f.as_table()
    u'<tr><th><label for="id_subject">Subject:</label></th><td><input id="id_subject" type="text" name="subject" maxlength="100" /></td></tr>\n<tr><th><label for="id_message">Message:</label></th><td><input type="text" name="message" id="id_message" /></td></tr>\n<tr><th><label for="id_sender">Sender:</label></th><td><input type="text" name="sender" id="id_sender" /></td></tr>\n<tr><th><label for="id_cc_myself">Cc myself:</label></th><td><input type="checkbox" name="cc_myself" id="id_cc_myself" /></td></tr>'
    >>> print f.as_table()
    <tr><th><label for="id_subject">Subject:</label></th><td><input id="id_subject" type="text" name="subject" maxlength="100" /></td></tr>
    <tr><th><label for="id_message">Message:</label></th><td><input type="text" name="message" id="id_message" /></td></tr>
    <tr><th><label for="id_sender">Sender:</label></th><td><input type="text" name="sender" id="id_sender" /></td></tr>
    <tr><th><label for="id_cc_myself">Cc myself:</label></th><td><input type="checkbox" name="cc_myself" id="id_cc_myself" /></td></tr>

``form`` をコンテキストに入れていれば，テンプレート上では以下のようにして出
力できます::

    {{ f.as_table }}

デフォルトの設定はテーブル出力なので，以下のようにしても出力できます::

    {{ f }}

.. _Configuring HTML ``<label>`` tags:

``<label>`` タグの出力設定
~~~~~~~~~~~~~~~~~~~~~~~~~~

``<label>`` タグは，あるラベルテキストがどのフォーム要素に対応づけられてい
るかを知らせるタグです． ``<label>`` タグがあると，フォームの利便性が増し，
入力補助デバイスで操作しやすくなります． ``<label>`` タグは常に使うようにし
ておくよう勧めます．

デフォルトでは，フォームのレンダリングメソッドを呼び出すと，各フォーム要素
に ``id`` 属性が追加され，ラベルを ``<label>`` タグで囲って出力します．
``id`` 属性の値はフォームのフィールド名の前に ``id_`` を付けたものになりま
す．とはいえ， ``id`` 属性の命名規則を変えたり，そもそも ``<label>`` を出力
したくない人のために，この仕様は設定変更できるようになっています．

``<label>`` タグや ``id`` の挙動を変更するには， ``Form`` コンストラクタの
``auto_id`` 引数を使います．この引数は ``True`` ， ``False`` ，文字列のいず
れかで指定せねばなりません．

``auto_id`` を ``False`` にすると，フォーム出力に ``<label>`` タグや
``id`` 属性が含まれなくなります::

    >>> f = ContactForm(auto_id=False)
    >>> print f.as_table()
    <tr><th>Subject:</th><td><input type="text" name="subject" maxlength="100" /></td></tr>
    <tr><th>Message:</th><td><input type="text" name="message" /></td></tr>
    <tr><th>Sender:</th><td><input type="text" name="sender" /></td></tr>
    <tr><th>Cc myself:</th><td><input type="checkbox" name="cc_myself" /></td></tr>
    >>> print f.as_ul()
    <li>Subject: <input type="text" name="subject" maxlength="100" /></li>
    <li>Message: <input type="text" name="message" /></li>
    <li>Sender: <input type="text" name="sender" /></li>
    <li>Cc myself: <input type="checkbox" name="cc_myself" /></li>
    >>> print f.as_p()
    <p>Subject: <input type="text" name="subject" maxlength="100" /></p>
    <p>Message: <input type="text" name="message" /></p>
    <p>Sender: <input type="text" name="sender" /></p>
    <p>Cc myself: <input type="checkbox" name="cc_myself" /></p>

``auto_id`` が ``True`` の場合，フォームの出力には ``<label>`` タグが入り，
各フォームフィールドの ``id`` 属性の値にはフィールド名をそのまま使います::

    >>> f = ContactForm(auto_id=True)
    >>> print f.as_table()
    <tr><th><label for="subject">Subject:</label></th><td><input id="subject" type="text" name="subject" maxlength="100" /></td></tr>
    <tr><th><label for="message">Message:</label></th><td><input type="text" name="message" id="message" /></td></tr>
    <tr><th><label for="sender">Sender:</label></th><td><input type="text" name="sender" id="sender" /></td></tr>
    <tr><th><label for="cc_myself">Cc myself:</label></th><td><input type="checkbox" name="cc_myself" id="cc_myself" /></td></tr>
    >>> print f.as_ul()
    <li><label for="subject">Subject:</label> <input id="subject" type="text" name="subject" maxlength="100" /></li>
    <li><label for="message">Message:</label> <input type="text" name="message" id="message" /></li>
    <li><label for="sender">Sender:</label> <input type="text" name="sender" id="sender" /></li>
    <li><label for="cc_myself">Cc myself:</label> <input type="checkbox" name="cc_myself" id="cc_myself" /></li>
    >>> print f.as_p()
    <p><label for="subject">Subject:</label> <input id="subject" type="text" name="subject" maxlength="100" /></p>
    <p><label for="message">Message:</label> <input type="text" name="message" id="message" /></p>
    <p><label for="sender">Sender:</label> <input type="text" name="sender" id="sender" /></p>
    <p><label for="cc_myself">Cc myself:</label> <input type="checkbox" name="cc_myself" id="cc_myself" /></p>

``auto_id`` がフォーマット文字 ``'%s'`` を含む文字列になっている場合，フォー
ム出力は ``<label>`` タグを含むようになり，タグの ``id`` 属性はフォーマット
文字列に従って生成されます．例えば，フォーマット文字列が ``field_%s`` の場
合， ``subject`` という名前のフィールドの ``id`` は ``'field_subject'`` に
なります．出力例は以下のようになります::

    >>> f = ContactForm(auto_id='id_for_%s')
    >>> print f.as_table()
    <tr><th><label for="id_for_subject">Subject:</label></th><td><input id="id_for_subject" type="text" name="subject" maxlength="100" /></td></tr>
    <tr><th><label for="id_for_message">Message:</label></th><td><input type="text" name="message" id="id_for_message" /></td></tr>
    <tr><th><label for="id_for_sender">Sender:</label></th><td><input type="text" name="sender" id="id_for_sender" /></td></tr>
    <tr><th><label for="id_for_cc_myself">Cc myself:</label></th><td><input type="checkbox" name="cc_myself" id="id_for_cc_myself" /></td></tr>
    >>> print f.as_ul()
    <li><label for="id_for_subject">Subject:</label> <input id="id_for_subject" type="text" name="subject" maxlength="100" /></li>
    <li><label for="id_for_message">Message:</label> <input type="text" name="message" id="id_for_message" /></li>
    <li><label for="id_for_sender">Sender:</label> <input type="text" name="sender" id="id_for_sender" /></li>
    <li><label for="id_for_cc_myself">Cc myself:</label> <input type="checkbox" name="cc_myself" id="id_for_cc_myself" /></li>
    >>> print f.as_p()
    <p><label for="id_for_subject">Subject:</label> <input id="id_for_subject" type="text" name="subject" maxlength="100" /></p>
    <p><label for="id_for_message">Message:</label> <input type="text" name="message" id="id_for_message" /></p>
    <p><label for="id_for_sender">Sender:</label> <input type="text" name="sender" id="id_for_sender" /></p>
    <p><label for="id_for_cc_myself">Cc myself:</label> <input type="checkbox" name="cc_myself" id="id_for_cc_myself" /></p>

``auto_id`` がこれ以外の偽でない値，つまり ``%s`` を含まない文字列のような
値の場合， ``auto_id`` は ``True`` に設定されたものとみなされます．

デフォルトでは， ``auto_id`` は ``'id_%s'`` に設定されています．

.. _Notes on field ordering:

フィールドの並び順について
~~~~~~~~~~~~~~~~~~~~~~~~~~

``as_p()`` や ``as_ul()``, ``as_table()`` ショートカットを使うと，各フィー
ルドは Form クラス内で定義された順に出力されます．例えば，上の
``ContactForm`` の例では，フィールドの並び順は ``subject``, ``message``,
``sender``, ``cc_myself`` になります． HTML 出力の中でフィールドの並び順を
変更したければ，クラス定義内でのフィールドの並び順を変更してください．

.. _How errors are displayed:

エラーの出力方法
~~~~~~~~~~~~~~~~

束縛フォームオブジェクトをレンダすると，フォームの検証がまだであればレンダ
リング操作の中で自動的に検証が行われ，エラーがあれば HTML 出力中の該当フィー
ルドの付近に ``<ul class=errorlist>`` でエラー内容が表示されます．エラーメッ
セージ中の具体的なエラー表示位置は，どのメソッドでフォームをレンダしている
かによります::

    >>> data = {'subject': '',
    ...         'message': 'Hi there',
    ...         'sender': 'invalid e-mail address',
    ...         'cc_myself': True}
    >>> f = ContactForm(data, auto_id=False)
    >>> print f.as_table()
    <tr><th>Subject:</th><td><ul class="errorlist"><li>This field is required.</li></ul><input type="text" name="subject" maxlength="100" /></td></tr>
    <tr><th>Message:</th><td><input type="text" name="message" value="Hi there" /></td></tr>
    <tr><th>Sender:</th><td><ul class="errorlist"><li>Enter a valid e-mail address.</li></ul><input type="text" name="sender" value="invalid e-mail address" /></td></tr>
    <tr><th>Cc myself:</th><td><input checked="checked" type="checkbox" name="cc_myself" /></td></tr>
    >>> print f.as_ul()
    <li><ul class="errorlist"><li>This field is required.</li></ul>Subject: <input type="text" name="subject" maxlength="100" /></li>
    <li>Message: <input type="text" name="message" value="Hi there" /></li>
    <li><ul class="errorlist"><li>Enter a valid e-mail address.</li></ul>Sender: <input type="text" name="sender" value="invalid e-mail address" /></li>
    <li>Cc myself: <input checked="checked" type="checkbox" name="cc_myself" /></li>
    >>> print f.as_p()
    <p><ul class="errorlist"><li>This field is required.</li></ul></p>
    <p>Subject: <input type="text" name="subject" maxlength="100" /></p>
    <p>Message: <input type="text" name="message" value="Hi there" /></p>
    <p><ul class="errorlist"><li>Enter a valid e-mail address.</li></ul></p>
    <p>Sender: <input type="text" name="sender" value="invalid e-mail address" /></p>
    <p>Cc myself: <input checked="checked" type="checkbox" name="cc_myself" /></p>

.. _More granular output:

より細かな出力調整
~~~~~~~~~~~~~~~~~~

``as_p()`` や ``as_ul()``, ``as_table()`` といったメソッドは，単に面倒臭が
りの開発者むけに用意されているショートカットでしかなく，他のやり方でもフォー
ムを表示できます．

フォーム中のあるフィールドの HTML を表示するには，フォームを辞書のように扱
い，フィールドの名前をキーにして参照し，その値を出力します::

    >>> f = ContactForm()
    >>> print f['subject']
    <input id="id_subject" type="text" name="subject" maxlength="100" />
    >>> print f['message']
    <input type="text" name="message" id="id_message" />
    >>> print f['sender']
    <input type="text" name="sender" id="id_sender" />
    >>> print f['cc_myself']
    <input type="checkbox" name="cc_myself" id="id_cc_myself" />

フィールドを引数にして ``str()`` や ``unicode()`` を呼び出すと，レンダ結果
の HTML をそれぞれ string 型や Unicode 型のオブジェクトで返します::

    >>> str(f['subject'])
    '<input id="id_subject" type="text" name="subject" maxlength="100" />'
    >>> unicode(f['subject'])
    u'<input id="id_subject" type="text" name="subject" maxlength="100" />'

フィールド固有の出力を行った場合でも，フォームオブジェクトの ``auto_id`` 設
定は有効です::

    >>> f = ContactForm(auto_id=False)
    >>> print f['message']
    <input type="text" name="message" />
    >>> f = ContactForm(auto_id='id_%s')
    >>> print f['message']
    <input type="text" name="message" id="id_message" />

あるフィールドに関するエラーのリストを取得するには，フィールドの ``errors``
属性にアクセスします．このフィールドはリストライクなオブジェクトで， HTML
として出力すると ``<ul class="errorlist">`` のリストになります::

    >>> data = {'subject': 'hi', 'message': '', 'sender': '', 'cc_myself': ''}
    >>> f = ContactForm(data, auto_id=False)
    >>> print f['message']
    <input type="text" name="message" />
    >>> f['message'].errors
    [u'This field is required.']
    >>> print f['message'].errors
    <ul class="errorlist"><li>This field is required.</li></ul>
    >>> f['subject'].errors
    []
    >>> print f['subject'].errors

    >>> str(f['subject'].errors)
    ''

.. _Using forms in views and templates:

ビューやテンプレートでフォームを使う
------------------------------------

では，先ほどの連絡フォームを Django のビューとテンプレートに組み込みましょ
う．

.. _Simple view example:

簡単なビューの例
~~~~~~~~~~~~~~~~

以下のビューは，デフォルトでは連絡フォームを表示し， POST リクエストで
アクセスすると，入力値の検証と処理を行います::

    def contact(request):
        if request.method == 'POST':
            form = ContactForm(request.POST)
            if form.is_valid():
                # Do form processing here...
                return HttpResponseRedirect('/url/on_success/')
        else:
            form = ContactForm()
        return render_to_response('contact.html', {'form': form})
 
.. _Simple template example:

簡単なテンプレートの例
~~~~~~~~~~~~~~~~~~~~~~

上の例で使っているテンプレート， ``contact.html`` は，フォームを HTML で出
力する役割を担います．フォームの出力には，前述の 
`フォームを HTML として出力する <#outputting-forms-as-html>`_ で述べたテク
ニックを使えます．

フォームを HTML 出力するもっとも簡単な方法は，以下のようにフォーム変数その
ものを使うというものです::

    <form method="post">
    <table>{{ form }}</table>
    <input type="submit" />
    </form>

上のテンプレートコードを使うと，フォームを ``form.as_table()`` メソッドによっ
てHTML テーブルにして表示します．テーブルが表示されるのは，テンプレートシス
テムがオブジェクトの ``__str__()`` 値を表示するようになっていて， ``Form``
クラスの ``__str__()`` メソッドが自身の ``as_table()`` メソッドを呼び出すか
らです．

以下のコードも全く同じ出力を生成しますが，こちらの方がより明示的です::

    <form method="post">
    <table>{{ form.as_table }}</table>
    <input type="submit" />
    </form>

もちろん， ``form.as_ul`` や ``form.as_p`` も使えます．

上の二つの例では， ``<form>``, ``<table>``, ``<input type="submit" />``,
``</table>`` および ``</form>`` といったタグが入っていることに注意してくだ
さい．フォームの便宜メソッド (``as_table()``, ``as_ul()`` および
``as_p()``) は，これらの HTML タグを出力しません．

.. _Complex template output:

複雑なテンプレート出力
~~~~~~~~~~~~~~~~~~~~~~

これまで何度か強調してきたように， ``as_table()``, ``as_ul()``, ``as_p()``
といったメソッドは，よく使う例に対するショートカットにすぎません．個々のフィー
ルドを操作すれば，完全にテンプレートを制御してフォームの設計を行えます．

もっとも簡単な方法は， ``{% for field in form %}`` を使って，フォームのフィー
ルドにわたって反復処理を行うというものです．例えば::

    <form method="post">
    <dl>
    {% for field in form %}
        <dt>{{ field.label }}</dt>
        <dd>{{ field }}</dd>
        {% if field.help_text %}<dd>{{ field.help_text }}</dd>{% endif %}
        {% if field.errors %}<dd class="myerrors">{{ field.errors }}</dd>{% endif %}
    {% endfor %}
    </dl>
    <input type="submit" />
    </form>

このような反復処理のテクニックは，各フィールドに対して同じ HTML のフォーマッ
トを適用したい場合や，あらかじめフォームフィールドの名前が分からない状況で
フォームを生成したい場合などに役立ちます．フィールドは ``Form`` クラスで定
義されている順番に反復処理されます．

反復処理を使う代わりに，フォームのフィールドを名前で明示した調整も行えます．
フォームフィールドを明示的に指定するには， ``{{ form.fieldname }}`` のよう
にします． ``fieldname`` はフィールドの名前です．
例を示します::

    <form method="post">
    <ul class="myformclass">
        <li>{{ form.sender.label }} {{ form.sender }}</li>
        <li class="helptext">{{ form.sender.help_text }}</li>
        {% if form.sender.errors %}<ul class="errorlist">{{ form.sender.errors }}</ul>{% endif %}

        <li>{{ form.subject.label }} {{ form.subject }}</li>
        <li class="helptext">{{ form.subject.help_text }}</li>
        {% if form.subject.errors %}<ul class="errorlist">{{ form.subject.errors }}</ul>{% endif %}

        ...
    </ul>
    </form>



.. _Subclassing forms:

フォームのサブクラス化
----------------------

同じフィールドを持つようなフォームクラスをいくつも作りたい場合，サブクラス
化を用いると冗長性を排除できます．

フォームクラスをサブクラス化すると，できたフォームクラスには親クラスの全て
のフィールドが入っています．サブクラスで定義したフィールドは親クラスのフィー
ルドの後に続きます．

以下の例では， ``ContactFormWithPriority`` には ``ContactForm`` の全てのフィー
ルドと， ``priority`` という追加のフィールドが入っています．
``ContactForm`` のフィールドは先に表示されます::

    >>> class ContactFormWithPriority(ContactForm):
    ...     priority = forms.CharField()
    >>> f = ContactFormWithPriority(auto_id=False)
    >>> print f.as_ul()
    <li>Subject: <input type="text" name="subject" maxlength="100" /></li>
    <li>Message: <input type="text" name="message" /></li>
    <li>Sender: <input type="text" name="sender" /></li>
    <li>Cc myself: <input type="checkbox" name="cc_myself" /></li>
    <li>Priority: <input type="text" name="priority" /></li>

複数のフォームを親クラスにしたサブクラス化も可能です．この場合，親クラスの
フォームは「混ぜ込み (mix-in)」クラスのように扱われます．以下の例では，
``BeatleForm`` が ``PersonForm`` と ``InstrumentForm`` を (この順番で)
サブクラス化しています．フィールドのリストには，親クラスのフィールドが順番
に表示されます::

    >>> class PersonForm(Form):
    ...     first_name = CharField()
    ...     last_name = CharField()
    >>> class InstrumentForm(Form):
    ...     instrument = CharField()
    >>> class BeatleForm(PersonForm, InstrumentForm):
    ...     haircut_type = CharField()
    >>> b = BeatleForm(auto_id=False)
    >>> print b.as_ul()
    <li>First name: <input type="text" name="first_name" /></li>
    <li>Last name: <input type="text" name="last_name" /></li>
    <li>Instrument: <input type="text" name="instrument" /></li>
    <li>Haircut type: <input type="text" name="haircut_type" /></li>


.. _Fields:

フィールド
==========

フォームクラスの作成で一番重要なのは，フォームの各フィールドの定義です．各
フィールドは固有のデータ検証ロジックと，いくつかのフックが備わっています．

フィールドクラスの主な用途はフォームクラスにおけるフィールド定義ですが，フィー
ルドクラスは直接インスタンス化して使えるので，フィールドの動作を理解する役
に立つはずです．各フィールドインスタンスは ``clean()`` メソッドを備えており，
単一の引数を取って検証を行い，その結果に応じて
``django.newforms.ValidationError`` を送出するか，クリーニング済みの値を返
します::

    >>> f = forms.EmailField()
    >>> f.clean('foo@example.com')
    u'foo@example.com'
    >>> f.clean(u'foo@example.com')
    u'foo@example.com'
    >>> f.clean('invalid e-mail address')
    Traceback (most recent call last):
    ...
    ValidationError: [u'Enter a valid e-mail address.']

Django の古いフォーム／検証フレームワークを使ったことがある人は，この
``VaridationError`` が以前の ``VaridationError`` とは別の例外であることに注
意してください．以前の例外は ``django.core.validators.ValidationError`` で
すが，新たな例外は ``django.newforms.ValidationError`` です．

.. _Core field arguments:

フィールドの主な引数
--------------------

各フィールドクラスのコンストラクタは，少なくとも以下に示す引数を取ります．
フィールドクラスによっては他にもフィールド固有の引数をとりますが．ここに示
す引数はどのフィールドクラスでも *常に* 指定できる引数です:

``required``
~~~~~~~~~~~~

デフォルトでは，フィールドクラスはフィールドが必須 (reqired) であると仮定し
ています．従って，フィールドに空の値，すなわち ``None`` や空文字列 (``""``)
を渡すと， ``clean()`` は ``VaridationError`` 例外を送出します::

    >>> f = forms.CharField()
    >>> f.clean('foo')
    u'foo'
    >>> f.clean('')
    Traceback (most recent call last):
    ...
    ValidationError: [u'This field is required.']
    >>> f.clean(None)
    Traceback (most recent call last):
    ...
    ValidationError: [u'This field is required.']
    >>> f.clean(' ')
    u' '
    >>> f.clean(0)
    u'0'
    >>> f.clean(True)
    u'True'
    >>> f.clean(False)
    u'False'

必須で *ない* フィールドにするには，フィールドのコンストラクタに
``required=False`` を指定します::

    >>> f = forms.CharField(required=False)
    >>> f.clean('foo')
    u'foo'
    >>> f.clean('')
    u''
    >>> f.clean(None)
    u''
    >>> f.clean(0)
    u'0'
    >>> f.clean(True)
    u'True'
    >>> f.clean(False)
    u'False'

``required=False`` のフィールドの ``clean()`` に空の値を渡して呼び出すと，
``clean()`` は ``VaridationError`` を送出する代わりに *正規化された* 空の値
を返します．例えば ``CharField`` の場合なら， Unicode の空文字列になります．
その他のフィールドクラスでは ``None`` になるはずです (フィールドによって異
なります)．

``label``
~~~~~~~~~

``label`` 引数を使うと，フィールドに「人間に優しい」ラベルを指定できます．
このラベルはフォーム内でフィールドを表示するときに使われます．

上の `フォームを HTML として出力する`_ で説明し
たように，フィールドのデフォルトのラベルはフィールド名のアンダースコアを除
去して，頭文字を大文字にしたものです．デフォルトのラベル命名規則が期待通り
のラベルを出力しない場合には，この引数を指定してください．

``label`` を指定したフォームの例を以下に示します．出力を短くするために
``auto_id=False`` にしています::

    >>> class CommentForm(forms.Form):
    ...     name = forms.CharField(label='Your name')
    ...     url = forms.URLField(label='Your Web site', required=False)
    ...     comment = forms.CharField()
    >>> f = CommentForm(auto_id=False)
    >>> print f
    <tr><th>Your name:</th><td><input type="text" name="name" /></td></tr>
    <tr><th>Your Web site:</th><td><input type="text" name="url" /></td></tr>
    <tr><th>Comment:</th><td><input type="text" name="comment" /></td></tr>

``initial``
~~~~~~~~~~~

``initial`` 引数を使うと，非束縛フォーム内でフィールドをレンダするときの初
期値を指定できます．

この引数を使うケースは，例えば以下のように，「空の」フォームの各フィールド
を特定の値で初期化して表示したい場合です::

    >>> class CommentForm(forms.Form):
    ...     name = forms.CharField(initial='Your name')
    ...     url = forms.URLField(initial='http://')
    ...     comment = forms.CharField()
    >>> f = CommentForm(auto_id=False)
    >>> print f
    <tr><th>Name:</th><td><input type="text" name="name" value="Your name" /></td></tr>
    <tr><th>Url:</th><td><input type="text" name="url" value="http://" /></td></tr>
    <tr><th>Comment:</th><td><input type="text" name="comment" /></td></tr>

こんなことをしなくても，フォームに初期データの入った辞書を渡せばいいのにと
思うかもしれませんね．しかし，フォームにデータを渡して束縛フォームにすると，
データを表示する際に検証がトリガされてしまい， HTML 出力にバリデーションエ
ラーが入ってしまいます::

    >>> class CommentForm(forms.Form):
    ...     name = forms.CharField()
    ...     url = forms.URLField()
    ...     comment = forms.CharField()
    >>> default_data = {'name': 'Your name', 'url': 'http://'}
    >>> f = CommentForm(default_data, auto_id=False)
    >>> print f
    <tr><th>Name:</th><td><input type="text" name="name" value="Your name" /></td></tr>
    <tr><th>Url:</th><td><ul class="errorlist"><li>Enter a valid URL.</li></ul><input type="text" name="url" value="http://" /></td></tr>
    <tr><th>Comment:</th><td><ul class="errorlist"><li>This field is required.</li></ul><input type="text" name="comment" /></td></tr>

このため，非束縛フォームの場合に限って ``initial`` に指定した値が出力される
ようになっているのです．束縛フォームの場合，出力は常に束縛済みのデータにな
ります．

また， ``initial`` の指定値は，フィールドの値が指定されなかった場合の
「フォールバック用の」値には *ならない* ので注意が必要です．
``initial`` の値は初期値の入ったフォームの表示 *だけ* に用いられます::

    >>> class CommentForm(forms.Form):
    ...     name = forms.CharField(initial='Your name')
    ...     url = forms.URLField(initial='http://')
    ...     comment = forms.CharField()
    >>> data = {'name': '', 'url': '', 'comment': 'Foo'}
    >>> f = CommentForm(data)
    >>> f.is_valid()
    False
    # フォームの値は初期値にフォールバック *しません．*
    >>> f.errors
    {'url': [u'This field is required.'], 'name': [u'This field is required.']}

``widget``
~~~~~~~~~~

``widget`` 引数を使うと，フィールドをレンダリングするときの ``Widget`` クラ
スを指定できます．詳しくは後述の ``ウィジェット`` を参照してください．

``help_text``
~~~~~~~~~~~~~

``help_text`` 引数を使うと，フィールドに説明文をつけられます．
``help_text`` を指定した場合，フォームを (``as_ul()`` のような) フォームメ
ソッドでレンダした時に，該当フィールドの隣に表示されます．

以下に， ``help_text`` を使ったフォームの例を示します．この例では，フォーム
の二つのフィールドに ``help_text`` を指定しています．出力を単純にするために，
``auto_id=False`` を指定しています::

    >>> class HelpTextContactForm(forms.Form):
    ...     subject = forms.CharField(max_length=100, help_text='100 characters max.')
    ...     message = forms.CharField()
    ...     sender = forms.EmailField(help_text='A valid e-mail address, please.')
    ...     cc_myself = forms.BooleanField()
    >>> f = HelpTextContactForm(auto_id=False)
    >>> print f.as_table()
    <tr><th>Subject:</th><td><input type="text" name="subject" maxlength="100" /><br />100 characters max.</td></tr>
    <tr><th>Message:</th><td><input type="text" name="message" /></td></tr>
    <tr><th>Sender:</th><td><input type="text" name="sender" /><br />A valid e-mail address, please.</td></tr>
    <tr><th>Cc myself:</th><td><input type="checkbox" name="cc_myself" /></td></tr>
    >>> print f.as_ul()
    <li>Subject: <input type="text" name="subject" maxlength="100" /> 100 characters max.</li>
    <li>Message: <input type="text" name="message" /></li>
    <li>Sender: <input type="text" name="sender" /> A valid e-mail address, please.</li>
    <li>Cc myself: <input type="checkbox" name="cc_myself" /></li>
    >>> print f.as_p()
    <p>Subject: <input type="text" name="subject" maxlength="100" /> 100 characters max.</p>
    <p>Message: <input type="text" name="message" /></p>
    <p>Sender: <input type="text" name="sender" /> A valid e-mail address, please.</p>
    <p>Cc myself: <input type="checkbox" name="cc_myself" /></p>

.. _Dynamic initial values:

初期値を動的に決定する
----------------------

フィールドオブジェクトの ``initial`` 引数を使えばフィールドの初期値をハード
コードできます．では，初期値を動的に決めたい場合はどうすればよいのでしょう．
例えば，現在ログインしているユーザで ``username`` フィールドを埋めたいよう
な場合です．

動的に初期値を決めるには，フォームオブジェクトの ``initial`` 引数を使います．
この引数はフィールド名と初期値を対応づけた辞書として指定します．全てのフィー
ルドを含める必要はなく，初期値を設定したいフィールドだけでかまいません．例
を示しましょう::

    >>> class CommentForm(forms.Form):
    ...     name = forms.CharField()
    ...     url = forms.URLField()
    ...     comment = forms.CharField()
    >>> f = CommentForm(initial={'name': 'your username'}, auto_id=False)
    >>> print f
    <tr><th>Name:</th><td><input type="text" name="name" value="your username" /></td></tr>
    <tr><th>Url:</th><td><input type="text" name="url" /></td></tr>
    <tr><th>Comment:</th><td><input type="text" name="comment" /></td></tr>
    >>> f = CommentForm(initial={'name': 'another username'}, auto_id=False)
    >>> print f
    <tr><th>Name:</th><td><input type="text" name="name" value="another username" /></td></tr>
    <tr><th>Url:</th><td><input type="text" name="url" /></td></tr>
    <tr><th>Comment:</th><td><input type="text" name="comment" /></td></tr>

フィールドの ``initial`` パラメタと同じく，フォームの初期値が表示されるのは
非束縛フォームだけであり，ユーザが特定のフィールドに値を入力しなかったとき
のフォールバックとしては使われません．

最後に，フィールドに ``initial`` が定義されていて， *かつ* フォームの初期化
時にも ``initial`` を指定した場合，後者の ``initial`` が優先されるので気を
付けてください．例えば，以下のように，フィールドとフォームの両方に
``initial`` を指定した場合，フォームの値の方が使われます::

    >>> class CommentForm(forms.Form):
    ...     name = forms.CharField(initial='class')
    ...     url = forms.URLField()
    ...     comment = forms.CharField()
    >>> f = CommentForm(initial={'name': 'instance'}, auto_id=False)
    >>> print f
    <tr><th>Name:</th><td><input type="text" name="name" value="instance" /></td></tr>
    <tr><th>Url:</th><td><input type="text" name="url" /></td></tr>
    <tr><th>Comment:</th><td><input type="text" name="comment" /></td></tr>


.. _Built-in ``Field`` classes:

組み込みフォームフィールドクラス
--------------------------------

通常， ``newforms`` ライブラリには，一般的なバリデーション機能を備えたフィー
ルドクラスのセットがついてきます．この節では，そうした組み込みフィールドに
ついて述べます．

各フィールドについて， ``widget`` パラメタを指定しなかったときのデフォルト
のウィジェット型について説明しています．また，データが空の値だったとき
(前述の ``requied`` の節を参照してください) に返される値についても定義して
います．

``BooleanField``
~~~~~~~~~~~~~~~~

    * デフォルトのウィジェット: ``CheckboxInput``
    * 空のフォームデータに対する値: ``None``
    * Python データへの正規化: Python の ``True`` または ``False`` 値
    * バリデーションなし (``ValidationError`` を送出しない)

``CharField``
~~~~~~~~~~~~~

    * デフォルトのウィジェット: ``TextInput``
    * 空のフォームデータに対する値: ``''`` (空文字列)
    * Python データへの正規化: Unicode 文字列オブジェクト
    * ``max_length`` や ``min_length`` を指定しないかぎり，
      バリデーションなし

オプションの引数として， ``max_length`` と ``min_length`` の二つをとれます．
これらの引数を指定すると，文字列長が最大，あるいは最小値の条件を満たしてい
るか検証します．

``ChoiceField``
~~~~~~~~~~~~~~~

    * デフォルトのウィジェット: ``Select``
    * 空のフォームデータに対する値: ``''`` (空文字列)
    * Python データへの正規化: Unicode 文字列オブジェクト
    * 入力値が選択肢内にある値かどうか検証します．

追加の引数として， ``choices`` 引数をとります． ``choices`` 引数はイテレー
ション可能オブジェクト (たとえばリストやタプルなど) で，各要素はフィールド
の選択肢として使える 2 要素のタプルでなければなりません．

``DateField``
~~~~~~~~~~~~~

    * デフォルトのウィジェット: ``TextInput``
    * 空のフォームデータに対する値: ``None``
    * Python データへの正規化: Python ``datetime.date`` オブジェクト
    * 入力値が ``datetime.date`` や ``datetime.datetime`` オブジェクト，ま
      たは特定の日付フォーマットの形式に従っているか検証します．

オプションの引数として， ``input_formats`` をとります． ``input_formats``
は，文字列から有効な ``datetime.date`` オブジェクトへの変換を試みるために使
われるフォーマット文字列からなるリストです．

``input_formats`` を指定しない場合，デフォルトで以下の入力フォーマットをサ
ポートします::

    '%Y-%m-%d', '%m/%d/%Y', '%m/%d/%y', # '2006-10-25', '10/25/2006', '10/25/06'
    '%b %d %Y', '%b %d, %Y',            # 'Oct 25 2006', 'Oct 25, 2006'
    '%d %b %Y', '%d %b, %Y',            # '25 Oct 2006', '25 Oct, 2006'
    '%B %d %Y', '%B %d, %Y',            # 'October 25 2006', 'October 25, 2006'
    '%d %B %Y', '%d %B, %Y',            # '25 October 2006', '25 October, 2006'

``DateTimeField``
~~~~~~~~~~~~~~~~~

    * デフォルトのウィジェット: ``TextInput``
    * 空のフォームデータに対する値: ``None``
    * Python データへの正規化: Python ``datetime.datetime`` オブジェクト
    * 入力値が ``datetime.date`` や ``datetime.datetime`` オブジェクト，ま
      たは特定の日付フォーマットの形式に従っているか検証します．

オプションの引数として， ``input_formats`` をとります． ``input_formats``
は，文字列から有効な ``datetime.datetime`` オブジェクトへの変換を試みるため
に使われるフォーマット文字列からなるリストです．

``input_formats`` を指定しない場合，デフォルトで以下の入力フォーマットをサ
ポートします::

    '%Y-%m-%d %H:%M:%S',     # '2006-10-25 14:30:59'
    '%Y-%m-%d %H:%M',        # '2006-10-25 14:30'
    '%Y-%m-%d',              # '2006-10-25'
    '%m/%d/%Y %H:%M:%S',     # '10/25/2006 14:30:59'
    '%m/%d/%Y %H:%M',        # '10/25/2006 14:30'
    '%m/%d/%Y',              # '10/25/2006'
    '%m/%d/%y %H:%M:%S',     # '10/25/06 14:30:59'
    '%m/%d/%y %H:%M',        # '10/25/06 14:30'
    '%m/%d/%y',              # '10/25/06'

``EmailField``
~~~~~~~~~~~~~~

    * デフォルトのウィジェット: ``TextInput``
    * 空のフォームデータに対する値: ``''`` (空文字列)
    * Python データへの正規化: Unicode 文字列オブジェクト
    * やや複雑な正規表現を使って，入力値が有効なメールアドレスであるか検証
      します．

オプションの引数として， ``max_length`` と ``min_length`` の二つをとれます．
これらの引数を指定すると，文字列長が最大，あるいは最小値の条件を満たしてい
るか検証します．

``IntegerField``
~~~~~~~~~~~~~~~~

    * デフォルトのウィジェット: ``TextInput``
    * 空のフォームデータに対する値: ``None``
    * Python データへの正規化: Python 整数型または長整数型
    * 入力値が整数であるか検証します． Python の ``int()`` 関数と同様，先頭
      や末尾に空白があってもかまいません．

``MultipleChoiceField``
~~~~~~~~~~~~~~~~~~~~~~~

    * デフォルトのウィジェット: ``SelectMultiple``
    * 空のフォームデータに対する値: ``[]`` (空のリスト)
    * Python データへの正規化: Unicode 文字列オブジェクトのリスト
    * 入力値のリスト中の全ての値が選択肢内の値であるかどうか検証します．

追加の引数として， ``choices`` 引数をとります． ``choices`` 引数はイテレー
ション可能オブジェクト (たとえばリストやタプルなど) で，各要素はフィールド
の選択肢として使える 2 要素のタプルでなければなりません．

``NullBooleanField``
~~~~~~~~~~~~~~~~~~~~

    * デフォルトのウィジェット: ``NullBooleanSelect``
    * 空のフォームデータに対する値: ``None``
    * Python データへの正規化: ``True``, ``False`` または ``None`` ．
    * バリデーションなし (``VaridationError`` を送出しない)

``RegexField``
~~~~~~~~~~~~~~

    * デフォルトのウィジェット: ``TextInput``
    * 空のフォームデータに対する値: ``''`` (空文字列)
    * Python データへの正規化: Unicode 文字列オブジェクト
    * 入力値が特定の正規表現にマッチするかどうか検証します．

必須の引数 ``regex`` をとります． ``regex`` は正規表現を表す文字列またはコ
ンパイル済みの正規表現オブジェクトです．

また，以下のオプション引数をとります:

    ======================  =================================================
    引数                    説明
    ======================  =================================================
    ``max_length``          文字列の最大長です．
    ``min_length``          文字列の最小長です．
    ``error_message``       バリデーションに失敗したときに返すエラーメッセー
                            ジです．メッセージを指定しなければ，汎用のエラー
              		    メッセージを使います．
    ======================  =================================================

``TimeField``
~~~~~~~~~~~~~

    * デフォルトのウィジェット: ``TextInput``
    * 空のフォームデータに対する値: ``None``
    * Python データへの正規化: Python ``datetime.time`` オブジェクト
    * 入力値が ``datetime.time`` オブジェクトまたは特定の日付フォーマットの
      形式に従っているか検証します．

オプションの引数として， ``input_formats`` をとります． ``input_formats``
は，文字列から有効な ``datetime.time`` オブジェクトへの変換を試みるために使
われるフォーマット文字列からなるリストです．

``input_formats`` を指定しない場合，デフォルトで以下の入力フォーマットをサ
ポートします::

    '%H:%M:%S',     # '14:30:59'
    '%H:%M',        # '14:30'

``URLField``
~~~~~~~~~~~~

    * デフォルトのウィジェット: ``TextInput``
    * 空のフォームデータに対する値: ``''`` (空文字列)
    * Python データへの正規化: Unicode 文字列オブジェクト
    * 入力値が有効な URL であるかどうか検証します．

以下のオプションの引数をとります:

    ========================  ==============================================
    引数                      説明                 Description
    ========================  ==============================================
    ``max_length``            文字列の最大長です．
    ``min_length``            文字列の最小長です．
    ``verify_exists``         ``True`` にすると，バリデータが指定された URL
                              をロードできるか調べ，該当ページの HTTP レス
                              ポンスが 404 のときに ``ValidationError`` を
                              送出します．デフォルト値は ``False`` です．
    ``validator_user_agent``  URL が存在するか確かめるときに使うユーザエー
                              ジェントを表す文字列です．デフォルト値は
                              ``URL_VALIDATOR_USER_AGENT`` 設定の値です．
    ========================  ==============================================

.. _Slightly complex built-in Field classes:

やや複雑な組み込みフィールドクラス
----------------------------------

以下のフィールドはまだドキュメント化されていません．使いかたは，このドキュ
メントの末尾のリンクから辿れる各フィールド型のユニットテストを参照してくだ
さい．

``ComboField``
~~~~~~~~~~~~~~

``MultiValueField``
~~~~~~~~~~~~~~~~~~~

``SplitDateTimeField``
~~~~~~~~~~~~~~~~~~~~~~


.. _Creating custom fields:

カスタムフィールドの作成
------------------------

組み込みのフィールドクラスが用途に合わなくても，カスタムのフィールドクラス
は簡単に作成できるので大丈夫です．カスタムのフィールドクラスは
``django.newforms.Field`` をサブクラス化します．
フィールドクラスを定義する際の制約は， ``clean()`` メソッドを実装すること，
``__init__()`` メソッドが前述のコアとなる引数 (``required``, ``label``,
``initial``, ``widget``, ``help_text``) を持つことだけです．


.. _Custom form and field validation:

フォームやフィールドのバリデーションコードを自作する
----------------------------------------------------

フォームのバリデーションは，データのクリーニングを行ったときに実行されます．
この挙動をカスタマイズしたければ，目的に応じていくつかの手法から選択するこ
とになります．フォームの処理では， 3 つのデータクリーニング過程があります．
これらの過程は通常，フォームの ``is_valid()`` メソッドを呼び出したときに実
行されます．データのクリーニングとバリデーションをトリガする要素は他にもあ
ります (``errors`` 属性へのアクセスや， ``full_clean()`` の呼び出し) が，
通常は直接用いることはありません．

一般に，データクリーニングのメソッドは，処理中のデータに何らかの問題がある
場合， ``ValidationError`` 例外を送出し，その際 ``ValidationError`` のコン
ストラクタにエラーメッセージを渡すことになっています． ``ValidationError``
を送出しない場合，クリーニングメソッドはクリーニング済み (正規化済み) のデー
タを Python オブジェクトとして返さねばなりません．

クリーニング処理中に複数のエラーを検出し，全てのエラーをフォームのユーザに
提示したければ， ``ValidationError`` のコンストラクタにエラーのリストを渡せ
ます．

クリーニングメソッドとは，以下の 3 つです:

    * フィールドサブクラスの ``clean()`` メソッド．このメソッドは，該当フィー
      ルドクラスのインスタンスに共通して必要なクリーニングを行う役割を担いま
      す．例えば， FloatField の ``clean()`` メソッドは，データを Python の
      ``float`` オブジェクトに変換するか， ``ValidationError`` を送出します．

    * フォームサブクラスの ``clean_<fieldname>()`` (``<fieldname>`` はフォー
      ムフィールドを指す属性名) メソッド．このメソッドは特定の属性名のフィー
      ルドに対するクリーニングを行います．フィールドの型は問いません．この
      メソッドはパラメタ無しで呼び出されます．フィールドの値は
      ``self.cleaned_data`` を介して参照せねばならず，値はこの段階ではフォー
      ムとして提出された元の文字列ではなく，Python オブジェクトであることに
      注意してください．(``cleaned_data`` に入るのは，上記の ``clean()`` メ
      ソッドが既にデータを一度クリーニングしているからです．)

      例えば， ``serialnumber`` という名前の ``CharField`` の中身が一意な値
      になるようバリデーションを行いたければ， ``clean_serialnumber()`` を
      使うのが適切です．特定のフィールド (実際には ``CharField``) 向けでは
      なく，フォーム上のフィールド固有のバリデーションや，データのクリーニ
      ング，正規化を行うことになります．

    * フォームのサブクラスの ``clean()`` メソッド．このメソッドは，フォーム
      上の複数のフィールドに一度にアクセスする必要があるようなバリデーショ
      ンを実行できます．「フィールド ``A`` に値が入っている時に，フィールド
      ``B`` には有効なメールアドレスが入っていなければならない」といったバ
      リデーションにはこのメソッドを使います．このメソッドの返すデータは，
      フォームの ``cleaned_data`` 属性の最終的な値になるので，このメソッド
      をオーバライドする場合は必ず全てのクリーニング済みデータを返すように
      してください (デフォルトでは， ``Form.clean()`` は 
      ``self.cleaned_data`` をそのまま返します)．

      オーバライドされた ``Form.clean()`` の送出するエラーは特定のフィー
      ルドではなく，(``__all__`` という名の)「特殊なフィールド」に関連づけ
      られます．エラーは ``non_field_errors()`` でアクセスできます．

上に挙げたメソッドは，各フィールドごとに一度づつ，上に挙げた順に呼び出され
ます．すなわち，フォームの各フィールドについて， (フォーム定義で宣言した順
に) まず ``Field.clean()`` メソッドを呼び出し，次いで 
``cleaned_<fieldname>()`` ，を呼びます．最後に， ``Form.clean()`` メソッド
(オーバライドされていればそれを) を呼び出します．

先程も書いた通り，上記のメソッドは ``VaridationError`` を送出することがあり
ます．個々のフィールドで， ``Field.clean()`` メソッドが ``ValidationError``
を送出した場合，フォーム上のフィールドごとのクリーニングメソッドは呼び出さ
れません．ただし，残りの全てのフィールドに対するクリーニング処理は最後まで
行われます．

フォームクラスやサブクラスに対する ``clean()`` メソッドは常に実行されます．
このメソッドが ``VaridationError`` を送出する場合， ``cleaned_data`` は空の
辞書になります．

前の段落の意味するところは， ``Form.clean()`` をオーバライドする場合，
``self.cleaned_data.items()`` の各要素を調べ，さらにフォームの ``_errors`` 
属性も考慮して，どのフィールドが個別のバリデーション用件を満たしているかを
調べる必要があるということです．

.. _A simple example:

簡単な例
~~~~~~~~

入力値がカンマで区切られたメールアドレスになっていて，少なくとも一つアドレ
スが入っているかどうか検証するカスタムフィールドの例を以下に示します．簡単
のため，個々のメールアドレスの検証は ``is_valid_email()`` という関数で行っ
ていることにします．クラスの全体像は以下のようになります::

    from django import newforms as forms

    class MultiEmailField(forms.Field):
        def clean(self, value):
            emails = value.split(',')
            for email in emails:
                if not is_valid_email(email):
                    raise forms.ValidationError('%s is not a valid e-mail address.' % email)
            if not emails:
                raise forms.ValidationError('Enter at least one e-mail address.')
            return emails

件の ``ContactForm`` の例を使って，上のカスタムフィールドをフォームで使って
みます．以下のように， ``forms.EmailField`` を ``MultiEmailField`` に置き換
えてください::

    class ContactForm(forms.Form):
        subject = forms.CharField(max_length=100)
        message = forms.CharField()
        senders = MultiEmailField()
        cc_myself = forms.BooleanField()


.. _Generating forms for models:

モデルからフォームを生成する
============================

データベース指向のアプリケーションを開発しているなら， Django のモデルとほ
ぼ同じ内容のフォームを作ることもあるでしょう．たとえば， ``BlogComment`` と
いうモデルを作っておき，ユーザがコメントを入力できるようなフォームを作成し
たいような場合です．こうした状況では，フォームの中でフィールドタイプをい
ちいち定義するのは二度手間というものです．なぜなら，モデル中にすでにフィー
ルドを定義しているからです．

そこで， Django では， Django モデルからフォームクラスを生成できるヘルパ関
数をいくつか提供しています．

``form_for_model()``
--------------------

``django.newforms.form_for_model()`` メソッドは，引数に指定したモデルの定義
に従ってフォームを生成します．このメソッドは，モデルクラスを渡すとフォーム
クラスを返します．フォームクラスの中には，モデル中の各フィールドに対応した
フォームフィールドが入っています．

例を示します::

    >>> from django.newforms import form_for_model

    # Create the form class.
    >>> ArticleForm = form_for_model(Article)

    # Create an empty form instance.
    >>> f = ArticleForm()

繰り返しになりますが， ``form_for_model()`` は，モデルのインスタンスでなく，
*クラス* を引数にとり，フォームクラスのインスタンスではなく *クラス* を返し
ます．

.. _Field types:

フィールド型
~~~~~~~~~~~~

生成されたフォームクラスは，各モデルフィールドに対応したフォームフィールド
を持っています．各モデルフィールドは，デフォルトのフォームフィールドに対応
しています．たとえば，モデルクラス上の ``CharField`` は，フォーム上でも
``CharField`` 型のフォームフィールドとして表現されます ``ManyToManyField``
は ``MultipleChoiceField`` として表現されます．モデルフィールド型からフォー
ムフィールド型への変換表を以下に示します:

    ===============================  ========================================
    モデルフィールド                 フォームフィールド
    ===============================  ========================================
    ``AutoField``                    フィールド上に表示されません
    ``BooleanField``                 ``BooleanField``
    ``CharField``                    ``max_length`` がモデルフィールドの
                                     ``maxlength`` と同じ値の ``CharField``
    ``CommaSeparatedIntegerField``   ``CharField``
    ``DateField``                    ``DateField``
    ``DateTimeField``                ``DateTimeField``
    ``DecimalField``                 ``DecimalField``
    ``EmailField``                   ``EmailField``
    ``FileField``                    ``CharField``
    ``FilePathField``                ``CharField``
    ``FloatField``                   ``FloatField``
    ``ForeignKey``                   ``ModelChoiceField`` (下記参照)
    ``ImageField``                   ``CharField``
    ``IntegerField``                 ``IntegerField``
    ``IPAddressField``               ``CharField``
    ``ManyToManyField``              ``ModelMultipleChoiceField`` (下記参照)
    ``NullBooleanField``             ``CharField``
    ``PhoneNumberField``             (``django.contrib.localflavor.us`` の)
                                     ``USPhoneNumberField``
    ``PositiveIntegerField``         ``IntegerField``
    ``PositiveSmallIntegerField``    ``IntegerField``
    ``SlugField``                    ``CharField``
    ``SmallIntegerField``            ``IntegerField``
    ``TextField``                    ``widget=Textarea`` の ``CharField``
    ``TimeField``                    ``TimeField``
    ``URLField``                     ``verify_exists`` が モデルフィールド
                                     の ``verify_exists`` と同じ値の 
                                     ``URLField``
    ``USStateField``                 ``widget=USStateSelect`` の ``CharField``
                                     (``USStateSelect`` は
                                     ``django.contrib.localflavor.us`` から)
    ``XMLField``                     ``widget=Textarea`` の ``CharField``
    ===============================  ========================================



.. note::
    ``FloatField`` フォームフィールドと， ``DecimalField`` モデルフィールド
    およびフォームフィールドは，開発版で新たに登場した機能です．

``ForeignKey`` と ``ManyToManyField`` モデルフィールド型は特別なケースとし
て扱われます:

    * ``ForeignKey`` は ``django.newforms.ModelChoiceField`` になります．
      これは選択肢が ``QuerySet`` の内容であるような ``ChoiceField`` です．

    * ``ManyToManyField`` は ``django.newforms.ModelMultipleChoiceField``
      で表されます．これは選択肢が ``QuerySet`` の内容であるような
      ``MultipleChoiceField`` です．

加えて，各フォームフィールドには以下のような属性が追加されます:

    * モデルフィールドが ``blank=True`` の場合，対応するフォームフィールド
      の ``required`` 属性が ``False`` になります．それ以外の場合は
      ``required=True`` です．

    * フォームフィールドの ``label`` 属性は，モデルフィールドの
      ``verbose_name`` の頭文字を大文字にしたものになります．

    * フォームフィールドの ``help_text`` 属性は，モデルフィールドの
      ``help_text`` の値になります．

    * モデルフィールドに ``choices`` が設定されている場合，フォームフィール
      ドの ``widget`` 型は ``Select`` になり，選択肢として ``choices`` の内
      容が使われます．

最後に，モデルフィールドから生成したフォームフィールドの値はオーバライドで
きるということに注意してください．詳しくは後述の
「 `デフォルトフィールド型のオーバライド`_ 」 を参照してください．

.. _`デフォルトフィールド型のオーバライド`: `Overriding the default field types`_


.. _A full example:

詳細な例
~~~~~~~~

まず，以下のようなモデル群を想定します::

    from django.db import models

    TITLE_CHOICES = (
        ('MR', 'Mr.'),
        ('MRS', 'Mrs.'),
        ('MS', 'Ms.'),
    )

    class Author(models.Model):
        name = models.CharField(maxlength=100)
        title = models.CharField(maxlength=3, choices=TITLE_CHOICES)
        birth_date = models.DateField(blank=True, null=True)

        def __unicode__(self):
            return self.name

    class Book(models.Model):
        name = models.CharField(maxlength=100)
        authors = models.ManyToManyField(Author)

``form_for_model(Author)`` を呼び出すと，以下のクラスと等価なフォームクラス
を返します::

    class AuthorForm(forms.Form):
        name = forms.CharField(max_length=100)
        title = forms.CharField(max_length=3,
                    widget=forms.Select(choices=TITLE_CHOICES))
        birth_date = forms.DateField(required=False)

``form_for_model(Book)`` を呼び出すと，以下のクラスと等価なフォームクラス
を返します::

    class BookForm(forms.Form):
        name = forms.CharField(max_length=100)
        authors = forms.ModelMultipleChoiceField(queryset=Author.objects.all())

.. _`The save() method`:

``save()`` メソッド
~~~~~~~~~~~~~~~~~~~

``form_for_model()`` で生成したフォームにも， ``save()`` メソッドがあります．
``save()`` メソッドは，フォームに結びつけられたデータベースオブジェクトの生
成と保存を行います．例えば::

    # POST データからフォームインスタンスを生成する
    >>> f = ArticleForm(request.POST)

    # フォームのデータから新たな Article オブジェクトを生成して保存する
    >>> new_article = f.save()

``save()`` は，フォーム中のデータの検証に成功していない場合，つまり，
``form.errors`` が真の場合に ``ValueError`` を送出します．

.. _Using an alternate base class:

フォームのベースクラスを変更する
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

``form_for_model()`` が生成するフォームにカスタムのメソッドを追加したい場合，
``django.newfdorms.BaseForm`` を拡張して，その中にカスタムメソッドを入れま
す．そして， ``form_for_model()`` を呼び出す際に， ``form`` パラメタに自作
のフォームを指定してベースクラスにさせます::

    # 自作のベースクラスを作成する
    >>> class MyBase(BaseForm):
    ...     def my_method(self):
    ...         # Do whatever the method does

    # 自作のベースクラスを使ってフォームクラスを生成する
    >>> ArticleForm = form_for_model(Article, form=MyBase)

    # フォームのインスタンス化
    >>> f = ArticleForm()

    # ベースクラスのメソッドを使う
    >>> f.my_method()

.. _Using a subset of fields on the form:

フォームの一部のフィールドだけを使う
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

**開発版の Django で新たに追加された機能です**

場合によっては，モデルからフォームを生成する際に，モデルの一部のフィールド
だけを表示したいこともあるでしょう． ``form_for_model()`` に入れるフィール
ドを，モデルフィールドのサブセットにするには，二つの方法があります:

    1. モデルのフィールドに ``editable=False`` を設定しておくと，
       ``form_for_model()`` から生成されたフォームは *常に* そのフィールド
       を含まなくなります．

    2. ``form_for_model()`` に ``fields`` 引数を指定します．この引数を指定
       する場合，フォームに含めたいフィールド名のリストにせねばなりません．

       例えば， ``Author`` モデルからフォームを生成するときに， ``name`` と
       ``title`` フィールドだけをフォームに含めたいなら， ``fields`` を以下
       のように定義します::

           PartialArticleForm = form_for_model(Author, fields=('name', 'title'))

.. note::

    ``form_for_model()`` に ``fields`` を指定してフォームを生成する場合，
    フォームに *含めない* フィールドは，デフォルト値を持つか ``None`` を値
    にとりえるフィールドであるかよく確認してください．フォーム内に含まれな
    いフィールドがあると，フォームを使ってオブジェクトを生成した際に，フィー
    ルドから値が提供されないことがあり，そのためにインスタンスを保存できな
    くなるからです．

.. _Overriding the default field types:

デフォルトのフィールド型をオーバライドする
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

上の `フィールド型 <#field-types>`_ に挙げたデフォルトフィールド型は，いわ
ゆる「気の利いたデフォルト値」にすぎません．モデルに ``DateField`` が入って
いる場合，普通はフォームにも ``DateField`` が入っていてほしいでしょう．
とはいえ， ``form_for_model()`` は，特定のモデルフィールドに対してフォー
ムのフィールド型を変更できるという柔軟さも備えています．フィールド型の変更
は「フォームフィールドコールバック (formfield callback)」で行います．

フォームフィールドコールバック関数は，モデルフィールドを指定して呼び出すと，
フォームフィールドのインスタンスを返します．フォームを生成する際，
``form_for_model()`` はフォームフィールドコールバックを使って，フォームフィー
ルドの型を決定します．

デフォルトでは， ``form_for_model()`` は，モデルフィールドの
``formfield()`` メソッドを呼び出します::

    def default_callback(field, **kwargs):
        return field.formfield(**kwargs)

``kwargs`` は， ``required=True`` や ``label='Foo'`` のような，フォームフィー
ルドに渡されることになるキーワード引数です．

例えば，モデル上の全ての ``DateField`` に対して ``MyDateFormField`` を使い
たい場合，以下のようにコールバックを定義します::

    >>> def my_callback(field, **kwargs):
    ...     if isinstance(field, models.DateField):
    ...         return MyDateFormField(**kwargs)
    ...     else:
    ...         return field.formfield(**kwargs)

    >>> ArticleForm = form_for_model(formfield_callback=my_callback)

コールバックは，自分がデフォルト設定に対して手を加えたい対象のフィールド以
外も含めた， *全ての* モデルフィールドを扱えねばならないので注意が必要です．
上の例で ``else`` 節にデフォルトの挙動を実装しているのはそのためです．

.. _Finding the model associated with a form:

フォームに関連づけられたモデルを取り出す
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

フォームの構築に使われたモデルクラスは，生成されたフォームの ``_model`` プ
ロパティからアクセスできます::

    >>> ArticleForm = form_for_model(Article)
    >>> ArticleForm._model
    <class 'myapp.models.Article'>

``form_for_instance()``
-----------------------

``form_for_instance()`` は ``form_for_model()`` に似ていますが，モデルのク
ラスではなく，モデルのインスタンスを引数にとります::

    # Author オブジェクトを生成
    >>> a = Author(name='Joe Smith', title='MR', birth_date=None)
    >>> a.save()

    # 特定の Author オブジェクト用のフォームを生成
    >>> AuthorForm = form_for_instance(a)

    # フォームのインスタンス化
    >>> f = AuthorForm()

``form_for_instance()`` で生成したフォームクラスでインスタンスを生成すると，
フォームフィールドの初期値はインスタンスから取り出されます．ただし，このデー
タはフォームに結びつけられていません．従って，フォームを保存する前に，デー
タをフォームに結びつける必要があります．

``form_for_instance()`` で生成したフォームのインスタンスに対して ``save()``
を呼び出すと，データベース上のインスタンスが更新されます．
``form_for_model()`` と同様，データの検証に失敗すると， ``save()`` は
``ValueError`` 例外を送出します．

``form_for_instance()`` は， ``form``, ``fields`` および
``formfield_callback`` パラメタをとります．これらの引数の挙動は
``form_for_model()`` の同名の引数と同じです．

.. _When should you use form_for_model() and form_for_instance():

``form_for_model()`` や ``form_for_instance()`` はいつ使うもの?
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

``form_for_model()`` や ``form_for_instance()`` は，一般的なケースを扱うた
めのショートカットにすぎません．こうしたショートカットは，複数のモデルのフィー
ルドをマップするフォームや，モデル上に *ない* フィールドの入ったフォームを
生成したい場合には利用できません．それに，フォームクラスをこつこつ作成する
のはちっとも難しい作業ではありません．


.. _More coming soon:

つづく
======

現時点でのドキュメントはこれだけです．詳しくは ``django.newforms`` のユニッ
トテストである
http://code.djangoproject.com/browser/django/trunk/tests/regressiontests/forms/tests.py
を参照してください． newforms でできることをよく理解できるはずです．

このライブラリを使ってみたくてうずうずしているなら，もう少しだけ我慢してく
ださいね．今，コードとドキュメントの仕上げにかかっているところなんです．

