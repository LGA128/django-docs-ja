===================
newforms ライブラリ
===================

:revision-up-to: 4828 (0.96+ SVN)

``django.newforms`` は， Django に新たに導入された画期的なフォーム処理ライ
ブラリで，従来のフォーム／マニピュレータ／バリデータフレームワークである
``django.forms`` を置き換えるものです．このドキュメントでは，新たなフォーム
ライブラリの使い方について解説します．

.. _Migration plan:

移行の計画
==========

現在のところ， ``django.newforms`` を利用できるのはリリース 0.96 以降のバー
ジョンの Django だけです．今後リリースに向けて，我々は以下のような移行計画
を立てています:

    * リビジョン [4208] で，現在の ``django.forms`` を ``django.oldforms``
      にコピーしました．これで，互換性のない変更を座して待つことなく，
      *今すぐ* コードの修正に取り掛かれます．修正は，各アプリケーションのコー
      ドを以下のように書き換えるだけです::

          from django import forms             # 移行前
          from django import oldforms as forms # 移行後

    * まだ具体的な日程は決まっていませんが，現在の ``django.newforms`` を
      ``django.forms`` に移動します．これは互換性のない変更なので，以前の
      ``django.forms`` を使い続けたい人は，上記に従って import 文を変更する
      必要があります．

    * 次の Django リリース，すなわち新たな ``django.forms`` が導入されたリ
      リースの *後に* ， ``django.oldforms`` をコードから除去します．

この移行計画を念頭に， ``django.newforms`` を使う場合には以下のような
import 文を使うように勧めます::

    from django import newforms as forms

こうしておけば，フォームライブラリを ``forms`` モジュールとして参照でき，
``django.newforms`` が ``django.forms`` になったときに ``import`` 文を書き
換えるだけで済みます．

「 ``import *`` 」構文を使いたければ以下のようにできます::

    from django.newforms import *

上の命令は，全てのフィールド，ウィジェット，フォームクラスと検証のためのユー
ティリティをローカルな名前空間に import します．便利と考える人も，美しくな
いと考える人もいるでしょう．

.. _Overview:

概要
====

``django.newforms`` は，以前の ``django.forms`` (「マニピュレータ」) システ
ムと同じく， HTML フォームを表示し，データ処理 (検証) を行って再表示するた
めのライブラリです．HTML フォームをサーバ側で検証する場合に使います．

例えば， Web サイトに連絡用フォームを設置し，訪問者が電子メールでメッセージ
を送信できるようにしたいなら，このライブラリを使って HTML フォームフィール
ドを表示し，フォームの値を検証できます．このライブラリは， HTML の
``<form>`` タグが必要になるような状況で利用できるわけです．

このライブラリでは，以下のような概念を扱います:

    * **ウィジェット (Widget)** -- ``<input type="text">`` や
      ``<textarea>`` のような， HTML フォームウィジェットに対応するクラスで
      す．ウィジェットから HTML へのレンダリングもこのクラスで行われます．

    * **フィールド (Field)** -- データの検証を行うためのクラスです．例えば，
      ``EmailField`` はデータが有効な電子メールアドレスかどうか検証します．

    * **フォーム (Form)** -- フィールドの集まりで，データの検証や HTML への
      表示方法が実装されたものです．

このライブラリは，データベースレイヤやビュー，テンプレートといった他の
Django コンポーネントに対してカップリングしていません． newforms ライブラリ
が依存しているのは settings と ``django.utils`` の二つのヘルパ関数，そして
国際化のためのフック (ただし，このライブラリを使うために国際化の機能を使わ
ねばならないわけではありません) だけです．

.. _Form objects:

フォームオブジェクト
====================

``newforms`` ライブラリの第一の用途はフォームオブジェクト (form object) の
作成にあります．フォームオブジェクトは， ``django.newforms.Form`` クラスを
サブクラス化して，フォームのフィールドを定義して作成します．フォームのフィー
ルド定義は Django のデータベースモデルで親しんでいるあの記述方法で行えます．
この節では，自分のウェブサイトに「連絡フォーム (contact me)」の機能を実装す
るためのフォームオブジェクトを逐次開発してゆきます．

まずは ``ContactForm`` という名前で ``Form`` のサブクラスを作成するところか
らはじめましょう::

    from django import newforms as forms

    class ContactForm(forms.Form):
        subject = forms.CharField(max_length=100)
        message = forms.CharField()
        sender = forms.EmailField()
        cc_myself = forms.BooleanField()

フォームは ``Field`` オブジェクトの組み合わせでできています．今回の例では，
``subject`` (題名)， ``message`` (メッセージ)， ``sender`` (送信者)，そして
``cc_myself`` (自分に CC する)，の 4 つのフィールドをフォームに持たせます．
``CharField`` や ``EmailField`` といったフィールド型については，また後で説
明する予定です．

.. _Creating Form instances:

``Form`` のインスタンスを生成する
---------------------------------

``Form`` のインスタンスには，何らかのデータの集まりと結び付いたもの
(**束縛 (bound) フォーム**) と，そうでないもの
(**非束縛 (unbound) フォーム**) があります．

    * データと **結び付いている** フォームは，データを検証機能する機能と， 
      フォームを HTML にレンダリングするときにデータを HTML 形式で表示する
      機能をあわせ持っています．

    * データと **結び付いていない** フォームには検証機能はありません (検証
      すべきデータがないから当然ですね!) が，空のフォームを HTML としてレン
      ダリングする機能は備えています．

非束縛フォームのインスタンスを生成するには，単にフォームクラスのインスタン
ス化を行います::

    >>> f = ContactForm()

フォームにデータを結び付けるには，データの入った辞書をフォームクラスのコン
ストラクタの第一引数に渡します::

    >>> data = {'subject': 'hello',
    ...         'message': 'Hi there',
    ...         'sender': 'foo@example.com',
    ...         'cc_myself': True}
    >>> f = ContactForm(data)

この辞書の中では，キーは各フィールドの名前であり，フォームクラスの各属性に
対応しています．値は検証すべきデータです．通常，値は文字列にしますが，必ず
しも文字列でなくてかまいません．値にどんなデータ型を指定指定できるかは，フィー
ルドの型に依存します．

実行時に束縛フォームと非束縛フォームを区別したければ，フォームの
``is_bound`` 属性を調べてください::

    >>> f = ContactForm()
    >>> f.is_bound
    False
    >>> f = ContactForm({'subject': 'hello'})
    >>> f.is_bound
    True

空の辞書を渡すと，空のデータの入った *束縛フォーム* を返します::

    >>> f = ContactForm({})
    >>> f.is_bound
    True

束縛フォームのインスタンスに入っているデータに何らかの変更を加えたい場合や，
束縛フォームを変換して，何らかのデータの入った非束縛フォームにしたい場合に
は，新たにフォームインスタンスを生成してください．フォームインスタンス内の
データを変更する方法はありません．一度フォームインスタンスを生成したら，デー
タの有無に関わらず，インスタンス内のデータは変更不能だと考えてください．

.. _Using forms to validate data:

フォームを使ってデータを検証する
--------------------------------

フォームオブジェクトの主要な役割はデータの検証です．束縛フォームのインスタ
ンスに対して ``is_valid()`` メソッドを呼び出すと，データの検証を行って，そ
の結果をブール値で返します::

    >>> data = {'subject': 'hello',
    ...         'message': 'Hi there',
    ...         'sender': 'foo@example.com',
    ...         'cc_myself': True}
    >>> f = ContactForm(data)
    >>> f.is_valid()
    True

無効なデータを入れてみましょう．例えば， ``subject`` を空にしてみます
(フィールドは全てデフォルトで必須なためエラーになります)．また，
``sender`` に不正なメールアドレス情報を入れてみます::

    >>> data = {'subject': '',
    ...         'message': 'Hi there',
    ...         'sender': 'invalid e-mail address',
    ...         'cc_myself': True}
    >>> f = ContactForm(data)
    >>> f.is_valid()
    False

``Form`` の ``errors`` という属性にアクセスすると，エラーメッセージの入った
辞書を参照できます::

    >>> f.errors
    {'sender': [u'Enter a valid e-mail address.'], 'subject': [u'This field is required.']}

この辞書は，フィールド名がキーに，エラーメッセージを表す Unicode 文字列のリ
ストが値になっています．エラーメッセージがリストになっているのは，一つのフィー
ルドに対して複数のエラーが存在し得るからです．

``is_valid()`` を呼ばなくても ``errors`` にはアクセスできます．
``is_valid()`` を呼び出すか， ``errors`` にアクセスすると，フォームのデータ
は自動的に検証されます．

.. _Behavior of unbound forms:

非束縛フォームの動作
~~~~~~~~~~~~~~~~~~~~

データを含まないようなフォームの検証は無意味でしかありませんが，参考までに
非束縛フォームに対する検証を行ったときの動作を示しておきます::

    >>> f = ContactForm()
    >>> f.is_valid()
    False
    >>> f.errors
    {}

.. _Accessing "clean" data:

「クリーニング済み」のデータにアクセスする
------------------------------------------

フォームクラスの各フィールドには，データの検証だけでなく，「クリーニング」
を行う役割もあります．データのクリーニングとは，データを一貫性のある書式に
正規化することです．データのクリーニングはとても素晴らしい機能で，クリーニ
ングを行うと，ユーザがフィールドに色々な形式でデータを入力しても，常に一貫
性を持った出力を得られます．

例えば， ``DateField`` はデータを Python の ``datetime.date`` オブジェクト
に正規化します．フィールドの値は， ``'1994-07-15'`` のような形式の文字列で
も， ``datetime.date`` オブジェクトでも，その他の形式でも， ``DateField``
は有効なデータであるかぎり，常に出力を ``datetime.date`` オブジェクトで正規
化します．

データセットの入ったフォームインスタンスを生成して検証を行うと， 
``clean_data`` 属性を介してクリーニング済みのデータにアクセスできるようにな
ります::

    >>> data = {'subject': 'hello',
    ...         'message': 'Hi there',
    ...         'sender': 'foo@example.com',
    ...         'cc_myself': True}
    >>> f = ContactForm(data)
    >>> f.is_valid()
    True
    >>> f.clean_data
    {'cc_myself': True, 'message': u'Hi there', 'sender': u'foo@example.com', 'subject': u'hello'}

``CharField`` や ``EmailField`` のようなテキストベースのフィールドは，常に
入力を Unicode 文字列に変換します．エンコーディングに関する解説は，このドキュ
メントの後の方でカバーする予定です．

データが *まだ検証されていない* 場合，フォームインスタンスには
``clean_data`` 属性がありません::

    >>> data = {'subject': '',
    ...         'message': 'Hi there',
    ...         'sender': 'invalid e-mail address',
    ...         'cc_myself': True}
    >>> f = ContactForm(data)
    >>> f.is_valid()
    False
    >>> f.clean_data
    Traceback (most recent call last):
    ...
    AttributeError: 'ContactForm' object has no attribute 'clean_data'

フォームを生成するときに追加の値を渡した場合でも， ``clean_data`` の中に入
るキーは，フォーム内で定義されているフィールド *だけ* です．以下の例でも，
``ContactForm`` のコンストラクタに追加のフィールドデータを渡していますが，
``clean_data`` が返すのは ``ContactForm`` で定義されているフィールドだけで
す::

    >>> data = {'subject': 'hello',
    ...         'message': 'Hi there',
    ...         'sender': 'foo@example.com',
    ...         'cc_myself': True,
    ...         'extra_field_1': 'foo',
    ...         'extra_field_2': 'bar',
    ...         'extra_field_3': 'baz'}
    >>> f = ContactForm(data)
    >>> f.is_valid()
    True
    >>> f.clean_data # Doesn't contain extra_field_1, etc.
    {'cc_myself': True, 'message': u'Hi there', 'sender': u'foo@example.com', 'subject': u'hello'}


.. .. _Behavior of unbound forms:

非束縛フォームの動作
~~~~~~~~~~~~~~~~~~~~

データの入っていないフォームをクリーニングしても無意味ですが，参考までに非
束縛フォームでの挙動を示します::

    >>> f = ContactForm()
    >>> f.clean_data
    Traceback (most recent call last):
    ...
    AttributeError: 'ContactForm' object has no attribute 'clean_data'


.. _Outputting forms as HTML:

フォームを HTML として出力する
------------------------------

フォームオブジェクトの二つ目の仕事は，フォームの HTML へのレンダリングです．
フォームを HTML として出力するには，フォームをインスタンス化して，
``print`` で出力します::

    >>> f = ContactForm()
    >>> print f
    <tr><th><label for="id_subject">Subject:</label></th><td><input id="id_subject" type="text" name="subject" maxlength="100" /></td></tr>
    <tr><th><label for="id_message">Message:</label></th><td><input type="text" name="message" id="id_message" /></td></tr>
    <tr><th><label for="id_sender">Sender:</label></th><td><input type="text" name="sender" id="id_sender" /></td></tr>
    <tr><th><label for="id_cc_myself">Cc myself:</label></th><td><input type="checkbox" name="cc_myself" id="id_cc_myself" /></td></tr>

束縛フォームの場合，フォームのデータは適切な形で HTML 出力されます．例えば，
フィールドが ``<input type="text">`` で表される場合，データは ``value`` 属
性の中に出力されます．フィールドが ``<input type="checkbox">`` であれば，
必要に応じて ``checked="checked"`` が入ります::

    >>> data = {'subject': 'hello',
    ...         'message': 'Hi there',
    ...         'sender': 'foo@example.com',
    ...         'cc_myself': True}
    >>> f = ContactForm(data)
    >>> print f
    <tr><th><label for="id_subject">Subject:</label></th><td><input id="id_subject" type="text" name="subject" maxlength="100" value="hello" /></td></tr>
    <tr><th><label for="id_message">Message:</label></th><td><input type="text" name="message" id="id_message" value="Hi there" /></td></tr>
    <tr><th><label for="id_sender">Sender:</label></th><td><input type="text" name="sender" id="id_sender" value="foo@example.com" /></td></tr>
    <tr><th><label for="id_cc_myself">Cc myself:</label></th><td><input type="checkbox" name="cc_myself" id="id_cc_myself" checked="checked" /></td></tr>

デフォルトの出力は 2 カラムの HTML テーブルになり，各フィールドが一つの
``<tr>`` タグの中に収まります．以下の点に注意してください:

    * 柔軟性をもたせるために，出力中には ``<table>`` と ``</table>`` タグが
      入っていません．また， ``<form>`` と ``</form>`` や， 
      ``<input type="submit">`` もありません．これらのタグは自分で入れる必
      要があります．

    * 各フィールドタイプには，それぞれデフォルトの HTML 表現があります．
      ``CharField`` や ``EmailField`` は ``<input type="text">`` で表され，
      ``BooleanField`` は ``<input type="checkbox">`` になります．とはいえ，
      これらは便利なデフォルト値にすぎません．ウィジェット (widget) を使え
      ば，フィールドの表現にどのような HTML を使うかを指定できます．これに
      ついては後で説明する予定です．

    * 各タグの ``name`` 属性は ``ContactForm`` クラスの属性名から直接取り出
      して使われます．

    * ``'Subject:'``, ``'Message:'``, ``'Cc myself:'``  といった各フィール
      ドのテキストラベルは，フィールド名のアンダースコアを全てスペースに変
      換し，先頭の文字を大文字にして生成します．これもまたデフォルト値にす
      ぎず，手動でもラベルを設定できるようになっています．

    * 各テキストラベルは HTML の ``<label>`` タグで囲われています．このタグ
      には ``for`` 属性が付いていて，対応するフォームフィールドの ``id`` 属
      性に対応しています．属性の値はフィールド名の前に ``'id_'`` を付けたも
      のになります． ``id`` 属性や ``<label>`` タグはフォーム生成の定石に従っ
      て組み込まれているものですが，この振舞は自分で変更できます．

テーブル組みによる出力は ``print`` した時に出力されるデフォルトで，他にもい
くつか出力スタイルがあります．各スタイルはフォームオブジェクトのメソッドと
して利用でき，各々のレンダリングメソッドは Unicode オブジェクトを返すように
なっています．

``as_p()``
~~~~~~~~~~

``Form.as_p()`` はフォームを一連の ``<p>`` タグの集まりで組みます．各
``<p>`` タグの中に一つのフィールドが入ります::

    >>> f = ContactForm()
    >>> f.as_p()
    u'<p><label for="id_subject">Subject:</label> <input id="id_subject" type="text" name="subject" maxlength="100" /></p>\n<p><label for="id_message">Message:</label> <input type="text" name="message" id="id_message" /></p>\n<p><label for="id_sender">Sender:</label> <input type="text" name="sender" id="id_sender" /></p>\n<p><label for="id_cc_myself">Cc myself:</label> <input type="checkbox" name="cc_myself" id="id_cc_myself" /></p>'
    >>> print f.as_p()
    <p><label for="id_subject">Subject:</label> <input id="id_subject" type="text" name="subject" maxlength="100" /></p>
    <p><label for="id_message">Message:</label> <input type="text" name="message" id="id_message" /></p>
    <p><label for="id_sender">Sender:</label> <input type="text" name="sender" id="id_sender" /></p>
    <p><label for="id_cc_myself">Cc myself:</label> <input type="checkbox" name="cc_myself" id="id_cc_myself" /></p>

``as_ul()``
~~~~~~~~~~~

``Form.as_ul()`` はフォームを一連の ``<li>`` タグで組みます．各 ``<li>`` タ
グの中に一つのフィールドが入ります． ``as_ul()`` は ``<ul>`` や ``</ul>``
を出力に *含めません* ．これは，ユーザが ``<ul>`` タグの HTML 属性を好きに
指定できるようにするためです::

    >>> f = ContactForm()
    >>> f.as_ul()
    u'<li><label for="id_subject">Subject:</label> <input id="id_subject" type="text" name="subject" maxlength="100" /></li>\n<li><label for="id_message">Message:</label> <input type="text" name="message" id="id_message" /></li>\n<li><label for="id_sender">Sender:</label> <input type="text" name="sender" id="id_sender" /></li>\n<li><label for="id_cc_myself">Cc myself:</label> <input type="checkbox" name="cc_myself" id="id_cc_myself" /></li>'
    >>> print f.as_ul()
    <li><label for="id_subject">Subject:</label> <input id="id_subject" type="text" name="subject" maxlength="100" /></li>
    <li><label for="id_message">Message:</label> <input type="text" name="message" id="id_message" /></li>
    <li><label for="id_sender">Sender:</label> <input type="text" name="sender" id="id_sender" /></li>
    <li><label for="id_cc_myself">Cc myself:</label> <input type="checkbox" name="cc_myself" id="id_cc_myself" /></li>

``as_table()``
~~~~~~~~~~~~~~

最後に， ``Form.as_table()`` はフォームを ``<table>`` で組みます．これは
``print`` で出力したときに使われる形式と同じです．実際，フォームオブジェク
トを ``print`` すると，背後では ``as_table()`` が呼び出されるようになってい
ます::

    >>> f = ContactForm()
    >>> f.as_table()
    u'<tr><th><label for="id_subject">Subject:</label></th><td><input id="id_subject" type="text" name="subject" maxlength="100" /></td></tr>\n<tr><th><label for="id_message">Message:</label></th><td><input type="text" name="message" id="id_message" /></td></tr>\n<tr><th><label for="id_sender">Sender:</label></th><td><input type="text" name="sender" id="id_sender" /></td></tr>\n<tr><th><label for="id_cc_myself">Cc myself:</label></th><td><input type="checkbox" name="cc_myself" id="id_cc_myself" /></td></tr>'
    >>> print f.as_table()
    <tr><th><label for="id_subject">Subject:</label></th><td><input id="id_subject" type="text" name="subject" maxlength="100" /></td></tr>
    <tr><th><label for="id_message">Message:</label></th><td><input type="text" name="message" id="id_message" /></td></tr>
    <tr><th><label for="id_sender">Sender:</label></th><td><input type="text" name="sender" id="id_sender" /></td></tr>
    <tr><th><label for="id_cc_myself">Cc myself:</label></th><td><input type="checkbox" name="cc_myself" id="id_cc_myself" /></td></tr>

.. _Configuring HTML ``<label>`` tags:

``<label>`` タグの出力設定
~~~~~~~~~~~~~~~~~~~~~~~~~~

``<label>`` タグは，あるラベルテキストがどのフォーム要素に対応づけられてい
るかを知らせるタグです． ``<label>`` タグがあると，フォームの利便性が増し，
入力補助デバイスで操作しやすくなります． ``<label>`` タグは常に使うようにし
ておくよう勧めます．

デフォルトでは，フォームのレンダリングメソッドを呼び出すと，各フォーム要素
に ``id`` 属性が追加され，ラベルを ``<label>`` タグで囲って出力します．
``id`` 属性の値はフォームのフィールド名の前に ``id_`` を付けたものになりま
す．とはいえ， ``id`` 属性の命名規則を変えたり，そもそも ``<label>`` を出力
したくない人のために，この仕様は設定変更できるようになっています．

``<label>`` タグや ``id`` の挙動を変更するには， ``Form`` コンストラクタの
``auto_id`` 引数を使います．この引数は ``True`` ， ``False`` ，文字列のいず
れかで指定せねばなりません．

``auto_id`` を ``False`` にすると，フォーム出力に ``<label>`` タグや
``id`` 属性が含まれなくなります::

    >>> f = ContactForm(auto_id=False)
    >>> print f.as_table()
    <tr><th>Subject:</th><td><input type="text" name="subject" maxlength="100" /></td></tr>
    <tr><th>Message:</th><td><input type="text" name="message" /></td></tr>
    <tr><th>Sender:</th><td><input type="text" name="sender" /></td></tr>
    <tr><th>Cc myself:</th><td><input type="checkbox" name="cc_myself" /></td></tr>
    >>> print f.as_ul()
    <li>Subject: <input type="text" name="subject" maxlength="100" /></li>
    <li>Message: <input type="text" name="message" /></li>
    <li>Sender: <input type="text" name="sender" /></li>
    <li>Cc myself: <input type="checkbox" name="cc_myself" /></li>
    >>> print f.as_p()
    <p>Subject: <input type="text" name="subject" maxlength="100" /></p>
    <p>Message: <input type="text" name="message" /></p>
    <p>Sender: <input type="text" name="sender" /></p>
    <p>Cc myself: <input type="checkbox" name="cc_myself" /></p>

``auto_id`` が ``True`` の場合，フォームの出力には ``<label>`` タグが入り，
各フォームフィールドの ``id`` 属性の値にはフィールド名をそのまま使います::

    >>> f = ContactForm(auto_id=True)
    >>> print f.as_table()
    <tr><th><label for="subject">Subject:</label></th><td><input id="subject" type="text" name="subject" maxlength="100" /></td></tr>
    <tr><th><label for="message">Message:</label></th><td><input type="text" name="message" id="message" /></td></tr>
    <tr><th><label for="sender">Sender:</label></th><td><input type="text" name="sender" id="sender" /></td></tr>
    <tr><th><label for="cc_myself">Cc myself:</label></th><td><input type="checkbox" name="cc_myself" id="cc_myself" /></td></tr>
    >>> print f.as_ul()
    <li><label for="subject">Subject:</label> <input id="subject" type="text" name="subject" maxlength="100" /></li>
    <li><label for="message">Message:</label> <input type="text" name="message" id="message" /></li>
    <li><label for="sender">Sender:</label> <input type="text" name="sender" id="sender" /></li>
    <li><label for="cc_myself">Cc myself:</label> <input type="checkbox" name="cc_myself" id="cc_myself" /></li>
    >>> print f.as_p()
    <p><label for="subject">Subject:</label> <input id="subject" type="text" name="subject" maxlength="100" /></p>
    <p><label for="message">Message:</label> <input type="text" name="message" id="message" /></p>
    <p><label for="sender">Sender:</label> <input type="text" name="sender" id="sender" /></p>
    <p><label for="cc_myself">Cc myself:</label> <input type="checkbox" name="cc_myself" id="cc_myself" /></p>

``auto_id`` がフォーマット文字 ``'%s'`` を含む文字列になっている場合，フォー
ム出力は ``<label>`` タグを含むようになり，タグの ``id`` 属性はフォーマット
文字列に従って生成されます．例えば，フォーマット文字列が ``field_%s`` の場
合， ``subject`` という名前のフィールドの ``id`` は ``'field_subject'`` に
なります．出力例は以下のようになります::

    >>> f = ContactForm(auto_id='id_for_%s')
    >>> print f.as_table()
    <tr><th><label for="id_for_subject">Subject:</label></th><td><input id="id_for_subject" type="text" name="subject" maxlength="100" /></td></tr>
    <tr><th><label for="id_for_message">Message:</label></th><td><input type="text" name="message" id="id_for_message" /></td></tr>
    <tr><th><label for="id_for_sender">Sender:</label></th><td><input type="text" name="sender" id="id_for_sender" /></td></tr>
    <tr><th><label for="id_for_cc_myself">Cc myself:</label></th><td><input type="checkbox" name="cc_myself" id="id_for_cc_myself" /></td></tr>
    >>> print f.as_ul()
    <li><label for="id_for_subject">Subject:</label> <input id="id_for_subject" type="text" name="subject" maxlength="100" /></li>
    <li><label for="id_for_message">Message:</label> <input type="text" name="message" id="id_for_message" /></li>
    <li><label for="id_for_sender">Sender:</label> <input type="text" name="sender" id="id_for_sender" /></li>
    <li><label for="id_for_cc_myself">Cc myself:</label> <input type="checkbox" name="cc_myself" id="id_for_cc_myself" /></li>
    >>> print f.as_p()
    <p><label for="id_for_subject">Subject:</label> <input id="id_for_subject" type="text" name="subject" maxlength="100" /></p>
    <p><label for="id_for_message">Message:</label> <input type="text" name="message" id="id_for_message" /></p>
    <p><label for="id_for_sender">Sender:</label> <input type="text" name="sender" id="id_for_sender" /></p>
    <p><label for="id_for_cc_myself">Cc myself:</label> <input type="checkbox" name="cc_myself" id="id_for_cc_myself" /></p>

``auto_id`` がこれ以外の偽でない値，つまり ``%s`` を含まない文字列のような
値の場合， ``auto_id`` は ``True`` に設定されたものとみなされます．

デフォルトでは， ``auto_id`` は ``'id_%s'`` に設定されています．

.. _Notes on field ordering:

フィールドの並び順について
~~~~~~~~~~~~~~~~~~~~~~~~~~

``as_p()`` や ``as_ul()``, ``as_table()`` ショートカットを使うと，各フィー
ルドは Form クラス内で定義された順に出力されます．例えば，上の
``ContactForm`` の例では，フィールドの並び順は ``subject``, ``message``,
``sender``, ``cc_myself`` になります． HTML 出力の中でフィールドの並び順を
変更したければ，クラス定義内でのフィールドの並び順を変更してください．

.. _How errors are displayed:

エラーの出力方法
~~~~~~~~~~~~~~~~

束縛フォームオブジェクトをレンダすると，フォームの検証がまだであればレンダ
リング操作の中で自動的に検証が行われ，エラーがあれば HTML 出力中の該当フィー
ルドの付近に ``<ul>`` でエラー内容が表示されます．エラーメッセージ中の具体
的なエラー表示位置は，どのメソッドでフォームをレンダしているかによります::

    >>> data = {'subject': '',
    ...         'message': 'Hi there',
    ...         'sender': 'invalid e-mail address',
    ...         'cc_myself': True}
    >>> f = ContactForm(data, auto_id=False)
    >>> print f.as_table()
    <tr><th>Subject:</th><td><ul class="errorlist"><li>This field is required.</li></ul><input type="text" name="subject" maxlength="100" /></td></tr>
    <tr><th>Message:</th><td><input type="text" name="message" value="Hi there" /></td></tr>
    <tr><th>Sender:</th><td><ul class="errorlist"><li>Enter a valid e-mail address.</li></ul><input type="text" name="sender" value="invalid e-mail address" /></td></tr>
    <tr><th>Cc myself:</th><td><input checked="checked" type="checkbox" name="cc_myself" /></td></tr>
    >>> print f.as_ul()
    <li><ul class="errorlist"><li>This field is required.</li></ul>Subject: <input type="text" name="subject" maxlength="100" /></li>
    <li>Message: <input type="text" name="message" value="Hi there" /></li>
    <li><ul class="errorlist"><li>Enter a valid e-mail address.</li></ul>Sender: <input type="text" name="sender" value="invalid e-mail address" /></li>
    <li>Cc myself: <input checked="checked" type="checkbox" name="cc_myself" /></li>
    >>> print f.as_p()
    <p><ul class="errorlist"><li>This field is required.</li></ul></p>
    <p>Subject: <input type="text" name="subject" maxlength="100" /></p>
    <p>Message: <input type="text" name="message" value="Hi there" /></p>
    <p><ul class="errorlist"><li>Enter a valid e-mail address.</li></ul></p>
    <p>Sender: <input type="text" name="sender" value="invalid e-mail address" /></p>
    <p>Cc myself: <input checked="checked" type="checkbox" name="cc_myself" /></p>

.. _More granular output:

より細かな出力調整
~~~~~~~~~~~~~~~~~~

``as_p()`` や ``as_ul()``, ``as_table()`` といったメソッドは，単に面倒臭が
りの開発者むけに用意されているショートカットでしかなく，他のやり方でもフォー
ムを表示できます．

フォーム中のあるフィールドの HTML を表示するには，フォームを辞書のように扱
い，フィールドの名前をキーにして参照し，その値を出力します::

    >>> f = ContactForm()
    >>> print f['subject']
    <input id="id_subject" type="text" name="subject" maxlength="100" />
    >>> print f['message']
    <input type="text" name="message" id="id_message" />
    >>> print f['sender']
    <input type="text" name="sender" id="id_sender" />
    >>> print f['cc_myself']
    <input type="checkbox" name="cc_myself" id="id_cc_myself" />

フィールドを引数にして ``str()`` や ``unicode()`` を呼び出すと，レンダ結果
の HTML をそれぞれ string 型や Unicode 型のオブジェクトで返します::

    >>> str(f['subject'])
    '<input id="id_subject" type="text" name="subject" maxlength="100" />'
    >>> unicode(f['subject'])
    u'<input id="id_subject" type="text" name="subject" maxlength="100" />'

フィールド固有の出力を行った場合でも，フォームオブジェクトの ``auto_id`` 設
定は有効です::

    >>> f = ContactForm(auto_id=False)
    >>> print f['message']
    <input type="text" name="message" />
    >>> f = ContactForm(auto_id='id_%s')
    >>> print f['message']
    <input type="text" name="message" id="id_message" />

あるフィールドに関するエラーのリストを取得するには，フィールドの ``errors``
属性にアクセスします．このフィールドはリストライクなオブジェクトで， HTML
として出力すると ``<ul>`` のリストになります::

    >>> data = {'subject': 'hi', 'message': '', 'sender': '', 'cc_myself': ''}
    >>> f = ContactForm(data, auto_id=False)
    >>> print f['message']
    <input type="text" name="message" />
    >>> f['message'].errors
    [u'This field is required.']
    >>> print f['message'].errors
    <ul class="errorlist"><li>This field is required.</li></ul>
    >>> f['subject'].errors
    []
    >>> print f['subject'].errors

    >>> str(f['subject'].errors)
    ''

.. _Subclassing forms:

フォームのサブクラス化
----------------------

フォームクラスをサブクラス化して自作する場合，できたフォームクラスには親ク
ラスの全てのフィールドが入っています．サブクラスで定義したフィールドは親ク
ラスのフィールドの後に続きます．

以下の例では， ``ContactFormWithPriority`` には ``ContactForm`` の全てのフィー
ルドと， ``priority`` という追加のフィールドが入っています．
``ContactForm`` のフィールドは先に表示されます::

    >>> class ContactFormWithPriority(ContactForm):
    ...     priority = forms.CharField()
    >>> f = ContactFormWithPriority(auto_id=False)
    >>> print f.as_ul()
    <li>Subject: <input type="text" name="subject" maxlength="100" /></li>
    <li>Message: <input type="text" name="message" /></li>
    <li>Sender: <input type="text" name="sender" /></li>
    <li>Cc myself: <input type="checkbox" name="cc_myself" /></li>
    <li>Priority: <input type="text" name="priority" /></li>

複数のフォームを親クラスにしたサブクラス化も可能です．この場合，親クラスの
フォームは「混ぜ込み (mix-in)」クラスのように扱われます．以下の例では，
``BeatleForm`` が ``PersonForm`` と ``InstrumentForm`` を (この順番で)
サブクラス化しています．フィールドのリストには，親クラスのフィールドが順番
に表示されます::

    >>> class PersonForm(Form):
    ...     first_name = CharField()
    ...     last_name = CharField()
    >>> class InstrumentForm(Form):
    ...     instrument = CharField()
    >>> class BeatleForm(PersonForm, InstrumentForm):
    ...     haircut_type = CharField()
    >>> b = BeatleForm(auto_id=False)
    >>> print b.as_ul()
    <li>First name: <input type="text" name="first_name" /></li>
    <li>Last name: <input type="text" name="last_name" /></li>
    <li>Instrument: <input type="text" name="instrument" /></li>
    <li>Haircut type: <input type="text" name="haircut_type" /></li>


.. _Fields:

フィールド
==========

フォームクラスの作成で一番重要なのは，フォームの各フィールドの定義です．各
フィールドは固有のデータ検証ロジックと，いくつかのフックが備わっています．

フィールドクラスの主な用途はフォームクラスにおけるフィールド定義ですが，フィー
ルドクラスは直接インスタンス化して使えるので，フィールドの動作を理解する役
に立つはずです．各フィールドインスタンスは ``clean()`` メソッドを備えており，
単一の引数を取って検証を行い，その結果に応じて
``django.newforms.ValidationError`` を送出するか，クリーニング済みの値を返
します::

    >>> f = forms.EmailField()
    >>> f.clean('foo@example.com')
    u'foo@example.com'
    >>> f.clean(u'foo@example.com')
    u'foo@example.com'
    >>> f.clean('invalid e-mail address')
    Traceback (most recent call last):
    ...
    ValidationError: [u'Enter a valid e-mail address.']

Django の古いフォーム／検証フレームワークを使ったことがある人は，この
``VaridationError`` が以前の ``VaridationError`` とは別の例外であることに注
意してください．以前の例外は ``django.core.validators.ValidationError`` で
すが，新たな例外は ``django.newforms.ValidationError`` です．

.. _Core field arguments:

フィールドの主な引数
--------------------

各フィールドクラスのコンストラクタは，少なくとも以下に示す引数を取ります．
フィールドクラスによっては他にもフィールド固有の引数をとりますが．ここに示
す引数はどのフィールドクラスでも *常に* 指定できる引数です:

``required``
~~~~~~~~~~~~

デフォルトでは，フィールドクラスはフィールドが必須 (reqired) であると仮定し
ています．従って，フィールドに空の値，すなわち ``None`` や空文字列 (``""``)
を渡すと， ``clean()`` は ``VaridationError`` 例外を送出します::

    >>> f = forms.CharField()
    >>> f.clean('foo')
    u'foo'
    >>> f.clean('')
    Traceback (most recent call last):
    ...
    ValidationError: [u'This field is required.']
    >>> f.clean(None)
    Traceback (most recent call last):
    ...
    ValidationError: [u'This field is required.']
    >>> f.clean(' ')
    u' '
    >>> f.clean(0)
    u'0'
    >>> f.clean(True)
    u'True'
    >>> f.clean(False)
    u'False'

必須で *ない* フィールドにするには，フィールドのコンストラクタに
``required=False`` を指定します::

    >>> f = forms.CharField(required=False)
    >>> f.clean('foo')
    u'foo'
    >>> f.clean('')
    u''
    >>> f.clean(None)
    u''
    >>> f.clean(0)
    u'0'
    >>> f.clean(True)
    u'True'
    >>> f.clean(False)
    u'False'

``required=False`` のフィールドの ``clean()`` に空の値を渡して呼び出すと，
``clean()`` は ``VaridationError`` を送出する代わりに *正規化された* 空の値
を返します．例えば ``CharField`` の場合なら， Unicode の空文字列になります．
その他のフィールドクラスでは ``None`` になるはずです (フィールドによって異
なります)．

``label``
~~~~~~~~~

``label`` 引数を使うと，フィールドに「人間に優しい」ラベルを指定できます．
このラベルはフォーム内でフィールドを表示するときに使われます．

上の `フォームを HTML として出力する <#outputting_forms_as_html>`_ で説明し
たように，フィールドのデフォルトのラベルはフィールド名のアンダースコアを除
去して，頭文字を大文字にしたものです．デフォルトのラベル命名規則が期待通り
のラベルを出力しない場合には，この引数を指定してください．

``label`` を指定したフォームの例を以下に示します．出力を短くするために
``auto_id=False`` にしています::

    >>> class CommentForm(forms.Form):
    ...     name = forms.CharField(label='Your name')
    ...     url = forms.URLField(label='Your Web site', required=False)
    ...     comment = forms.CharField()
    >>> f = CommentForm(auto_id=False)
    >>> print f
    <tr><th>Your name:</th><td><input type="text" name="name" /></td></tr>
    <tr><th>Your Web site:</th><td><input type="text" name="url" /></td></tr>
    <tr><th>Comment:</th><td><input type="text" name="comment" /></td></tr>

``initial``
~~~~~~~~~~~

``initial`` 引数を使うと，非束縛フォーム内でフィールドをレンダするときの初
期値を指定できます．

この引数を使うケースは，例えば以下のように，「空の」フォームの各フィールド
を特定の値で初期化して表示したい場合です::

    >>> class CommentForm(forms.Form):
    ...     name = forms.CharField(initial='Your name')
    ...     url = forms.URLField(initial='http://')
    ...     comment = forms.CharField()
    >>> f = CommentForm(auto_id=False)
    >>> print f
    <tr><th>Name:</th><td><input type="text" name="name" value="Your name" /></td></tr>
    <tr><th>Url:</th><td><input type="text" name="url" value="http://" /></td></tr>
    <tr><th>Comment:</th><td><input type="text" name="comment" /></td></tr>

こんなことをしなくても，フォームに初期データの入った辞書を渡せばいいのにと
思うかもしれませんね．しかし，フォームにデータを渡して束縛フォームにすると，
データを表示する際に検証がトリガされてしまい， HTML 出力にバリデーションエ
ラーが入ってしまいます::

    >>> class CommentForm(forms.Form):
    ...     name = forms.CharField()
    ...     url = forms.URLField()
    ...     comment = forms.CharField()
    >>> default_data = {'name': 'Your name', 'url': 'http://'}
    >>> f = CommentForm(default_data, auto_id=False)
    >>> print f
    <tr><th>Name:</th><td><input type="text" name="name" value="Your name" /></td></tr>
    <tr><th>Url:</th><td><ul class="errorlist"><li>Enter a valid URL.</li></ul><input type="text" name="url" value="http://" /></td></tr>
    <tr><th>Comment:</th><td><ul class="errorlist"><li>This field is required.</li></ul><input type="text" name="comment" /></td></tr>

このため，非束縛フォームの場合に限って ``initial`` に指定した値が出力される
ようになっているのです．束縛フォームの場合，出力は常に束縛済みのデータにな
ります．

また， ``initial`` の指定値は，フィールドの値が指定されなかった場合の
「フォールバック用の」値には *ならない* ので注意が必要です．
``initial`` の値は初期値の入ったフォームの表示 *だけ* に用いられます::

    >>> class CommentForm(forms.Form):
    ...     name = forms.CharField(initial='Your name')
    ...     url = forms.URLField(initial='http://')
    ...     comment = forms.CharField()
    >>> data = {'name': '', 'url': '', 'comment': 'Foo'}
    >>> f = CommentForm(data)
    >>> f.is_valid()
    False
    # フォームの値は初期値にフォールバック *しません．*
    >>> f.errors
    {'url': [u'This field is required.'], 'name': [u'This field is required.']}

``widget``
~~~~~~~~~~

``widget`` 引数を使うと，フィールドをレンダリングするときの ``Widget`` クラ
スを指定できます．詳しくは後述の `ウィジェット <#widgets>`_ を参照してくだ
さい．

``help_text``
~~~~~~~~~~~~~

``help_text`` 引数を使うと，フィールドに説明文をつけられます．
``help_text`` を指定した場合，その内容がフォームをレンダした時に該当フィー
ルドの隣に表示されます．

以下に， ``help_text`` を使ったフォームの例を示します．この例では，フォーム
の二つのフィールドに ``help_text`` を指定しています．出力を単純にするために，
``auto_id=False`` を指定しています::

    >>> class HelpTextContactForm(forms.Form):
    ...     subject = forms.CharField(max_length=100, help_text='100 characters max.')
    ...     message = forms.CharField()
    ...     sender = forms.EmailField(help_text='A valid e-mail address, please.')
    ...     cc_myself = forms.BooleanField()
    >>> f = HelpTextContactForm(auto_id=False)
    >>> print f.as_table()
    <tr><th>Subject:</th><td><input type="text" name="subject" maxlength="100" /><br />100 characters max.</td></tr>
    <tr><th>Message:</th><td><input type="text" name="message" /></td></tr>
    <tr><th>Sender:</th><td><input type="text" name="sender" /><br />A valid e-mail address, please.</td></tr>
    <tr><th>Cc myself:</th><td><input type="checkbox" name="cc_myself" /></td></tr>
    >>> print f.as_ul()
    <li>Subject: <input type="text" name="subject" maxlength="100" /> 100 characters max.</li>
    <li>Message: <input type="text" name="message" /></li>
    <li>Sender: <input type="text" name="sender" /> A valid e-mail address, please.</li>
    <li>Cc myself: <input type="checkbox" name="cc_myself" /></li>
    >>> print f.as_p()
    <p>Subject: <input type="text" name="subject" maxlength="100" /> 100 characters max.</p>
    <p>Message: <input type="text" name="message" /></p>
    <p>Sender: <input type="text" name="sender" /> A valid e-mail address, please.</p>
    <p>Cc myself: <input type="checkbox" name="cc_myself" /></p>

.. _Dynamic initial values:

初期値を動的に決定する
----------------------

フィールドオブジェクトの ``initial`` 引数を使えばフィールドの初期値をハード
コードできます．では，初期値を動的に決めたい場合はどうすればよいのでしょう．
例えば，現在ログインしているユーザで ``username`` フィールドを埋めたいよう
な場合です．

動的に初期値を決めるには，フォームオブジェクトの ``initial`` 引数を使います．
この引数はフィールド名と初期値を対応づけた辞書として指定します．全てのフィー
ルドを含める必要はなく，初期値を設定したいフィールドだけでかまいません．例
を示しましょう::

    >>> class CommentForm(forms.Form):
    ...     name = forms.CharField()
    ...     url = forms.URLField()
    ...     comment = forms.CharField()
    >>> f = CommentForm(initial={'name': 'your username'}, auto_id=False)
    >>> print f
    <tr><th>Name:</th><td><input type="text" name="name" value="your username" /></td></tr>
    <tr><th>Url:</th><td><input type="text" name="url" /></td></tr>
    <tr><th>Comment:</th><td><input type="text" name="comment" /></td></tr>
    >>> f = CommentForm(initial={'name': 'another username'}, auto_id=False)
    >>> print f
    <tr><th>Name:</th><td><input type="text" name="name" value="another username" /></td></tr>
    <tr><th>Url:</th><td><input type="text" name="url" /></td></tr>
    <tr><th>Comment:</th><td><input type="text" name="comment" /></td></tr>

フィールドの ``initial`` パラメタと同じく，フォームの初期値が表示されるのは
非束縛フォームだけであり，ユーザが特定のフィールドに値を入力しなかったとき
のフォールバックとしては使われません．

最後に，フィールドに ``initial`` が定義されていて， *かつ* フォームの初期化
時にも ``initial`` を指定した場合，後者の ``initial`` が優先されるので気を
付けてください．例えば，以下のように，フィールドとフォームの両方に
``initial`` を指定した場合，フォームの値の方が使われます::

    >>> class CommentForm(forms.Form):
    ...     name = forms.CharField(initial='class')
    ...     url = forms.URLField()
    ...     comment = forms.CharField()
    >>> f = CommentForm(initial={'name': 'instance'}, auto_id=False)
    >>> print f
    <tr><th>Name:</th><td><input type="text" name="name" value="instance" /></td></tr>
    <tr><th>Url:</th><td><input type="text" name="url" /></td></tr>
    <tr><th>Comment:</th><td><input type="text" name="comment" /></td></tr>


.. _Creating custom fields:

カスタムフィールドの作成
------------------------

組み込みのフィールドクラスが用途に合わなくても，カスタムのフィールドクラス
は簡単に作成できるので大丈夫です．カスタムのフィールドクラスは
``django.newforms.Field`` をサブクラス化します．
フィールドクラスを定義する際の制約は， ``clean()`` メソッドを実装すること，
``__init__()`` メソッドが前述のコアとなる引数 (``required``, ``label``,
``initial``, ``widget``, ``help_text``) を持つことだけです．

.. _More coming soon:

つづく
======

現時点でのドキュメントはこれだけです．詳しくは ``django.newforms`` のユニッ
トテストである
http://code.djangoproject.com/browser/django/trunk/tests/regressiontests/forms/tests.py
を参照してください． newforms でできることをよく理解できるはずです．

このライブラリを使ってみたくてうずうずしているなら，もう少しだけ我慢してく
ださいね．今，コードとドキュメントの仕上げにかかっているところなんです．

.. _Widgets:

ウィジェット
============

(この部分はまだ未完成です [4293], 2007/1/7.)
