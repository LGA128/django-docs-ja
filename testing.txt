==============================
Djangoアプリケーションのテスト
==============================

:revision-up-to: 5418 (0.97pre SVN)

今日の Web 開発者にとって，自動化されたテストはバグ潰しの工程で極めて有用な
ツールです．複数のテストを集めた **テストスイート** を使えば，Web開発におけ
るいくつもの問題を解決したり回避したりできます:

  * 新たなコードを書く際，コードが期待通りに動作するかテストできます．

  * 以前のコードを修正したりリファクタする場合，テストによって，コードの変
    更がアプリケーションに意図しない影響を及ぼさないか調べられます．

Web アプリケーションは， HTTP レベルのリクエスト処理，フォームの検証と処理，
そしてテンプレートレンダリングまで，複数のロジックレイヤから構成されていま
す．そのため，Webアプリケーションのテストは複雑なタスクです． Django のテス
ト実行フレームワークと関連ユーティリティを使えば，仮想的なリクエストを発行
したり，テストデータを挿入したり，アプリケーションの出力を調べて，コードが
期待通りに動作しているか検証したりできます．

しかも素晴らしいことに，テストはとても簡単なのです．

.. admonition:: note
    
    このテストフレームワークは現在開発中なので，次の公式リリースまでに多少
    の変更が加わるかもしれません．

    (だからといって，テスト書きをサボる理由にはなりませんよ！)

.. _Writing tests:

テストを書く
============

Django におけるテストは doctest と単体テストの二つの形式をとります．

.. _Writing doctests:

doctest を書く
--------------

doctest には， docstring (ドキュメンテーション文字列) 内のテストを探して実
行するための Python の標準モジュール， doctest_ を使います． Django のテス
トランナは ``models.py`` ファイル内の doctest を探し，見つかったテストを実
行します． Django はまた，アプリケーションのディレクトリ (``models.py`` ファ
イルがあるのと同じディレクトリ) 内の ``test.py`` というファイルを探し，
``tests.py`` があれば，その中に doctest がないか探します．


.. admonition:: **docstring** とは?

    docstring の詳しい説明 (と，効果的な docstring の書き方) は，
    :PEP:`257` (`和訳
    <http://www.python.jp/doc/contrib/peps/pep-0257.txt>`__) に書かれていま
    す:
        
        docstring とは，モジュールや関数，クラス，メソッド定義のブロック中
        の先頭に置かれた文字列リテラルです． docstring を定義すると，オブジェ
        クトの ``__doc__`` という特殊な属性になります．
        
    テストはそれ自体が素晴らしいドキュメントになります． doctest を使うと，
    テストを直接 docstring の中に配置できます．

doctest の文字列は ``models.py`` の全てのオブジェクトに対して記述できますが，
慣習的には，アプリケーションレベルの doctest はモジュールの docstring に，
モデルレベルの doctest は各モデルの docstring に配置します．

例を示します::

    from django.db import model
    
    class Animal(models.Model):
        """
        鳴き声から動物を調べるテスト
        
        # 動物インスタンスを生成する
        >>> lion = Animal.objects.create(name="lion", sound="roar")
        >>> cat = Animal.objects.create(name="cat", sound="meow")
        
        # speak() を呼び出す
        >>> lion.speak()
        'The lion says "roar"'
        >>> cat.speak()
        'The cat says "meow"'
        """
        
        name = models.CharField(maxlength=20)
        sound = models.CharField(maxlength=20)
        
        def speak(self):
            return 'The %s says "%s"' % (self.name, self.sound)


`テストを実行する`_ と，テストユーティリティは上の docstring を探し出して，
Python の対話セッションに見える部分を検出し，そこに書かれた命令を実行して，
docstring に書かれた結果と実際の実行結果が一致するかどうかを確かめます．

doctest の詳しい動作原理は， `標準ドキュメントの doctest の項`_
を参照してください．

.. doctest: http://docs.python.org/lib/module-doctest.html
.. _standard library documentation for doctest: doctest_
.. _doctest: http://python.jp/doc/release/lib/module-doctest.html
.. _`標準ドキュメントの doctest の項`: doctest_

.. _Writing unittests:

unittest を書く
---------------

Django の単体テストもまた，doctest と同様，標準ライブラリモジュールの
unittest_ を使います． doctest と同様， Django のテストランナは，アプリケー
ションディレクトリ内の ``models.py`` または ``test.py`` 内に定義されている
単体テストを探します．

上の例と同じ内容のテストを unittest のテストケースで書くと以下のようになり
ます::

    import unittest
    from myapp.models import Animal
    
    class AnimalTestCase(unittest.TestCase):
        
        def setUp(self):
            self.lion = Animal.objects.create(name="lion", sound="roar")
            self.cat = Animal.objects.create(name="cat", sound="meow")
        
        def testSpeaking(self):
            self.assertEquals(self.lion.speak(), 'The lion says "roar"')
            self.assertEquals(self.cat.speak(), 'The cat says "meow"')
            
`テストを実行する`_ と，テストユーティリティは ``models.py`` と
``tests.py`` に入っている全てのテストケース (``unittest.TestCase`` のサブク
ラス) を探しだし，そこからテストスイートを自動的に構築して，スイートを実行
します．

``unittest`` の詳細は `標準ライブラリドキュメントの unittest の項`_ を参照
してください．

.. unittest: http://docs.python.org/lib/module-unittest.html
.. _standard library unittest documentation: unittest_
.. _run your tests: `Running tests`_
.. _`テストを実行する`: `Running tests`_
.. _unittest: http://python.jp/doc/release/lib/module-unittest.html
.. _`標準ライブラリドキュメントの unittest の項`: unittest_

.. _Which should I use?:

どちらのテストを使うべきか
--------------------------

テストフレームワークの選択にまつわる議論は時として過熱ぎみになります．そこ
で，Django では二つの Python 標準テストフレームワークの両方をサポートしまし
た．どちらを選ぶかは，開発者個々人の好みに任せますし，どちらかをひいきにす
るということもありません．二つのテストフレームワークにはそれぞれの長所があ
るので，書きたいテストのタイプに合ったテストシステムをその都度選びながら，
両方を使いこなすのがベストだと思います．

とはいえ，テストを初めて書く開発者にとって，選択を行わねばならないのは混乱
のもとになるでしょう．ですから，ここでは doctest と単体テストの主な違いにつ
いて示し，どちらのテストを使うべきかを決める時の手がかりにしてもらおうと思
います．

そこそこ Python に慣れているなら， ``doctest`` の方がより "pythonic" だと感
じることでしょう． doctest はテストをできるだけ楽に書けるように設計されてい
るので，クラスやメソッドを書くときのオーバヘッドがほとんどありません．単に
docstring にテストを書くだけでよいのです．それに，モジュールに対してドキュ
メントを自動生成させられるという利点もあります．つまり， doctest を上手に書
けば，ドキュメント作成とテストを同時に片付けられて一石二鳥，というわけです．

また，テストにまだ慣れていない開発者は， doctest を使った方が早くテストにつ
いて学べることでしょう．

Java での開発経験のある開発者なら， ``unittest`` フレームワークはとても理解
しやすいはずです． ``unittest`` は Java の JUnit に影響を受けているので，
他の言語で JUnit から派生したテストフレームワークを使ったことがあるのなら，
``unittest`` はかなりしっくりくるはずです．

``unittest`` はクラスとメソッドを使って構築するので，一連のテストを書くとき
にコードを共有でき，より短く，きれいにテストコードを書けます．また，
``unittest`` はテストの初期化／終了処理のルーチンをサポートしているので，テ
ストケースを実行するときの環境を高い水準でコントロールできます．

繰り返しになりますが，(一つのアプリケーションの中であっても) 両方のシステム
を並べて使えることを忘れないでください．どちらのテストシステムにも，状況に
応じて適した部分があるので，大抵のプロジェクトでは，最終的には両方のテスト
システムを使うことになるものです．

.. _Testing Tools:

テストツール
====================

Django は，アプリケーションの様々な機能に対するテストを補助するために，テス
ト自体やテスト環境の構築に使えるツールを提供しています．

* `テストクライアント`_
* `TestCaseクラス`_
* `メールサービス`_


.. _`テストクライアント`: `Test Client`_
.. _`TestCaseクラス`: `TestCase`_
.. _`メールサービス`: `E-mail services`_

.. _Test Client:

テストクライアント
------------------

テストクライアント (Test Client) は簡単なダミーブラウザです．テストクライア
ントを使うと，ある URL に対する GET や POST をシミュレートでき，リクエスト
に対するレスポンスを調べられます．テストクライアントを使えば，特定の URL に
対して正しいビューが呼び出されるかどうか，また，ビューが正しいレスポンスを
生成しているかどうかをテストできます．

テストクライアントは，ビューがレスポンスを生成する際に，ビューが利用した
``Template`` オブジェクトと ``Context`` オブジェクトに関する情報を取得しま
す．これらの情報はビューからのレスポンスの一部として返され，テスト条件とし
て利用できます．

.. admonition:: テストクライアントか，それともブラウザを自動化すべきか？

    テストクライアントは Twill_ や Selenium_ やその他ブラウザ自動化フレーム
    ワークの置き換えを狙ったものではありません．テストクライアントの目的は，
    エンドユーザに提供される HTML 自体のチェックではなく，ビューが使うコン
    テキストやテンプレートの内容のテストにあります．
    
    網羅的なテストスイートを実現したいのなら，テストクライアントと自動化ブ
    ラウザの両方を使うべきでしょう．テストクライアントは，正しいビューが呼
    び出されているか，そしてビューが正しいコンテキストデータを用意している
    かのテストを行います．一方，自動化ブラウザは，ユーザインタフェースが期
    待通りに動作しているかのテストを行います．
    
.. _Twill: http://twill.idyll.org/
.. _Selenium: http://www.openqa.org/selenium/

.. _Making requests:

リクエスト生成
~~~~~~~~~~~~~~

``Client`` (``django.test.client.Client``) のインスタンスは引数なしで生成し
ます． ``Client`` のインスタンスからは，以下のメソッドを呼び出せます．

``get(path, data={})``
    ``path`` に対する GET リクエストを行います．引数 ``data`` は辞書オブジェ
    クトで，キー／値のペアが GET データのペイロードの生成に使われます．例え
    ば::

        c = Client()
        c.get('/customers/details/', {'name':'fred', 'age':7})

    は，以下のような GET リクエストの送信と同じです::

        http://yoursite.com/customers/details/?name=fred&age=7

``post(path, data={}, content_type=MULTIPART_CONTENT)``
    ``path`` に対する POST リクエストを行います． ``content_type`` を
    指定した場合 (例えば XML ペイロードの場合には ``text/xml``)，引数
    ``data`` の中身は POST リクエストそのままで送信され， 
    ``Content-Type`` ヘッダの値は ``content_type`` の値になります．

    ``content_type`` を指定しなければ， ``data`` の中身は
    ``multipart/form-data`` で送信されます．

    ``data`` の中のキー／値のペアは，マルチパートメッセージにエンコードされ，
    POST データのペイロードになります．

    あるキーに対して複数の値を提出 (submit) する場合 (複数選択可能なリスト
    に対する選択内容を指定する場合など) は，キーに対する値をリストやタプル
    にしてください．例えば， ``{'choices': ('a', 'b', 'd')}`` のようにする
    と， ``choices`` という名前のフィールドから 3 つの行を選択して提出した
    のと同じになります．

    ただし，ファイルの送信は特別な扱いが必要です．ファイルの POST を行う場
    合，ファイル名フィールドの名前をキーに，アップロードしたいファイルのファ
    イルハンドルを値に設定します．テストクライアントは FileField が要求する
    二つの POST フィールド (``field`` と ``field_file``) に値を設定します．
    例えば::

        c = Client()
        f = open('wishlist.doc')
        c.post('/customers/wishes/', {'name':'fred', 'attachment':f})
        f.close()

    のようにすると， ``/customers/wishes/`` に対する POST リクエストの送信
    と同じになります．ビュー側の ``request.POST`` 辞書には `name`,
    `aatachment` (ファイル名), `attachment_file` (ファイルデータ) が入りま
    す．送信するファイルのハンドルは， POST データの送信後に手動で閉じる必
    要があります．

``login(**credentials)``
    **開発バージョンの Django で新たに追加されました**

    運用環境では，匿名のアクセスからビューを保護するために，一部のビューを
    ``django.contrib.auth`` の ``@login_required`` デコレータなどのログイン
    チェック機構で保護することがあります． ``login()`` メソッドを使うと，あ
    るユーザがサイトにログインしたのと同じ効果をシミュレートできます．この
    メソッドを呼び出すと，テストクライアント上にログインに関するクッキーと
    セッション情報が生成され，ビューの他の部分でログイン状態に基づいたテス
    トが行われた場合にパスできるようになります．

    たいていのケースでは， ``credentials`` (認証情報) にはログインするユー
    ザのユーザ名 ``username`` とパスワード ``password`` をキーワード引数で
    指定します::


        c = Client()
        c.login(username='fred', password='secret')
        # ログイン保護されたビューに入れるようになった

    認証バックエンドを変えた場合，このメソッドには違った認証情報を指定せね
    ばならないかもしれません．

    ``login()`` は，指定した認証情報が承認され，ログインに成功した場合に
    ``True`` を返します．

結果ログインの有無
    で保護されている URL とのやりとりをテストするのはちょっと厄介なので，テ
    ストクライアントはログイン処理を自動化するための単純なメソッドを提供し
    ています．
    ``login()`` を呼び出すと， ``@login_required`` で保護されたビューにユー
    ザをログインさせる上で必要な一連の GET/POST 呼び出しを行います．

    ログインが可能なら， ``login()`` の戻り値は保護された URL に対する GET
    リクエストに応じて生成されたレスポンスになります．ログインが不可能なら，
    ``login()`` は False を返します．

    テストスイートはテスト用データベース上で実行されます．テスト用データベー
    スには，デフォルトではユーザが一切登録されていないので，運用環境で使え
    るログイン情報でもテスト環境では使えません．手動なり，テストフィクスチャ
    を使うなりして，テストスイートの一環としてユーザを生成しておく必要があ
    るでしょう．

.. _Testing Responses:

レスポンスのテスト
~~~~~~~~~~~~~~~~~~

``get()`` および ``post()`` メソッドは，いずれも Response オブジェクトを返
します． Response オブジェクトには以下のようなプロパティがあり，テストに利
用できます:

    ================  ========================================================
    プロパティ        説明
    ================  ========================================================
    ``status_code``   レスポンスの HTTP 状態コードです．全ての HTTP 状態コー
                      ドのリストは RFC2616_ を参照してください．

    ``content``       レスポンスの本体部分 (body) です．ビューがレンダリン
                      グによって生成した最終的なページコンテンツか，エラー
                      メッセージ (302 リダイレクトの場合のリダイレクト先
                      URL など) です．

    ``template``      最終的なページコンテンツのレンダリングに使われた
                      Template のインスタンスです．とりわけ，
                      ``template.name`` を調べると便利でしょう．テンプレー
                      トをファイルからロードしている場合， ``name`` はロー
                      ドされたファイル名になります．
                      
                      複数のテンプレートをレンダリングしている場合 (例えば
                      テンプレートが他のテンプレートを include している場合)，
                      ``template`` は Template オブジェクトをレンダリングし
                      た順に並べたリストになります．

    ``context``       レスポンスのページコンテンツのレンダに使われた
                      Context オブジェクトです．
                      
                      ``template`` と同様，複数の Context オブジェクトを使っ
                      てレンダリングを行った場合， ``context`` は Context
                      オブジェクトをレンダリングで使った順に並べたリストに
                      なります．
    ================  ========================================================

.. _RFC2616: http://www.w3.org/Protocols/rfc2616/rfc2616-sec10.html

.. _Exceptions:

例外
~~~~

テストクライアントのアクセス先のビューが例外を送出するような場合，その例外
はテストケース内でアクセスできます．例外のテストを行うには，通常の
``try...catch`` ブロックか， ``unittest.TestCase.assertRaises()`` を使いま
す．

ただし， ``Http404`` や ``PermissionDenied``, ``SystemExit`` といった例外は
テストケースからアクセスできません． Django はこれらの例外を内部的に捕捉し
て，対応する適切な HTTP 応答コードに変換してしまうからです．

.. _Persistent state:

セッションの永続性
~~~~~~~~~~~~~~~~~~

テストクライアントの動作はステートフルです．すなわち，ある時点でクライアン
トがクッキーつきのレスポンスを受け取ると，それ以降のリクエストはクッキー情
報つきになります．テストクライアントは，クッキーの有効期限ポリシを守りませ
ん．クッキーを期限切れにしたければ，該当クッキーを ``client.cookies`` から
手動で削除するか，新たな ``Client`` インスタンスを生成 (全てのクッキーを除
去) します．

テストクライアントには，永続セッション情報 (persistent state information)
を保存するためのプロパティが二つあります．これらのプロパティは，必要に応じ
てテスト条件の一部として検査できます．

    ===============  ====================================================
    プロパティ       説明
    ===============  ====================================================
    ``cookies``      Python の ``SimpleCookie`` 型のオブジェクトで，
                     全てのクライアントクッキーの現在値が入っています．

    ``session``      セッション情報の入った辞書ライクなオブジェクトです．
                     詳しくは `セッションのドキュメント <../sessions/>`_
                     を参照してください．
    ===============  ====================================================

.. _`session documentation`: ../sessions/
        
.. _Example:
             
テスト例
~~~~~~~~

テストクライアントを使った簡単な単体テストを以下に示します::
    
    import unittest
    from django.test.client import Client
    
    class SimpleTest(unittest.TestCase):
        def setUp(self):
            # Client 生成はいつも必要．
            self.client = Client()
        def test_details(self):        
            # GET リクエストを発行
            response = self.client.get('/customer/details/')

            # レスポンスが 200 OK であるか調べる    
            self.failUnlessEqual(response.status_code, 200)
            # レンダリングされるコンテキストの customers の長さが 5 である
            # か確かめる
            self.failUnlessEqual(len(response.context['customers']), 5)


.. _TestCase:

TestCaseクラス
--------------

通常， Python のユニットテストでは， ``unittest.testCase`` をテストケースク
ラスのベースクラスとして拡張して使います． Django では，
``unittest.testCase`` を更に拡張した独自のベースクラス，
``django.test.TestCase`` を提供しています．このクラスは， Web サイトのテス
ト時に便利な機能をいくつか追加しています．

通常のユニットテストの TestCase から Django 独自の TestCase への以降は簡単
で，単にベースクラスを ``unittest.TestCase`` から ``django.test.TestCase``
に変更するだけです． ``django.test.TestCase`` では，標準の Python ユニットテ
スト機能はそのままに，さらに便利な機能が加わっています．

.. _Default Test Client:

デフォルトのテストクライアント
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

**開発バージョンの Django で新たに追加されました**

``django.test.TestCase`` クラスのインスタンス内に入っているテストケースは全
て，デフォルトの `テストクライアント`_ にアクセスできます．このテストクライ
アントは ``self.client`` で参照でき，テストごとに再生成されます．

.. _Fixture loading:

フィクスチャの読み込み
~~~~~~~~~~~~~~~~~~~~~~

データベースがバックにあるウェブサイトのテストで，データベース上に何もデー
タが入っていなければあまり意味はありません．データベースにテストデータを入
れやすくするために， Django ではフィクスチャフレームワークを提供しています．

*フィクスチャ* (fixture) とは，データベースに入れるデータをシリアライズして
格納したファイル群を指します．各フィクスチャファイルには固有の名前を付けら
れますが，ある名前のフィクスチャを複数のディレクトリに入れても構いませんし，
複数のアプリケーション内に配置してもかまいません．

.. note::
    Django プロジェクトで syncdb を実行したことがあれば，すでに
    ``initial_data`` というフィクスチャを使っているはずです． Django はデー
    タベースの同期を行うたびに ``initial_data`` フィクスチャをインストール
    します．このメカニズムを使えば， (カテゴリのデフォルトセットのような)
    新たなデータセットをデータベースに組み込めます． ``initial_data`` 以外
    の名前のフィクスチャは， ``django-admin.py loaddata`` で手動で組み込め
    ます．
    
さて，単体テストが目的なら，各テストの開始時にデータベースの中身が何らかの
値になるよう保証せねばなりません．

あるテスト用にフィクスチャを定義するには，テストで使いたいフィクスチャの内
容が入ったクラス属性を一つ定義します．例えば，例えば， 
`unittest を書く <#writing-unittests>`_ のテストケースは以下のようになりま
す::

    from django.test import TestCase
    from myapp.models import Animal

    class AnimalTestCase(TestCase):
        fixtures = ['mammals.json', 'birds']
        
        def setUp(self):
            # test definitions as before

テストケースの開始時で，かつ ``setUp()`` の実行前に， Django はデータベース
を一掃して，データベースを ``syncdb`` 直後の状態に戻します．次に，テストケー
スクラスに指定した全てのフィクスチャをインストールします．上の例では，
``mammals`` という名前の JSON フィクスチャと， ``birds`` という名前のフィク
スチャがインストールされます．フィクスチャの定義とインストールに関する詳細
は `フィクスチャの読み込み`_ を参照してください．

.. _`loading fixtures`: ../django-admin/#loaddata-fixture-fixture
.. _フィクスチャの読み込み: `loading fixtures`_

このフラッシュ／ロードの作業はテストケースの実行毎に繰り返されるので，他の
テストや以前のテスト実行の影響を受けることはありません．

.. _Emptying the test outbox:

メール送信箱の内容抹消
~~~~~~~~~~~~~~~~~~~~~~

**開発バージョンの Django で新たに追加されました**

Djangoは，各テストケースの開始時に，フィクスチャのインストールに加え，メー
ルの送信箱に入っている内容を抹消します．

テスト中のメールサービスの詳細は `メールサービス`_ を参照してください．


.. _Assertions:

アサーション
~~~~~~~~~~~~

**開発バージョンの Django で新たに追加されました**

通常の Python ユニットテストには， ``assertTrue`` や ``assertEquals`` のよ
うな様々なアサーションがあり，プログラムの挙動を検証するのに使えます．
``django.TestCase`` では，Web サイトの挙動をテストするのに便利なアサーショ
ンをさらにいくつか追加しています．

``assertContains(response, text, count=1, status_code=200)``
    ページの取得が行われ，指定の HTTP 状態コード 200 が生成され，レスポンス
    のコンテンツ内に ``text`` に指定した内容が ``count`` 回登場するかどうか
    調べるアサーションです．

``assertFormError(response, form, field, errors)``
    ``form`` に指定したフォーム上のフィールド ``field`` で， ``errors`` に
    指定したエラーリストと同じエラーが送出されるかどうか調べるアサーション
    です．

    ``form`` はテンプレートコンテキスト内でのフォームオブジェクトの名前です．

    ``field`` はフォーム内のフィールドの名前です． ``field`` の値が
    ``None`` であれば，そのフィールドのエラーはチェックされません．

    ``errors`` はエラー文字列か，エラー文字列のリストです．フォームの検証結
    果として返されるのと同じ形式です．

``assertRedirects(response, expected_path, status_code=302, target_status_code=200)``
    レスポンスを受け取ったブラウザが，指定した HTTP 状態コード
    ``status_code`` によってパス ``expected_path`` へリダイレクトされ，リダ
    イレクト先の内容を HTTP 状態コード ``target_status_code`` で取得できた
    か調べるアサーションです．

``assertTemplateNotUsed(response, template_name)``
    ``template_name`` に指定したテンプレートがレスポンスのレンダリングに使
    われて *いない* かどうか調べるアサーションです．

``assertTemplateUsed(response, template_name)``
    ``template_name`` に指定したテンプレートがレスポンスのレンダリングに使
    われているか調べるアサーションです．

.. _E-mail services:

メールサービス
--------------
**開発バージョンの Django で新たに追加されました**

ビューが `Django のメールサービス`_ を使っている場合，ビューをテストするた
びにメールが送信されてほしくはないでしょう．

Django は，テストフレームワークを初期化する際，通常の `SMTPConnection`_ ク
ラスをダミーの SMTPConnection 実装に切替えます．このダミーは，全てのメール
をダミーの送信箱に転送します．送信箱は ``djnago.core.mail.outbox`` で参照で
き，実体はその時点で送信された全ての `EmailMessage`_ インスタンスからなるリ
ストです．この仕組みによって，テスト条件として，以下のようなコードを実行で
きるようになります::

    from django.core import mail

    # Send message
    mail.send_mail('Subject here', 'Here is the message.', 'from@example.com',
        ['to@example.com'], fail_silently=False)

    # One message has been sent
    self.assertEqual(len(mail.outbox), 1)
    # Subject of first message is correct
    self.assertEqual(mail.outbox[0].subject, 'Subject here')

``mail.outbox`` オブジェクトは，通常の実行条件下では存在しません．この送信
箱はテスト設定のときに，ダミーの `SMTPConnection`_ と共に作成されます．
テストフレームワークが実行を終了すると，通常の `SMTPConnection`_ クラスが復
元され，送信箱は消去されます．

`前節で`_ 述べたように，テスト用の送信箱の内容は TestCase 内の各テストケー
スの開始時点で抹消されます．手動で送信箱の内容を空にしたければ，空のリスト
を mail.outbox に代入します::

    from django.core import mail

    # Empty the test outbox
    mail.outbox = []

.. _`Django e-mail services`: ../email/
.. _`SMTPConnection`: ../email/#the-emailmessage-and-smtpconnection-classes
.. _`EmailMessage`: ../email/#the-emailmessage-and-smtpconnection-classes
.. _`previously`: #emptying-the-test-outbox
.. _`Django のメールサービス`: `Django e-mail services`_
.. _`前節で`: `previously`_
    
.. _Running tests:

テストを実行する
================

テストを実行するには，プロジェクトの ``manage.py`` ユーティリティを使います::

    $ ./manage.py test

特定のアプリケーションに対してテストを実行したければ，コマンドラインにアプ
リケーションの名前を追加します．例えば， ``INSTALLED_APPS`` に
``myproject.polls`` と ``myproject.animals`` というアプリケーションが入って
おり， animals の単体テストを実行したいだけなら，以下のようにします::
 
    $ ./manage.py test animals

テストを実行すると，テストデータベースの生成やモデルの初期化の過程を示すテ
キストが表示されます．テストデータベースはテストを実行するたびに生成されま
す．

デフォルトでは，テストデータベースの名前は， ``settings.DATABASE_NAME`` に
指定したデータベース名の前に ``test_`` を付けたものになります．その他のデー
タベースに関する設定は，通常のプロジェクトで使われているものと同じです．
テストデータベースの名前をデフォルト意外の値にしたければ，
``TEST_DATABASE_NAME`` 設定を使って名前を指定します．

**開発バージョンの Django で新たに追加されました:** 
テスト用データベースの文字セットエンコーディング設定を細かく調整したいのな
ら， ``TEST_DATABASE_CHARSET`` 設定を使ってください． MySQL を使っているなら，
``TEST_DATABASE_COLLATION`` でテストデータベースで使うコレーション
(collation) を指定できます．これらの設定については， settings_ ファイルのド
キュメントを参照してください．

.. _settings: ../settings/

テスト用データベースは， ``DATABASE_USER`` 設定に指定したユーザの権限で作成
されます．従って，そのユーザは新たなデータベースを作成するのに必要な権限を
持っていなければなりません．

テストデータベースが生成されると， Django はテストを実行します．全てのテス
トにパスすると，最後には以下のようなメッセージが表示されます::

    ----------------------------------------------------------------------
    Ran 22 tests in 0.221s

    OK

一方，失敗したテストがあると，失敗したテストに関する詳しい情報が表示されま
す::

    ======================================================================
    FAIL: Doctest: ellington.core.throttle.models
    ----------------------------------------------------------------------
    Traceback (most recent call last):
      File "/dev/django/test/doctest.py", line 2153, in runTest
        raise self.failureException(self.format_failure(new.getvalue()))
    AssertionError: Failed doctest test for myapp.models
      File "/dev/myapp/models.py", line 0, in models

    ----------------------------------------------------------------------
    File "/dev/myapp/models.py", line 14, in myapp.models
    Failed example:
        throttle.check("actor A", "action one", limit=2, hours=1)
    Expected:
        True
    Got:
        False

    ----------------------------------------------------------------------
    Ran 2 tests in 0.048s

    FAILED (failures=1)
    
スクリプトの戻り値コードは失敗したテストや出力のおかしかったテストの総数で
す．全てのテストにパスしていれば，リターンコードは 0 になります．

テストにパスしたか否かに関係なく，テストを全て実行し終えると，テストデータ
ベースは消去されます．

.. _Using a different testing framework:

他のテストフレームワークを使う
==============================

Python のテストフレームワークは doctest と unittest だけではありません．
Django は他のテストフレームワークを明にサポートしているわけではありませんが，
他のテストフレームワークで作成したテストを Django の通常のテストと同じよう
に呼び出すためのメカニズムは提供しています．

``./manage.py test`` を実行すると， Django は ``TEST_RUNNER`` 設定を探して，
実行すべきテストランナを決定します．デフォルトでは， ``TEST_RUNNER`` は
``django.test.simple.run_tests`` です．このメソッドは Django のデフォルトの
テスト動作を実装しており，以下のように動作します:

#. テスト前の全体的な準備を行います．
#. テストデータベースを生成します．
#. ``syncdb`` を実行して，モデルと初期データをデータベースにインストールし
   ます．
#. インストールされている全てのアプリケーションの ``models.py`` や
   ``tests.py`` から，単体テストと doctest を探します．
#. 見つかった単体テストと doctest を実行します．
#. テストデータベースを破壊します．
#. テスト後の全体的な後始末を行います．

テストランナメソッドを自作して，そのメソッド名を ``TEST_RUNNER`` に指定して
おき， ``./manage.py test`` を実行すると， Django はそのテストランナメソッ
ドを実行します．これによって， Python コードから任意のテストフレームワーク
を実行できます．

.. _Defining a test runner:

テストランナを定義する
----------------------

慣習的に，テストランナは ``run_tests`` と呼ぶことになっていますが，実際には
どんな名前にしてもかまいません．ただし，テストランナは以下に示すように二つ
の引数をとらねばなりません．

``run_tests(module_list, verbosity=1)``
  ``module_list`` はテスト対象のモデルが入った Python モジュールのリストで，
  ``django.db.models.get_apps()`` が返すのと同じフォーマットです．

  ``verbosity`` には，コンソールに出力される通知情報やデバッグ情報の量を指
  定します．  `0` にすると何も出力しません． `1` は通常の出力， `2` は多め
  の出力です．

  このメソッドは失敗したテストの数を返さねばなりません．

.. _Testing utilities:

テスト用のユーティリティ
------------------------

``django.test.utils`` モジュールには，テストランナの自作に役立つユーティリ
ティメソッドが定義されています．

``setup_test_environment()``
    テンプレートレンダリングシステム構成のインストールなど，テスト前の全
    体的な準備を行い，ダミーの SMTP 接続をセットアップします．

``teardown_test_environment()``
    テンプレートレンダリングシステム構成の除去など，テスト後の全体的な後始
    末を行い，メールサービスを通常の状態に復帰します．

``create_test_db(verbosity=1, autoclobber=False)``
    新たなテストデータベースを生成し， ``syncdb`` を実行します．

    ``verbosity`` はテストランナの同名の引数と同じ意味です．

    ``autoclobber`` には，テスト用データベースと同じ名前のデータベースが既
    に存在する場合の挙動を指定します． ``autoclobber`` が ``False`` なら，
    既存のデータベースを破壊してもよいかユーザに尋ねます．ユーザが「いいえ」
    を選択すると，その時点で ``sys.exit`` を呼び出して終了します．
    ``autoclobber`` が ``True`` なら，既存のデータベースを破壊するときにユー
    ザに了解を求めません． 

    ``create_test_db()`` には ``settings.DATABASE_NAME`` を変更してテストデー
    タベースの名前にするという副作用があります．

``destroy_test_db(old_database_name, verbosity=1)``
    ``settings.DATABASE_NAME`` の名前 (通常は， ``create_test_db`` でテスト
    用に変更されているはずです) に一致するデータベースを破壊し，
    ``settings.DATABASE_NAME`` の値を ``old_database_name`` に指定した名前
    に戻します．

    ``verbosity`` はテストランナの同名の引数と同じ意味です．
