.. _ref-models-instances:

========================
Model instance reference
========================

.. currentmodule:: django.db.models
   
This document describes the details of the ``Model`` API. It builds on the
material presented in the :ref:`model <topics-db-models>` and `database query
<topics-db-queries>` guides, so you'll probably want to read and understand
those documents before reading this one.

Throughout this reference we'll use the :ref:`example weblog models
<queryset-model-example>` presented in the :ref:`database query guide
<topics-db-queries>`.

Creating objects
================

To create a new instance of a model, just instantiate it like any other Python class:

.. class:: Model(**kwargs)

The keyword arguments to are simply the names of the fields you've defined on
your model. Note that instantiating a model in no way touches your database; for
that, you need to ``save()``.

Saving objects
==============

To save an object back to the database, call ``save()``:

.. method:: Model.save([force_insert=False, force_update=False])

Of course, there are some subtleties; see the sections below.

.. versionadded:: 1.0

The signature of the ``save()`` method has changed from earlier versions
(``force_insert`` and ``force_update`` have been added). If you are overriding
these methods, be sure to use the correct signature.

.. _Auto-incrementing primary keys:

主キーの自動インクリメント
--------------------------

モデルに ``AutoField`` 、すなわち自動インクリメントされる主キーがある場合に
は、オブジェクトに対して最初に ``save()`` を呼び出したときに自動インクリメ
ント値が計算され、保存されます::

    >>> b2 = Blog(name='Cheddar Talk', tagline='Thoughts on cheese.')
    >>> b2.id     # b には ID がないので None を返します。
    >>> b2.save()
    >>> b2.id     # 新たに保存されたオブジェクトの ID を返します。

ID の値は Django ではなくデータベースによって計算されるので、 ``save()`` を
呼び出すまでは ID の値は分かりません。

(利便性のため、明示的に ``primary_key=True`` を指定したフィールドを作成しな
いかぎり、デフォルトでは各モデルに ``id`` という名前の ``AutoField``
が追加されます。詳しくは ``AutoField`` のドキュメントを参照してください。)

.. TBD

The ``pk`` property
~~~~~~~~~~~~~~~~~~~

.. versionadded:: 1.0

.. attribute:: Model.pk

Regardless of whether you define a primary key field yourself, or let Django
supply one for you, each model will have a property called ``pk``. It behaves
like a normal attribute on the model, but is actually an alias for whichever
attribute is the primary key field for the model. You can read and set this
value, just as you would for any other attribute, and it will update the
correct field in the model.

.. _Explicitly specifying auto-primary-key values:

自動主キーの値を明示的に指定する
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

モデルが ``AutoField`` を持っていて、新たなオブジェクトの ID を保存時に明示
的に指定したい場合、 ID を自動的に決定させずに保存前に明示的に指定してくだ
さい::

    >>> b3 = Blog(id=3, name='Cheddar Talk', tagline='Thoughts on cheese.')
    >>> b3.id     # Returns 3.
    >>> b3.save()
    >>> b3.id     # Returns 3.

自動主キーの値を手動で割り当てる場合、決して既に存在する主キーの値を割り当
てないようにしてください! 明示的な主キー値を持った新たなオブジェクトを作成
し、その主キーがすでにデータベース上に存在する場合、 Django は保存操作を新
たなオブジェクトの作成ではなく、既存のオブジェクトの変更とみなします。

上の ``'Cheddar Talk'`` ブログを例にとると、以下の例はデータベース上の既存
のレコードをオーバライドしてしまいます::

    b4 = Blog(id=3, name='Not Cheddar', tagline='Anything but cheese.')
    b4.save()  # Overrides the previous blog with ID=3!

この理由については後述の `UPDATE と INSERT の区別`_ を参照してください。

主キーの衝突がないとはっきり判っている場合なら、自動主キーの値の明示的な指
定は大量のオブジェクトを保存する際にきわめて便利です。

.. _`What happens when you save?`:

オブジェクトの保存時に何が起きるのか
-------------------------------------

Django は以下の段階を踏んでオブジェクトを保存します:

    1. **``pre_save`` シグナルの発行** 
       :attr:`django.db.models.signals.pre_save` :ref:`シグナル <ref-signals>`
       の発行によって、何らかのオブジェクトを保存しようとしていることを通知
       します。このシグナルを待ち受けている関数でカスタムの処理を実行できま
       す。

    2. **データの前処理** オブジェクトの各フィールドについて、保存時に自動
       的に実行する必要があるデータ修飾処理がないか調べ、あれば実行します。

       ほとんどのフィールドは前処理を *伴いません* 。フィールドのデータは 
       そのまま保存されます。前処理が行われるのは、特殊な挙動を示すフィー
       ルドだけです。例えば、 ``auto_now=True`` に設定された ``DateField``
       の場合、前処理の段階で、フィールドの内容が現在の日付になるようデータ
       を置き換えます (現時点では、「特殊な」挙動を示すフィールドのリストを
       全て列挙したドキュメントはありません)。

    3. **データベース保存用のデータ準備処理** 各フィールドについて、フィー
       ルドの現在の値を元にデータベースに保存できる型のデータを生成します。

       ほとんどのフィールドはデータ準備処理を *伴いません* 。整数や文字列は
       Python オブジェクトとして「いつでもデータベースへの書き込みに使える」
       形式になっています。ただ、より複雑なデータ型の場合、なにがしかの修飾
       が必要なことがあります。

       例えば、 ``DateField`` は、データの保存に Python の ``datetime`` 型
       を使います。データベースは ``datetime`` オブジェクトを保存しないので、
       データベースに保存するには、フィールドの値を ISO 準拠の日付文字列に
       変換せねばなりません。

    4. **データベースへの保存** 前処理と準備処理を経たデータが SQL 文に組み
       込まれ、データベースに挿入されます。

    5. **``post_save`` シグナルの発行** `
       :attr:`django.db.models.signals.pre_save` シグナルと同じく、オブジェ
       クトが成功理に保存されたことを通知するために 
       :attr:`django.db.models.signals.post_save` シグナルが発行されます。


.. _How Django knows to UPDATE vs. INSERT:

UPDATE と INSERT の区別
-----------------------

Django データベースオブジェクトがオブジェクトの作成と変更に同じ ``save()``
メソッドを使っていることにお気づきかもしれませんね。 Django は ``INSERT``
と ``UPDATE`` SQL 文のどちらを使うべきかの判断を抽象化しています。具体的
に言うと、 ``save()`` を呼び出したときに、Django は以下のアルゴリズムに従い
ます:

    * オブジェクトの主キー属性の評価値が ``False`` でない場合 (``None`` や
      空文字列の場合などでない場合) 、 Django は ``SELECT`` クエリを使って、
      該当する主キーを持つレコードが存在するかどうか調べます。
    * 該当する主キーを持つレコードがデータベース上に存在する場合には
      ``UPDATE`` クエリを使います。
    * オブジェクトの主キー属性が設定 *されていない* 場合や、主キーが設定さ
      れているが該当するレコードは存在しない場合、 ``INSERT`` を使います。

新たなオブジェクトを保存する際、まだ使われていない値を主キーに指定できる保
証がないかぎり、主キーの値を明示的に指定しないよう注意してください。詳しく
は上記の `自動主キーの値を明示的に指定する`_ の節や、後述の
`Forcing an INSERT or UPDATE`_ を参照してください。

.. _ref-models-force-insert:

Forcing an INSERT or UPDATE
~~~~~~~~~~~~~~~~~~~~~~~~~~~

.. versionadded:: 1.0

In some rare circumstances, it's necessary to be able to force the ``save()``
method to perform an SQL ``INSERT`` and not fall back to doing an ``UPDATE``.
Or vice-versa: update, if possible, but not insert a new row. In these cases
you can pass the ``force_insert=True`` or ``force_update=True`` parameters to
the ``save()`` method. Passing both parameters is an error, since you cannot
both insert *and* update at the same time.

It should be very rare that you'll need to use these parameters. Django will
almost always do the right thing and trying to override that will lead to
errors that are difficult to track down. This feature is for advanced use
only.

.. _model-instance-methods:

Other model instance methods
============================

A few object methods have special purposes.

``__str__``
-----------

.. method:: Model.__str__()

``__str__()`` is a Python "magic method" that defines what should be returned
if you call ``str()`` on the object. Django uses ``str(obj)`` (or the related
function, ``unicode(obj)`` -- see below) in a number of places, most notably
as the value displayed to render an object in the Django admin site and as the
value inserted into a template when it displays an object. Thus, you should
always return a nice, human-readable string for the object's ``__str__``.
Although this isn't required, it's strongly encouraged (see the description of
``__unicode__``, below, before putting ``__str__`` methods everywhere).

For example::

    class Person(models.Model):
        first_name = models.CharField(max_length=50)
        last_name = models.CharField(max_length=50)

        def __str__(self):
            # Note use of django.utils.encoding.smart_str() here because
            # first_name and last_name will be unicode strings.
            return smart_str('%s %s' % (self.first_name, self.last_name))

``__unicode__``
---------------

.. method:: Model.__unicode__()

The ``__unicode__()`` method is called whenever you call ``unicode()`` on an
object. Since Django's database backends will return Unicode strings in your
model's attributes, you would normally want to write a ``__unicode__()``
method for your model. The example in the previous section could be written
more simply as::

    class Person(models.Model):
        first_name = models.CharField(max_length=50)
        last_name = models.CharField(max_length=50)

        def __unicode__(self):
            return u'%s %s' % (self.first_name, self.last_name)

If you define a ``__unicode__()`` method on your model and not a ``__str__()``
method, Django will automatically provide you with a ``__str__()`` that calls
``__unicode__()`` and then converts the result correctly to a UTF-8 encoded
string object. This is recommended development practice: define only
``__unicode__()`` and let Django take care of the conversion to string objects
when required.

``get_absolute_url``
--------------------

.. method:: Model.get_absolute_url()

Define a ``get_absolute_url()`` method to tell Django how to calculate the
URL for an object. For example::

    def get_absolute_url(self):
        return "/people/%i/" % self.id

Django uses this in its admin interface. If an object defines
``get_absolute_url()``, the object-editing page will have a "View on site"
link that will jump you directly to the object's public view, according to
``get_absolute_url()``.

Also, a couple of other bits of Django, such as the :ref:`syndication feed
framework <ref-contrib-syndication>`, use ``get_absolute_url()`` as a
convenience to reward people who've defined the method.

It's good practice to use ``get_absolute_url()`` in templates, instead of
hard-coding your objects' URLs. For example, this template code is bad::

    <a href="/people/{{ object.id }}/">{{ object.name }}</a>

But this template code is good::

    <a href="{{ object.get_absolute_url }}">{{ object.name }}</a>

.. note::
    The string you return from ``get_absolute_url()`` must contain only ASCII
    characters (required by the URI spec, `RFC 2396`_) that have been
    URL-encoded, if necessary. Code and templates using ``get_absolute_url()``
    should be able to use the result directly without needing to do any
    further processing. You may wish to use the
    ``django.utils.encoding.iri_to_uri()`` function to help with this if you
    are using unicode strings a lot.

.. _RFC 2396: http://www.ietf.org/rfc/rfc2396.txt

The ``permalink`` decorator
~~~~~~~~~~~~~~~~~~~~~~~~~~~

The problem with the way we wrote ``get_absolute_url()`` above is that it
slightly violates the DRY principle: the URL for this object is defined both
in the URLConf file and in the model.

You can further decouple your models from the URLconf using the ``permalink``
decorator:

.. function:: django.db.models.permalink()

This decorator is passed the view function, a list of positional parameters and
(optionally) a dictionary of named parameters. Django then works out the correct
full URL path using the URLconf, substituting the parameters you have given into
the URL. For example, if your URLconf contained a line such as::

    (r'^people/(\d+)/$', 'people.views.details'),

...your model could have a ``get_absolute_url`` method that looked like this::

    from django.db import models

    @models.permalink
    def get_absolute_url(self):
        return ('people.views.details', [str(self.id)])

Similarly, if you had a URLconf entry that looked like::

    (r'/archive/(?P<year>\d{4})/(?P<month>\d{1,2})/(?P<day>\d{1,2})/$', archive_view)

...you could reference this using ``permalink()`` as follows::

    @models.permalink
    def get_absolute_url(self):
        return ('archive_view', (), {
            'year': self.created.year,
            'month': self.created.month,
            'day': self.created.day})

Notice that we specify an empty sequence for the second parameter in this case,
because we only want to pass keyword parameters, not positional ones.

In this way, you're tying the model's absolute URL to the view that is used
to display it, without repeating the URL information anywhere. You can still
use the ``get_absolute_url`` method in templates, as before.

In some cases, such as the use of generic views or the re-use of
custom views for multiple models, specifying the view function may
confuse the reverse URL matcher (because multiple patterns point to
the same view).

For that problem, Django has **named URL patterns**. Using a named
URL pattern, it's possible to give a name to a pattern, and then
reference the name rather than the view function. A named URL
pattern is defined by replacing the pattern tuple by a call to
the ``url`` function)::

    from django.conf.urls.defaults import *

    url(r'^people/(\d+)/$',
        'django.views.generic.list_detail.object_detail',
        name='people_view'),

...and then using that name to perform the reverse URL resolution instead
of the view name::

    from django.db.models import permalink

    def get_absolute_url(self):
        return ('people_view', [str(self.id)])
    get_absolute_url = permalink(get_absolute_url)

More details on named URL patterns are in the :ref:`URL dispatch documentation
<topics-http-urls>`.

.. _Extra instance methods:

追加のインスタンスメソッド
==========================

``save()``, ``delete()`` に加えて、モデルオブジェクトは以下のいずれか、あるい
は全てのメソッドを持つことがあります:

get_FOO_display()
-----------------

``choices`` セットを持つ全てのフィールドについて、オブジェクトは
``get_FOO_display()`` メソッドを持ちます。 ``FOO`` はフィールド名です。この
メソッドは、「人間可読な」フィールド名を返します。例えば、以下のモデル::

    GENDER_CHOICES = (
        ('M', 'Male'),
        ('F', 'Female'),
    )
    class Person(models.Model):
        name = models.CharField(max_length=20)
        gender = models.CharField(max_length=1, choices=GENDER_CHOICES)

では、各 ``Person`` インスタンスは ``get_gender_display()`` メソッド
を持ちます::

    >>> p = Person(name='John', gender='M')
    >>> p.save()
    >>> p.gender
    'M'
    >>> p.get_gender_display()
    'Male'

get_next_by_FOO(\**kwargs) and get_previous_by_FOO(\**kwargs)
-------------------------------------------------------------

``null=True`` であるような ``DateField`` および ``DateTimeField`` フィール
ドについて、オブジェクトは ``get_next_by_FOO()`` および 
``get_previous_by_FOO()`` メソッドを持ちます。 ``FOO`` はフィールド名です。
このメソッドは該当の日付フィールドに応じて前のオブジェクトや次のオブジェク
トを返します。適切なオブジェクトがなければ ``DoesNotExist`` を送出します。

これらのメソッドはいずれもオプションのキーワード引数をとります。引数は
前述の「 :ref:`Field lookups <field-lookups>` 」で解説した形式にします。

同じ日付値を持つオブジェクトがある場合、このメソッドは ID を使ったチェック
にフォールバックします。これにより、レコードがスキップしたり重複したりしな
いことが保証されています。
