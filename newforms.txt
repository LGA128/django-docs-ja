===================
newforms ライブラリ
===================

:revision-up-to: 5221 (0.97pre SVN)

``django.newforms`` は， Django に新たに導入された画期的なフォーム処理ライ
ブラリで，従来のフォーム／マニピュレータ／バリデータフレームワークである
``django.forms`` を置き換えるものです．このドキュメントでは，新たなフォーム
ライブラリの使い方について解説します．

.. _Migration plan:

移行の計画
==========

``django.newforms`` はリリース 0.96 で新たに採り入れられた機能ですが，もう
「新しい(new)」機能ではなくなったので，将来 ``django.forms`` に名前を変更す
る予定です．現在の ``django.forms`` は Django 1.0 までの間
``django.oldforms`` という名前で利用でき，その後削除するのが適当だと考えて
います．

この変更は，現在皆さんが利用しているコードの将来のバージョンに対する互換性
に直接的に関わってきます．以下の移行計画を良く読んで，それに沿ったコードを
書くようにしてください:

    * 従来のフォームフレームワーク (現在の ``django.forms``) は
      ``django.oldforms`` にコピーされています．従って，互換性のない変更を
      座して待つことなく， *今すぐ* コードの修正に取り掛かれます．修正は，
      各アプリケーションのコードを以下のように書き換えるだけです::

          from django import forms             # 移行前
          from django import oldforms as forms # 移行後

    * 次の Django リリース (0.97) では，現在の ``django.newforms`` を
      ``django.forms`` に移動します．これは互換性のない変更なので，以前の
      ``django.forms`` を使い続けたい人は，上記に従って import 文を変更する
      必要があります．

    * 次の Django リリース，すなわち新たな ``django.forms`` が導入されたリ
      リースの *後* ， 0.98 か 1.0 のいずれか先に出たバージョンで，
      ``django.oldforms`` をコードから除去します．

この移行計画を念頭に， ``django.newforms`` を使う場合には以下のような
import 文を使うように勧めます::

    from django import newforms as forms

こうしておけば，フォームライブラリを ``forms`` モジュールとして参照でき，
``django.newforms`` が ``django.forms`` になったときに ``import`` 文を書き
換えるだけで済みます．

「 ``import *`` 」構文を使いたければ以下のようにできます::

    from django.newforms import *

上の命令は，全てのフィールド，ウィジェット，フォームクラスと検証のためのユー
ティリティをローカルな名前空間に import します．便利と考える人も，美しくな
いと考える人もいるでしょう．

.. _Overview:

概要
====

``django.newforms`` は，以前の ``django.forms`` (「マニピュレータ」) システ
ムと同じく， HTML フォームを表示し，データ処理 (検証) を行って再表示するた
めのライブラリです．HTML フォームをサーバ側で検証する場合に使います．

例えば， Web サイトに連絡用フォームを設置し，訪問者が電子メールでメッセージ
を送信できるようにしたいなら，このライブラリを使って HTML フォームフィール
ドを表示し，フォームの値を検証できます．このライブラリは， HTML の
``<form>`` タグが必要になるような状況で利用できるわけです．

このライブラリでは，以下のような概念を扱います:

    * **ウィジェット (Widget)** -- ``<input type="text">`` や
      ``<textarea>`` のような， HTML フォームウィジェットに対応するクラスで
      す．ウィジェットから HTML へのレンダリングもこのクラスで行われます．

    * **フィールド (Field)** -- データの検証を行うためのクラスです．例えば，
      ``EmailField`` はデータが有効な電子メールアドレスかどうか検証します．

    * **フォーム (Form)** -- フィールドの集まりで，データの検証や HTML への
      表示方法が実装されたものです．

このライブラリは，データベースレイヤやビュー，テンプレートといった他の
Django コンポーネントに対してカップリングしていません． newforms ライブラリ
が依存しているのは settings と ``django.utils`` の二つのヘルパ関数，そして
国際化のためのフック (ただし，このライブラリを使うために国際化の機能を使わ
ねばならないわけではありません) だけです．

.. _Form objects:

フォームオブジェクト
====================

``newforms`` ライブラリの第一の用途はフォームオブジェクト (form object) の
作成にあります．フォームオブジェクトは， ``django.newforms.Form`` クラスを
サブクラス化して，フォームのフィールドを定義して作成します．フォームのフィー
ルド定義は Django のデータベースモデルで親しんでいるあの記述方法で行えます．
この節では，自分のウェブサイトに「連絡フォーム (contact me)」の機能を実装す
るためのフォームオブジェクトを逐次開発してゆきます．

まずは ``ContactForm`` という名前で ``Form`` のサブクラスを作成するところか
らはじめましょう::

    from django import newforms as forms

    class ContactForm(forms.Form):
        subject = forms.CharField(max_length=100)
        message = forms.CharField()
        sender = forms.EmailField()
        cc_myself = forms.BooleanField()

フォームは ``Field`` オブジェクトの組み合わせでできています．今回の例では，
``subject`` (題名)， ``message`` (メッセージ)， ``sender`` (送信者)，そして
``cc_myself`` (自分に CC する)，の 4 つのフィールドをフォームに持たせます．
``CharField`` や ``EmailField`` といったフィールド型については，また後で説
明する予定です．

.. _Creating Form instances:

``Form`` のインスタンスを生成する
---------------------------------

``Form`` のインスタンスには，何らかのデータの集まりと結び付いたもの
(**束縛 (bound) フォーム**) と，そうでないもの
(**非束縛 (unbound) フォーム**) があります．

    * データと **結び付いている** フォームは，データを検証機能する機能と， 
      フォームを HTML にレンダリングするときにデータを HTML 形式で表示する
      機能をあわせ持っています．

    * データと **結び付いていない** フォームには検証機能はありません (検証
      すべきデータがないから当然ですね!) が，空のフォームを HTML としてレン
      ダリングする機能は備えています．

非束縛フォームのインスタンスを生成するには，単にフォームクラスのインスタン
ス化を行います::

    >>> f = ContactForm()

フォームにデータを結び付けるには，データの入った辞書をフォームクラスのコン
ストラクタの第一引数に渡します::

    >>> data = {'subject': 'hello',
    ...         'message': 'Hi there',
    ...         'sender': 'foo@example.com',
    ...         'cc_myself': True}
    >>> f = ContactForm(data)

この辞書の中では，キーは各フィールドの名前であり，フォームクラスの各属性に
対応しています．値は検証すべきデータです．通常，値は文字列にしますが，必ず
しも文字列でなくてかまいません．値にどんなデータ型を指定指定できるかは，フィー
ルドの型に依存します．

実行時に束縛フォームと非束縛フォームを区別したければ，フォームの
``is_bound`` 属性を調べてください::

    >>> f = ContactForm()
    >>> f.is_bound
    False
    >>> f = ContactForm({'subject': 'hello'})
    >>> f.is_bound
    True

空の辞書を渡すと，空のデータの入った *束縛フォーム* を返します::

    >>> f = ContactForm({})
    >>> f.is_bound
    True

束縛フォームのインスタンスに入っているデータに何らかの変更を加えたい場合や，
束縛フォームを変換して，何らかのデータの入った非束縛フォームにしたい場合に
は，新たにフォームインスタンスを生成してください．フォームインスタンス内の
データを変更する方法はありません．一度フォームインスタンスを生成したら，デー
タの有無に関わらず，インスタンス内のデータは変更不能だと考えてください．

.. _Using forms to validate data:

フォームを使ってデータを検証する
--------------------------------

フォームオブジェクトの主要な役割はデータの検証です．束縛フォームのインスタ
ンスに対して ``is_valid()`` メソッドを呼び出すと，データの検証を行って，そ
の結果をブール値で返します::

    >>> data = {'subject': 'hello',
    ...         'message': 'Hi there',
    ...         'sender': 'foo@example.com',
    ...         'cc_myself': True}
    >>> f = ContactForm(data)
    >>> f.is_valid()
    True

無効なデータを入れてみましょう．例えば， ``subject`` を空にしてみます
(フィールドは全てデフォルトで必須なためエラーになります)．また，
``sender`` に不正なメールアドレス情報を入れてみます::

    >>> data = {'subject': '',
    ...         'message': 'Hi there',
    ...         'sender': 'invalid e-mail address',
    ...         'cc_myself': True}
    >>> f = ContactForm(data)
    >>> f.is_valid()
    False

``errors`` という属性にアクセスすると，エラーメッセージの入った辞書を参照で
きます::

    >>> f.errors
    {'sender': [u'Enter a valid e-mail address.'], 'subject': [u'This field is required.']}

この辞書は，フィールド名がキーに，エラーメッセージを表す Unicode 文字列のリ
ストが値になっています．エラーメッセージがリストになっているのは，一つのフィー
ルドに対して複数のエラーが存在し得るからです．

``is_valid()`` を呼ばなくても ``errors`` にはアクセスできます．
``is_valid()`` を呼び出すか， ``errors`` にアクセスすると，フォームのデータ
は自動的に検証されます．

``errors`` や ``is_invalid()`` に何度アクセスしても，検証のルーチンはたった
一度しか呼ばれません．別の見方をすれば，検証の処理には副作用があり，その副
作用はたった一度しか呼び出されないということです．

``clean_data`` には， ``Form`` 内で定義されている *全ての* フィールドのキー
と値が入ります．フォームに渡したデータに，必須でないフィールドの値が入って
いない場合でもです．下の例では，データ辞書には ``nick_name`` フィールドの値
が入っていませんが， ``clean_data`` には空の値が入っています::

    >>> class OptionalPersonForm(Form):
    ...     first_name = CharField()
    ...     last_name = CharField()
    ...     nick_name = CharField(required=False)
    >>> data = {'first_name': u'John', 'last_name': u'Lennon'}
    >>> f = OptionalPersonForm(data)
    >>> f.is_valid()
    True
    >>> f.clean_data
    {'nick_name': u'', 'first_name': u'John', 'last_name': u'Lennon'}

この例で， ``clean_data`` の中の ``nick_name`` は空文字列なのは，
``nick_name`` が ``CharField`` であり， ``CharField`` は空の値を空文字列と
みなすからです．各フィールドタイプは「空の」値が設定されています．例えば，
``DateField`` の場合，空の値は空文字列ではなく ``None`` になります．

.. _Behavior of unbound forms:

非束縛フォームの動作
~~~~~~~~~~~~~~~~~~~~

データを含まないようなフォームの検証は無意味でしかありませんが，参考までに
非束縛フォームに対する検証を行ったときの動作を示しておきます::

    >>> f = ContactForm()
    >>> f.is_valid()
    False
    >>> f.errors
    {}

.. _Accessing "clean" data:

「クリーニング済み」のデータにアクセスする
------------------------------------------

フォームクラスの各フィールドには，データの検証だけでなく，「クリーニング」
を行う役割もあります．データのクリーニングとは，データを一貫性のある書式に
正規化することです．データのクリーニングはとても素晴らしい機能で，クリーニ
ングを行うと，ユーザがフィールドに色々な形式でデータを入力しても，常に一貫
性を持った出力を得られます．

例えば， ``DateField`` はデータを Python の ``datetime.date`` オブジェクト
に正規化します．フィールドの値は， ``'1994-07-15'`` のような形式の文字列で
も， ``datetime.date`` オブジェクトでも，その他の形式でも， ``DateField``
は有効なデータであるかぎり，常に出力を ``datetime.date`` オブジェクトで正規
化します．

データセットの入ったフォームインスタンスを生成して検証を行うと， 
``clean_data`` 属性を介してクリーニング済みのデータにアクセスできるようにな
ります::

    >>> data = {'subject': 'hello',
    ...         'message': 'Hi there',
    ...         'sender': 'foo@example.com',
    ...         'cc_myself': True}
    >>> f = ContactForm(data)
    >>> f.is_valid()
    True
    >>> f.clean_data
    {'cc_myself': True, 'message': u'Hi there', 'sender': u'foo@example.com', 'subject': u'hello'}

``CharField`` や ``EmailField`` のようなテキストベースのフィールドは，常に
入力を Unicode 文字列に変換します．エンコーディングに関する解説は，このドキュ
メントの後の方でカバーする予定です．

データが *まだ検証されていない* 場合，フォームインスタンスには
``clean_data`` 属性がありません::

    >>> data = {'subject': '',
    ...         'message': 'Hi there',
    ...         'sender': 'invalid e-mail address',
    ...         'cc_myself': True}
    >>> f = ContactForm(data)
    >>> f.is_valid()
    False
    >>> f.clean_data
    Traceback (most recent call last):
    ...
    AttributeError: 'ContactForm' object has no attribute 'clean_data'

フォームを生成するときに追加の値を渡した場合でも， ``clean_data`` の中に入
るキーは，フォーム内で定義されているフィールド *だけ* です．以下の例でも，
``ContactForm`` のコンストラクタに追加のフィールドデータを渡していますが，
``clean_data`` が返すのは ``ContactForm`` で定義されているフィールドだけで
す::

    >>> data = {'subject': 'hello',
    ...         'message': 'Hi there',
    ...         'sender': 'foo@example.com',
    ...         'cc_myself': True,
    ...         'extra_field_1': 'foo',
    ...         'extra_field_2': 'bar',
    ...         'extra_field_3': 'baz'}
    >>> f = ContactForm(data)
    >>> f.is_valid()
    True
    >>> f.clean_data # Doesn't contain extra_field_1, etc.
    {'cc_myself': True, 'message': u'Hi there', 'sender': u'foo@example.com', 'subject': u'hello'}


.. .. _Behavior of unbound forms:

非束縛フォームの動作
~~~~~~~~~~~~~~~~~~~~

データの入っていないフォームをクリーニングしても無意味ですが，参考までに非
束縛フォームでの挙動を示します::

    >>> f = ContactForm()
    >>> f.clean_data
    Traceback (most recent call last):
    ...
    AttributeError: 'ContactForm' object has no attribute 'clean_data'


.. _Outputting forms as HTML:

フォームを HTML として出力する
------------------------------

フォームオブジェクトの二つ目の仕事は，フォームの HTML へのレンダリングです．
フォームを HTML として出力するには，フォームをインスタンス化して，
``print`` で出力します::

    >>> f = ContactForm()
    >>> print f
    <tr><th><label for="id_subject">Subject:</label></th><td><input id="id_subject" type="text" name="subject" maxlength="100" /></td></tr>
    <tr><th><label for="id_message">Message:</label></th><td><input type="text" name="message" id="id_message" /></td></tr>
    <tr><th><label for="id_sender">Sender:</label></th><td><input type="text" name="sender" id="id_sender" /></td></tr>
    <tr><th><label for="id_cc_myself">Cc myself:</label></th><td><input type="checkbox" name="cc_myself" id="id_cc_myself" /></td></tr>

束縛フォームの場合，フォームのデータは適切な形で HTML 出力されます．例えば，
フィールドが ``<input type="text">`` で表される場合，データは ``value`` 属
性の中に出力されます．フィールドが ``<input type="checkbox">`` であれば，
必要に応じて ``checked="checked"`` が入ります::

    >>> data = {'subject': 'hello',
    ...         'message': 'Hi there',
    ...         'sender': 'foo@example.com',
    ...         'cc_myself': True}
    >>> f = ContactForm(data)
    >>> print f
    <tr><th><label for="id_subject">Subject:</label></th><td><input id="id_subject" type="text" name="subject" maxlength="100" value="hello" /></td></tr>
    <tr><th><label for="id_message">Message:</label></th><td><input type="text" name="message" id="id_message" value="Hi there" /></td></tr>
    <tr><th><label for="id_sender">Sender:</label></th><td><input type="text" name="sender" id="id_sender" value="foo@example.com" /></td></tr>
    <tr><th><label for="id_cc_myself">Cc myself:</label></th><td><input type="checkbox" name="cc_myself" id="id_cc_myself" checked="checked" /></td></tr>

デフォルトの出力は 2 カラムの HTML テーブルになり，各フィールドが一つの
``<tr>`` タグの中に収まります．以下の点に注意してください:

    * 柔軟性をもたせるために，出力中には ``<table>`` と ``</table>`` タグが
      入っていません．また， ``<form>`` と ``</form>`` や， 
      ``<input type="submit">`` もありません．これらのタグは自分で入れる必
      要があります．

    * 各フィールドタイプには，それぞれデフォルトの HTML 表現があります．
      ``CharField`` や ``EmailField`` は ``<input type="text">`` で表され，
      ``BooleanField`` は ``<input type="checkbox">`` になります．とはいえ，
      これらは便利なデフォルト値にすぎません．ウィジェット (widget) を使え
      ば，フィールドの表現にどのような HTML を使うかを指定できます．これに
      ついては後で説明する予定です．

    * 各タグの ``name`` 属性は ``ContactForm`` クラスの属性名から直接取り出
      して使われます．

    * ``'Subject:'``, ``'Message:'``, ``'Cc myself:'``  といった各フィール
      ドのテキストラベルは，フィールド名のアンダースコアを全てスペースに変
      換し，先頭の文字を大文字にして生成します．これもまたデフォルト値にす
      ぎず，手動でもラベルを設定できるようになっています．

    * 各テキストラベルは HTML の ``<label>`` タグで囲われています．このタグ
      には ``for`` 属性が付いていて，対応するフォームフィールドの ``id`` 属
      性に対応しています．属性の値はフィールド名の前に ``'id_'`` を付けたも
      のになります． ``id`` 属性や ``<label>`` タグはフォーム生成の定石に従っ
      て組み込まれているものですが，この振舞は自分で変更できます．

テーブル組みによる出力は ``print`` した時に出力されるデフォルトで，他にもい
くつか出力スタイルがあります．各スタイルはフォームオブジェクトのメソッドと
して利用でき，各々のレンダリングメソッドは Unicode オブジェクトを返すように
なっています．

``as_p()``
~~~~~~~~~~

``Form.as_p()`` はフォームを一連の ``<p>`` タグの集まりで組みます．各
``<p>`` タグの中に一つのフィールドが入ります::

    >>> f = ContactForm()
    >>> f.as_p()
    u'<p><label for="id_subject">Subject:</label> <input id="id_subject" type="text" name="subject" maxlength="100" /></p>\n<p><label for="id_message">Message:</label> <input type="text" name="message" id="id_message" /></p>\n<p><label for="id_sender">Sender:</label> <input type="text" name="sender" id="id_sender" /></p>\n<p><label for="id_cc_myself">Cc myself:</label> <input type="checkbox" name="cc_myself" id="id_cc_myself" /></p>'
    >>> print f.as_p()
    <p><label for="id_subject">Subject:</label> <input id="id_subject" type="text" name="subject" maxlength="100" /></p>
    <p><label for="id_message">Message:</label> <input type="text" name="message" id="id_message" /></p>
    <p><label for="id_sender">Sender:</label> <input type="text" name="sender" id="id_sender" /></p>
    <p><label for="id_cc_myself">Cc myself:</label> <input type="checkbox" name="cc_myself" id="id_cc_myself" /></p>

``as_ul()``
~~~~~~~~~~~

``Form.as_ul()`` はフォームを一連の ``<li>`` タグで組みます．各 ``<li>`` タ
グの中に一つのフィールドが入ります． ``as_ul()`` は ``<ul>`` や ``</ul>``
を出力に *含めません* ．これは，ユーザが ``<ul>`` タグの HTML 属性を好きに
指定できるようにするためです::

    >>> f = ContactForm()
    >>> f.as_ul()
    u'<li><label for="id_subject">Subject:</label> <input id="id_subject" type="text" name="subject" maxlength="100" /></li>\n<li><label for="id_message">Message:</label> <input type="text" name="message" id="id_message" /></li>\n<li><label for="id_sender">Sender:</label> <input type="text" name="sender" id="id_sender" /></li>\n<li><label for="id_cc_myself">Cc myself:</label> <input type="checkbox" name="cc_myself" id="id_cc_myself" /></li>'
    >>> print f.as_ul()
    <li><label for="id_subject">Subject:</label> <input id="id_subject" type="text" name="subject" maxlength="100" /></li>
    <li><label for="id_message">Message:</label> <input type="text" name="message" id="id_message" /></li>
    <li><label for="id_sender">Sender:</label> <input type="text" name="sender" id="id_sender" /></li>
    <li><label for="id_cc_myself">Cc myself:</label> <input type="checkbox" name="cc_myself" id="id_cc_myself" /></li>

``as_table()``
~~~~~~~~~~~~~~

最後に， ``Form.as_table()`` はフォームを ``<table>`` で組みます．これは
``print`` で出力したときに使われる形式と同じです．実際，フォームオブジェク
トを ``print`` すると，背後では ``as_table()`` が呼び出されるようになってい
ます::

    >>> f = ContactForm()
    >>> f.as_table()
    u'<tr><th><label for="id_subject">Subject:</label></th><td><input id="id_subject" type="text" name="subject" maxlength="100" /></td></tr>\n<tr><th><label for="id_message">Message:</label></th><td><input type="text" name="message" id="id_message" /></td></tr>\n<tr><th><label for="id_sender">Sender:</label></th><td><input type="text" name="sender" id="id_sender" /></td></tr>\n<tr><th><label for="id_cc_myself">Cc myself:</label></th><td><input type="checkbox" name="cc_myself" id="id_cc_myself" /></td></tr>'
    >>> print f.as_table()
    <tr><th><label for="id_subject">Subject:</label></th><td><input id="id_subject" type="text" name="subject" maxlength="100" /></td></tr>
    <tr><th><label for="id_message">Message:</label></th><td><input type="text" name="message" id="id_message" /></td></tr>
    <tr><th><label for="id_sender">Sender:</label></th><td><input type="text" name="sender" id="id_sender" /></td></tr>
    <tr><th><label for="id_cc_myself">Cc myself:</label></th><td><input type="checkbox" name="cc_myself" id="id_cc_myself" /></td></tr>

.. _Configuring HTML ``<label>`` tags:

``<label>`` タグの出力設定
~~~~~~~~~~~~~~~~~~~~~~~~~~

``<label>`` タグは，あるラベルテキストがどのフォーム要素に対応づけられてい
るかを知らせるタグです． ``<label>`` タグがあると，フォームの利便性が増し，
入力補助デバイスで操作しやすくなります． ``<label>`` タグは常に使うようにし
ておくよう勧めます．

デフォルトでは，フォームのレンダリングメソッドを呼び出すと，各フォーム要素
に ``id`` 属性が追加され，ラベルを ``<label>`` タグで囲って出力します．
``id`` 属性の値はフォームのフィールド名の前に ``id_`` を付けたものになりま
す．とはいえ， ``id`` 属性の命名規則を変えたり，そもそも ``<label>`` を出力
したくない人のために，この仕様は設定変更できるようになっています．

``<label>`` タグや ``id`` の挙動を変更するには， ``Form`` コンストラクタの
``auto_id`` 引数を使います．この引数は ``True`` ， ``False`` ，文字列のいず
れかで指定せねばなりません．

``auto_id`` を ``False`` にすると，フォーム出力に ``<label>`` タグや
``id`` 属性が含まれなくなります::

    >>> f = ContactForm(auto_id=False)
    >>> print f.as_table()
    <tr><th>Subject:</th><td><input type="text" name="subject" maxlength="100" /></td></tr>
    <tr><th>Message:</th><td><input type="text" name="message" /></td></tr>
    <tr><th>Sender:</th><td><input type="text" name="sender" /></td></tr>
    <tr><th>Cc myself:</th><td><input type="checkbox" name="cc_myself" /></td></tr>
    >>> print f.as_ul()
    <li>Subject: <input type="text" name="subject" maxlength="100" /></li>
    <li>Message: <input type="text" name="message" /></li>
    <li>Sender: <input type="text" name="sender" /></li>
    <li>Cc myself: <input type="checkbox" name="cc_myself" /></li>
    >>> print f.as_p()
    <p>Subject: <input type="text" name="subject" maxlength="100" /></p>
    <p>Message: <input type="text" name="message" /></p>
    <p>Sender: <input type="text" name="sender" /></p>
    <p>Cc myself: <input type="checkbox" name="cc_myself" /></p>

``auto_id`` が ``True`` の場合，フォームの出力には ``<label>`` タグが入り，
各フォームフィールドの ``id`` 属性の値にはフィールド名をそのまま使います::

    >>> f = ContactForm(auto_id=True)
    >>> print f.as_table()
    <tr><th><label for="subject">Subject:</label></th><td><input id="subject" type="text" name="subject" maxlength="100" /></td></tr>
    <tr><th><label for="message">Message:</label></th><td><input type="text" name="message" id="message" /></td></tr>
    <tr><th><label for="sender">Sender:</label></th><td><input type="text" name="sender" id="sender" /></td></tr>
    <tr><th><label for="cc_myself">Cc myself:</label></th><td><input type="checkbox" name="cc_myself" id="cc_myself" /></td></tr>
    >>> print f.as_ul()
    <li><label for="subject">Subject:</label> <input id="subject" type="text" name="subject" maxlength="100" /></li>
    <li><label for="message">Message:</label> <input type="text" name="message" id="message" /></li>
    <li><label for="sender">Sender:</label> <input type="text" name="sender" id="sender" /></li>
    <li><label for="cc_myself">Cc myself:</label> <input type="checkbox" name="cc_myself" id="cc_myself" /></li>
    >>> print f.as_p()
    <p><label for="subject">Subject:</label> <input id="subject" type="text" name="subject" maxlength="100" /></p>
    <p><label for="message">Message:</label> <input type="text" name="message" id="message" /></p>
    <p><label for="sender">Sender:</label> <input type="text" name="sender" id="sender" /></p>
    <p><label for="cc_myself">Cc myself:</label> <input type="checkbox" name="cc_myself" id="cc_myself" /></p>

``auto_id`` がフォーマット文字 ``'%s'`` を含む文字列になっている場合，フォー
ム出力は ``<label>`` タグを含むようになり，タグの ``id`` 属性はフォーマット
文字列に従って生成されます．例えば，フォーマット文字列が ``field_%s`` の場
合， ``subject`` という名前のフィールドの ``id`` は ``'field_subject'`` に
なります．出力例は以下のようになります::

    >>> f = ContactForm(auto_id='id_for_%s')
    >>> print f.as_table()
    <tr><th><label for="id_for_subject">Subject:</label></th><td><input id="id_for_subject" type="text" name="subject" maxlength="100" /></td></tr>
    <tr><th><label for="id_for_message">Message:</label></th><td><input type="text" name="message" id="id_for_message" /></td></tr>
    <tr><th><label for="id_for_sender">Sender:</label></th><td><input type="text" name="sender" id="id_for_sender" /></td></tr>
    <tr><th><label for="id_for_cc_myself">Cc myself:</label></th><td><input type="checkbox" name="cc_myself" id="id_for_cc_myself" /></td></tr>
    >>> print f.as_ul()
    <li><label for="id_for_subject">Subject:</label> <input id="id_for_subject" type="text" name="subject" maxlength="100" /></li>
    <li><label for="id_for_message">Message:</label> <input type="text" name="message" id="id_for_message" /></li>
    <li><label for="id_for_sender">Sender:</label> <input type="text" name="sender" id="id_for_sender" /></li>
    <li><label for="id_for_cc_myself">Cc myself:</label> <input type="checkbox" name="cc_myself" id="id_for_cc_myself" /></li>
    >>> print f.as_p()
    <p><label for="id_for_subject">Subject:</label> <input id="id_for_subject" type="text" name="subject" maxlength="100" /></p>
    <p><label for="id_for_message">Message:</label> <input type="text" name="message" id="id_for_message" /></p>
    <p><label for="id_for_sender">Sender:</label> <input type="text" name="sender" id="id_for_sender" /></p>
    <p><label for="id_for_cc_myself">Cc myself:</label> <input type="checkbox" name="cc_myself" id="id_for_cc_myself" /></p>

``auto_id`` がこれ以外の偽でない値，つまり ``%s`` を含まない文字列のような
値の場合， ``auto_id`` は ``True`` に設定されたものとみなされます．

デフォルトでは， ``auto_id`` は ``'id_%s'`` に設定されています．

.. _Notes on field ordering:

フィールドの並び順について
~~~~~~~~~~~~~~~~~~~~~~~~~~

``as_p()`` や ``as_ul()``, ``as_table()`` ショートカットを使うと，各フィー
ルドは Form クラス内で定義された順に出力されます．例えば，上の
``ContactForm`` の例では，フィールドの並び順は ``subject``, ``message``,
``sender``, ``cc_myself`` になります． HTML 出力の中でフィールドの並び順を
変更したければ，クラス定義内でのフィールドの並び順を変更してください．

.. _How errors are displayed:

エラーの出力方法
~~~~~~~~~~~~~~~~

束縛フォームオブジェクトをレンダすると，フォームの検証がまだであればレンダ
リング操作の中で自動的に検証が行われ，エラーがあれば HTML 出力中の該当フィー
ルドの付近に ``<ul>`` でエラー内容が表示されます．エラーメッセージ中の具体
的なエラー表示位置は，どのメソッドでフォームをレンダしているかによります::

    >>> data = {'subject': '',
    ...         'message': 'Hi there',
    ...         'sender': 'invalid e-mail address',
    ...         'cc_myself': True}
    >>> f = ContactForm(data, auto_id=False)
    >>> print f.as_table()
    <tr><th>Subject:</th><td><ul class="errorlist"><li>This field is required.</li></ul><input type="text" name="subject" maxlength="100" /></td></tr>
    <tr><th>Message:</th><td><input type="text" name="message" value="Hi there" /></td></tr>
    <tr><th>Sender:</th><td><ul class="errorlist"><li>Enter a valid e-mail address.</li></ul><input type="text" name="sender" value="invalid e-mail address" /></td></tr>
    <tr><th>Cc myself:</th><td><input checked="checked" type="checkbox" name="cc_myself" /></td></tr>
    >>> print f.as_ul()
    <li><ul class="errorlist"><li>This field is required.</li></ul>Subject: <input type="text" name="subject" maxlength="100" /></li>
    <li>Message: <input type="text" name="message" value="Hi there" /></li>
    <li><ul class="errorlist"><li>Enter a valid e-mail address.</li></ul>Sender: <input type="text" name="sender" value="invalid e-mail address" /></li>
    <li>Cc myself: <input checked="checked" type="checkbox" name="cc_myself" /></li>
    >>> print f.as_p()
    <p><ul class="errorlist"><li>This field is required.</li></ul></p>
    <p>Subject: <input type="text" name="subject" maxlength="100" /></p>
    <p>Message: <input type="text" name="message" value="Hi there" /></p>
    <p><ul class="errorlist"><li>Enter a valid e-mail address.</li></ul></p>
    <p>Sender: <input type="text" name="sender" value="invalid e-mail address" /></p>
    <p>Cc myself: <input checked="checked" type="checkbox" name="cc_myself" /></p>

.. _More granular output:

より細かな出力調整
~~~~~~~~~~~~~~~~~~

``as_p()`` や ``as_ul()``, ``as_table()`` といったメソッドは，単に面倒臭が
りの開発者むけに用意されているショートカットでしかなく，他のやり方でもフォー
ムを表示できます．

フォーム中のあるフィールドの HTML を表示するには，フォームを辞書のように扱
い，フィールドの名前をキーにして参照し，その値を出力します::

    >>> f = ContactForm()
    >>> print f['subject']
    <input id="id_subject" type="text" name="subject" maxlength="100" />
    >>> print f['message']
    <input type="text" name="message" id="id_message" />
    >>> print f['sender']
    <input type="text" name="sender" id="id_sender" />
    >>> print f['cc_myself']
    <input type="checkbox" name="cc_myself" id="id_cc_myself" />

フィールドを引数にして ``str()`` や ``unicode()`` を呼び出すと，レンダ結果
の HTML をそれぞれ string 型や Unicode 型のオブジェクトで返します::

    >>> str(f['subject'])
    '<input id="id_subject" type="text" name="subject" maxlength="100" />'
    >>> unicode(f['subject'])
    u'<input id="id_subject" type="text" name="subject" maxlength="100" />'

フィールド固有の出力を行った場合でも，フォームオブジェクトの ``auto_id`` 設
定は有効です::

    >>> f = ContactForm(auto_id=False)
    >>> print f['message']
    <input type="text" name="message" />
    >>> f = ContactForm(auto_id='id_%s')
    >>> print f['message']
    <input type="text" name="message" id="id_message" />

あるフィールドに関するエラーのリストを取得するには，フィールドの ``errors``
属性にアクセスします．このフィールドはリストライクなオブジェクトで， HTML
として出力すると ``<ul>`` のリストになります::

    >>> data = {'subject': 'hi', 'message': '', 'sender': '', 'cc_myself': ''}
    >>> f = ContactForm(data, auto_id=False)
    >>> print f['message']
    <input type="text" name="message" />
    >>> f['message'].errors
    [u'This field is required.']
    >>> print f['message'].errors
    <ul class="errorlist"><li>This field is required.</li></ul>
    >>> f['subject'].errors
    []
    >>> print f['subject'].errors

    >>> str(f['subject'].errors)
    ''

.. _Subclassing forms:

フォームのサブクラス化
----------------------

フォームクラスをサブクラス化して自作する場合，できたフォームクラスには親ク
ラスの全てのフィールドが入っています．サブクラスで定義したフィールドは親ク
ラスのフィールドの後に続きます．

以下の例では， ``ContactFormWithPriority`` には ``ContactForm`` の全てのフィー
ルドと， ``priority`` という追加のフィールドが入っています．
``ContactForm`` のフィールドは先に表示されます::

    >>> class ContactFormWithPriority(ContactForm):
    ...     priority = forms.CharField()
    >>> f = ContactFormWithPriority(auto_id=False)
    >>> print f.as_ul()
    <li>Subject: <input type="text" name="subject" maxlength="100" /></li>
    <li>Message: <input type="text" name="message" /></li>
    <li>Sender: <input type="text" name="sender" /></li>
    <li>Cc myself: <input type="checkbox" name="cc_myself" /></li>
    <li>Priority: <input type="text" name="priority" /></li>

複数のフォームを親クラスにしたサブクラス化も可能です．この場合，親クラスの
フォームは「混ぜ込み (mix-in)」クラスのように扱われます．以下の例では，
``BeatleForm`` が ``PersonForm`` と ``InstrumentForm`` を (この順番で)
サブクラス化しています．フィールドのリストには，親クラスのフィールドが順番
に表示されます::

    >>> class PersonForm(Form):
    ...     first_name = CharField()
    ...     last_name = CharField()
    >>> class InstrumentForm(Form):
    ...     instrument = CharField()
    >>> class BeatleForm(PersonForm, InstrumentForm):
    ...     haircut_type = CharField()
    >>> b = BeatleForm(auto_id=False)
    >>> print b.as_ul()
    <li>First name: <input type="text" name="first_name" /></li>
    <li>Last name: <input type="text" name="last_name" /></li>
    <li>Instrument: <input type="text" name="instrument" /></li>
    <li>Haircut type: <input type="text" name="haircut_type" /></li>


.. _Fields:

フィールド
==========

フォームクラスの作成で一番重要なのは，フォームの各フィールドの定義です．各
フィールドは固有のデータ検証ロジックと，いくつかのフックが備わっています．

フィールドクラスの主な用途はフォームクラスにおけるフィールド定義ですが，フィー
ルドクラスは直接インスタンス化して使えるので，フィールドの動作を理解する役
に立つはずです．各フィールドインスタンスは ``clean()`` メソッドを備えており，
単一の引数を取って検証を行い，その結果に応じて
``django.newforms.ValidationError`` を送出するか，クリーニング済みの値を返
します::

    >>> f = forms.EmailField()
    >>> f.clean('foo@example.com')
    u'foo@example.com'
    >>> f.clean(u'foo@example.com')
    u'foo@example.com'
    >>> f.clean('invalid e-mail address')
    Traceback (most recent call last):
    ...
    ValidationError: [u'Enter a valid e-mail address.']

Django の古いフォーム／検証フレームワークを使ったことがある人は，この
``VaridationError`` が以前の ``VaridationError`` とは別の例外であることに注
意してください．以前の例外は ``django.core.validators.ValidationError`` で
すが，新たな例外は ``django.newforms.ValidationError`` です．

.. _Core field arguments:

フィールドの主な引数
--------------------

各フィールドクラスのコンストラクタは，少なくとも以下に示す引数を取ります．
フィールドクラスによっては他にもフィールド固有の引数をとりますが．ここに示
す引数はどのフィールドクラスでも *常に* 指定できる引数です:

``required``
~~~~~~~~~~~~

デフォルトでは，フィールドクラスはフィールドが必須 (reqired) であると仮定し
ています．従って，フィールドに空の値，すなわち ``None`` や空文字列 (``""``)
を渡すと， ``clean()`` は ``VaridationError`` 例外を送出します::

    >>> f = forms.CharField()
    >>> f.clean('foo')
    u'foo'
    >>> f.clean('')
    Traceback (most recent call last):
    ...
    ValidationError: [u'This field is required.']
    >>> f.clean(None)
    Traceback (most recent call last):
    ...
    ValidationError: [u'This field is required.']
    >>> f.clean(' ')
    u' '
    >>> f.clean(0)
    u'0'
    >>> f.clean(True)
    u'True'
    >>> f.clean(False)
    u'False'

必須で *ない* フィールドにするには，フィールドのコンストラクタに
``required=False`` を指定します::

    >>> f = forms.CharField(required=False)
    >>> f.clean('foo')
    u'foo'
    >>> f.clean('')
    u''
    >>> f.clean(None)
    u''
    >>> f.clean(0)
    u'0'
    >>> f.clean(True)
    u'True'
    >>> f.clean(False)
    u'False'

``required=False`` のフィールドの ``clean()`` に空の値を渡して呼び出すと，
``clean()`` は ``VaridationError`` を送出する代わりに *正規化された* 空の値
を返します．例えば ``CharField`` の場合なら， Unicode の空文字列になります．
その他のフィールドクラスでは ``None`` になるはずです (フィールドによって異
なります)．

``label``
~~~~~~~~~

``label`` 引数を使うと，フィールドに「人間に優しい」ラベルを指定できます．
このラベルはフォーム内でフィールドを表示するときに使われます．

上の `フォームを HTML として出力する`_ で説明し
たように，フィールドのデフォルトのラベルはフィールド名のアンダースコアを除
去して，頭文字を大文字にしたものです．デフォルトのラベル命名規則が期待通り
のラベルを出力しない場合には，この引数を指定してください．

``label`` を指定したフォームの例を以下に示します．出力を短くするために
``auto_id=False`` にしています::

    >>> class CommentForm(forms.Form):
    ...     name = forms.CharField(label='Your name')
    ...     url = forms.URLField(label='Your Web site', required=False)
    ...     comment = forms.CharField()
    >>> f = CommentForm(auto_id=False)
    >>> print f
    <tr><th>Your name:</th><td><input type="text" name="name" /></td></tr>
    <tr><th>Your Web site:</th><td><input type="text" name="url" /></td></tr>
    <tr><th>Comment:</th><td><input type="text" name="comment" /></td></tr>

.. _`フォームを HTML として出力する`: `Outputting forms as HTML`_

``initial``
~~~~~~~~~~~

``initial`` 引数を使うと，非束縛フォーム内でフィールドをレンダするときの初
期値を指定できます．

この引数を使うケースは，例えば以下のように，「空の」フォームの各フィールド
を特定の値で初期化して表示したい場合です::

    >>> class CommentForm(forms.Form):
    ...     name = forms.CharField(initial='Your name')
    ...     url = forms.URLField(initial='http://')
    ...     comment = forms.CharField()
    >>> f = CommentForm(auto_id=False)
    >>> print f
    <tr><th>Name:</th><td><input type="text" name="name" value="Your name" /></td></tr>
    <tr><th>Url:</th><td><input type="text" name="url" value="http://" /></td></tr>
    <tr><th>Comment:</th><td><input type="text" name="comment" /></td></tr>

こんなことをしなくても，フォームに初期データの入った辞書を渡せばいいのにと
思うかもしれませんね．しかし，フォームにデータを渡して束縛フォームにすると，
データを表示する際に検証がトリガされてしまい， HTML 出力にバリデーションエ
ラーが入ってしまいます::

    >>> class CommentForm(forms.Form):
    ...     name = forms.CharField()
    ...     url = forms.URLField()
    ...     comment = forms.CharField()
    >>> default_data = {'name': 'Your name', 'url': 'http://'}
    >>> f = CommentForm(default_data, auto_id=False)
    >>> print f
    <tr><th>Name:</th><td><input type="text" name="name" value="Your name" /></td></tr>
    <tr><th>Url:</th><td><ul class="errorlist"><li>Enter a valid URL.</li></ul><input type="text" name="url" value="http://" /></td></tr>
    <tr><th>Comment:</th><td><ul class="errorlist"><li>This field is required.</li></ul><input type="text" name="comment" /></td></tr>

このため，非束縛フォームの場合に限って ``initial`` に指定した値が出力される
ようになっているのです．束縛フォームの場合，出力は常に束縛済みのデータにな
ります．

また， ``initial`` の指定値は，フィールドの値が指定されなかった場合の
「フォールバック用の」値には *ならない* ので注意が必要です．
``initial`` の値は初期値の入ったフォームの表示 *だけ* に用いられます::

    >>> class CommentForm(forms.Form):
    ...     name = forms.CharField(initial='Your name')
    ...     url = forms.URLField(initial='http://')
    ...     comment = forms.CharField()
    >>> data = {'name': '', 'url': '', 'comment': 'Foo'}
    >>> f = CommentForm(data)
    >>> f.is_valid()
    False
    # フォームの値は初期値にフォールバック *しません．*
    >>> f.errors
    {'url': [u'This field is required.'], 'name': [u'This field is required.']}

``widget``
~~~~~~~~~~

``widget`` 引数を使うと，フィールドをレンダリングするときの ``Widget`` クラ
スを指定できます．詳しくは後述の `ウィジェット <#widgets>`_ を参照してくだ
さい．

``help_text``
~~~~~~~~~~~~~

``help_text`` 引数を使うと，フィールドに説明文をつけられます．
``help_text`` を指定した場合，その内容がフォームをレンダした時に該当フィー
ルドの隣に表示されます．

以下に， ``help_text`` を使ったフォームの例を示します．この例では，フォーム
の二つのフィールドに ``help_text`` を指定しています．出力を単純にするために，
``auto_id=False`` を指定しています::

    >>> class HelpTextContactForm(forms.Form):
    ...     subject = forms.CharField(max_length=100, help_text='100 characters max.')
    ...     message = forms.CharField()
    ...     sender = forms.EmailField(help_text='A valid e-mail address, please.')
    ...     cc_myself = forms.BooleanField()
    >>> f = HelpTextContactForm(auto_id=False)
    >>> print f.as_table()
    <tr><th>Subject:</th><td><input type="text" name="subject" maxlength="100" /><br />100 characters max.</td></tr>
    <tr><th>Message:</th><td><input type="text" name="message" /></td></tr>
    <tr><th>Sender:</th><td><input type="text" name="sender" /><br />A valid e-mail address, please.</td></tr>
    <tr><th>Cc myself:</th><td><input type="checkbox" name="cc_myself" /></td></tr>
    >>> print f.as_ul()
    <li>Subject: <input type="text" name="subject" maxlength="100" /> 100 characters max.</li>
    <li>Message: <input type="text" name="message" /></li>
    <li>Sender: <input type="text" name="sender" /> A valid e-mail address, please.</li>
    <li>Cc myself: <input type="checkbox" name="cc_myself" /></li>
    >>> print f.as_p()
    <p>Subject: <input type="text" name="subject" maxlength="100" /> 100 characters max.</p>
    <p>Message: <input type="text" name="message" /></p>
    <p>Sender: <input type="text" name="sender" /> A valid e-mail address, please.</p>
    <p>Cc myself: <input type="checkbox" name="cc_myself" /></p>

.. _Dynamic initial values:

初期値を動的に決定する
----------------------

フィールドオブジェクトの ``initial`` 引数を使えばフィールドの初期値をハード
コードできます．では，初期値を動的に決めたい場合はどうすればよいのでしょう．
例えば，現在ログインしているユーザで ``username`` フィールドを埋めたいよう
な場合です．

動的に初期値を決めるには，フォームオブジェクトの ``initial`` 引数を使います．
この引数はフィールド名と初期値を対応づけた辞書として指定します．全てのフィー
ルドを含める必要はなく，初期値を設定したいフィールドだけでかまいません．例
を示しましょう::

    >>> class CommentForm(forms.Form):
    ...     name = forms.CharField()
    ...     url = forms.URLField()
    ...     comment = forms.CharField()
    >>> f = CommentForm(initial={'name': 'your username'}, auto_id=False)
    >>> print f
    <tr><th>Name:</th><td><input type="text" name="name" value="your username" /></td></tr>
    <tr><th>Url:</th><td><input type="text" name="url" /></td></tr>
    <tr><th>Comment:</th><td><input type="text" name="comment" /></td></tr>
    >>> f = CommentForm(initial={'name': 'another username'}, auto_id=False)
    >>> print f
    <tr><th>Name:</th><td><input type="text" name="name" value="another username" /></td></tr>
    <tr><th>Url:</th><td><input type="text" name="url" /></td></tr>
    <tr><th>Comment:</th><td><input type="text" name="comment" /></td></tr>

フィールドの ``initial`` パラメタと同じく，フォームの初期値が表示されるのは
非束縛フォームだけであり，ユーザが特定のフィールドに値を入力しなかったとき
のフォールバックとしては使われません．

最後に，フィールドに ``initial`` が定義されていて， *かつ* フォームの初期化
時にも ``initial`` を指定した場合，後者の ``initial`` が優先されるので気を
付けてください．例えば，以下のように，フィールドとフォームの両方に
``initial`` を指定した場合，フォームの値の方が使われます::

    >>> class CommentForm(forms.Form):
    ...     name = forms.CharField(initial='class')
    ...     url = forms.URLField()
    ...     comment = forms.CharField()
    >>> f = CommentForm(initial={'name': 'instance'}, auto_id=False)
    >>> print f
    <tr><th>Name:</th><td><input type="text" name="name" value="instance" /></td></tr>
    <tr><th>Url:</th><td><input type="text" name="url" /></td></tr>
    <tr><th>Comment:</th><td><input type="text" name="comment" /></td></tr>


.. _Creating custom fields:

カスタムフィールドの作成
------------------------

組み込みのフィールドクラスが用途に合わなくても，カスタムのフィールドクラス
は簡単に作成できるので大丈夫です．カスタムのフィールドクラスは
``django.newforms.Field`` をサブクラス化します．
フィールドクラスを定義する際の制約は， ``clean()`` メソッドを実装すること，
``__init__()`` メソッドが前述のコアとなる引数 (``required``, ``label``,
``initial``, ``widget``, ``help_text``) を持つことだけです．


.. _Generating forms for models:

モデルからフォームを生成する
============================

データベース指向のアプリケーションを開発しているなら， Django のモデルとほ
ぼ同じ内容のフォームを作ることもあるでしょう．たとえば， ``BlogComment`` と
いうモデルを作っておき，ユーザがコメントを入力できるようなフォームを作成し
たいような場合です．こうした状況では，フォームの名かでフィールドタイプをい
ちいち定義するのは二度手間というものです．なぜなら，モデル中にすでにフィー
ルドを定義しているからです．

そこで， Django では， Django モデルからフォームクラスを生成できるヘルパ関
数をいくつか提供しています．

``form_for_model()``
--------------------

``django.newforms.form_for_model()`` メソッドは，引数に指定したモデルの定義
に従ってフォームを生成します．このメソッドは，モデルクラスを渡すとフォーム
クラスを返します．フォームクラスの中には，モデル中の各フィールドに対応した
フォームフィールドが入っています．

例を示します::

    >>> from django.newforms import form_for_model

    # Create the form class.
    >>> ArticleForm = form_for_model(Article)

    # Create an empty form instance.
    >>> f = ArticleForm()

繰り返しになりますが， ``form_for_model()`` は，モデルのインスタンスでなく，
*クラス* を引数にとり，フォームクラスのインスタンスではなく *クラス* を返し
ます．

.. _Field types:

フィールド型
~~~~~~~~~~~~

生成されたフォームクラスは，各モデルフィールドに対応したフォームフィールド
を持っています．各モデルフィールドは，デフォルトのフォームフィールドに対応
しています．たとえば，モデルクラス上の ``CharField`` は，フォーム上でも
``CharField`` 型のフォームフィールドとして表現されます ``ManyToManyField``
は ``MultipleChoiceField`` として表現されます．モデルフィールド型からフォー
ムフィールド型への変換表を以下に示します:

    ===============================  ========================================
    モデルフィールド                 フォームフィールド
    ===============================  ========================================
    ``AutoField``                    フィールド上に表示されません
    ``BooleanField``                 ``BooleanField``
    ``CharField``                    ``max_length`` がモデルフィールドの
                                     ``maxlength`` と同じ値の ``CharField``
    ``CommaSeparatedIntegerField``   ``CharField``
    ``DateField``                    ``DateField``
    ``DateTimeField``                ``DateTimeField``
    ``EmailField``                   ``EmailField``
    ``FileField``                    ``CharField``
    ``FilePathField``                ``CharField``
    ``FloatField``                   ``CharField``
    ``ForeignKey``                   ``ModelChoiceField`` (下記参照)
    ``ImageField``                   ``CharField``
    ``IntegerField``                 ``IntegerField``
    ``IPAddressField``               ``CharField``
    ``ManyToManyField``              ``ModelMultipleChoiceField`` (下記参照)
    ``NullBooleanField``             ``CharField``
    ``PhoneNumberField``             (``django.contrib.localflavor.us`` の)
                                     ``USPhoneNumberField``
    ``PositiveIntegerField``         ``IntegerField``
    ``PositiveSmallIntegerField``    ``IntegerField``
    ``SlugField``                    ``CharField``
    ``SmallIntegerField``            ``IntegerField``
    ``TextField``                    ``widget=Textarea`` の ``CharField``
    ``TimeField``                    ``TimeField``
    ``URLField``                     ``verify_exists`` が モデルフィールド
                                     の ``verify_exists`` と同じ値の 
                                     ``URLField``
    ``USStateField``                 ``widget=USStateSelect`` の ``CharField``
                                     (``USStateSelect`` は
                                     ``django.contrib.localflavor.us`` から)
    ``XMLField``                     ``widget=Textarea`` の ``CharField``
    ===============================  ========================================

``ForeignKey`` と ``ManyToManyField`` モデルフィールド型は特別なケースとし
て扱われます:

    * ``ForeignKey`` は ``django.newforms.ModelChoiceField`` になります．
      これは選択肢が ``QuerySet`` の内容であるような ``ChoiceField`` です．

    * ``ManyToManyField`` は ``django.newforms.ModelMultipleChoiceField``
      で表されます．これは選択肢が ``QuerySet`` の内容であるような
      ``MultipleChoiceField`` です．

加えて，各フォームフィールドには以下のような属性が追加されます:

    * モデルフィールドが ``blank=True`` の場合，対応するフォームフィールド
      の ``required`` 属性が ``False`` になります．それ以外の場合は
      ``required=True`` です．

    * フォームフィールドの ``label`` 属性は，モデルフィールドの
      ``verbose_name`` の頭文字を大文字にしたものになります．

    * フォームフィールドの ``help_text`` 属性は，モデルフィールドの
      ``help_text`` の値になります．

    * モデルフィールドに ``choices`` が設定されている場合，フォームフィール
      ドの ``widget`` 型は ``Select`` になり，選択肢として ``choices`` の内
      容が使われます．

最後に，モデルフィールドから生成したフォームフィールドの値はオーバライドで
きるということに注意してください．詳しくは後述の
「 `デフォルトフィールド型のオーバライド`_ 」 を参照してください．

.. _`デフォルトフィールド型のオーバライド`: `Overriding the default field types`_


.. _A full example:

詳細な例
~~~~~~~~

まず，以下のようなモデル群を想定します::

    from django.db import models

    TITLE_CHOICES = (
        ('MR', 'Mr.'),
        ('MRS', 'Mrs.'),
        ('MS', 'Ms.'),
    )

    class Author(models.Model):
        name = models.CharField(maxlength=100)
        title = models.CharField(maxlength=3, choices=TITLE_CHOICES)
        birth_date = models.DateField(blank=True, null=True)

        def __str__(self):
            return self.name

    class Book(models.Model):
        name = models.CharField(maxlength=100)
        authors = models.ManyToManyField(Author)

``form_for_model(Author)`` を呼び出すと，以下のクラスと等価なフォームクラス
を返します::

    class AuthorForm(forms.Form):
        name = forms.CharField(max_length=100)
        title = forms.CharField(max_length=3,
                    widget=forms.Select(choices=TITLE_CHOICES))
        birth_date = forms.DateField(required=False)

``form_for_model(Book)`` を呼び出すと，以下のクラスと等価なフォームクラス
を返します::

    class BookForm(forms.Form):
        name = forms.CharField(max_length=100)
        authors = forms.ModelMultipleChoiceField(queryset=Author.objects.all())

.. _`The save() method`:

``save()`` メソッド
~~~~~~~~~~~~~~~~~~~

``form_for_model()`` で生成したフォームにも， ``save()`` メソッドがあります．
``save()`` メソッドは，フォームに結びつけられたデータベースオブジェクトの生
成と保存を行います．例えば::

    # POST データからフォームインスタンスを生成する
    >>> f = ArticleForm(request.POST)

    # フォームのデータから新たな Article オブジェクトを生成して保存する
    >>> new_article = f.save()

``save()`` は，フォーム中のデータの検証に成功していない場合，つまり，
``form.errors`` が真の場合に ``ValueError`` を送出します．

.. _Using an alternate base class:

フォームのベースクラスを変更する
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

``form_for_model()`` が生成するフォームにカスタムのメソッドを追加したい場合，
``django.newfdorms.BaseForm`` を拡張して，その中にカスタムメソッドを入れま
す．そして， ``form_for_model()`` を呼び出す際に， ``form`` パラメタに自作
のフォームを指定してベースクラスにさせます::

    # 自作のベースクラスを作成する
    >>> class MyBase(BaseForm):
    ...     def my_method(self):
    ...         # Do whatever the method does

    # 自作のベースクラスを使ってフォームクラスを生成する
    >>> ArticleForm = form_for_model(Article, form=MyBase)

    # フォームのインスタンス化
    >>> f = ArticleForm()

    # ベースクラスのメソッドを使う
    >>> f.my_method()

.. _Using a subset of fields on the form:

フォームの一部のフィールドだけを使う
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

**開発版の Django で新たに追加された機能です**

場合によっては，モデルからフォームを生成する際に，モデルの一部のフィールド
だけを表示したいこともあるでしょう． ``form_for_model()`` に入れるフィール
ドを，モデルフィールドのサブセットにするには，二つの方法があります:

    1. モデルのフィールドに ``editable=False`` を設定しておくと，
       ``form_for_model()`` から生成されたフォームは *常に* そのフィールド
       を含まなくなります．

    2. ``form_for_model()`` に ``fields`` 引数を指定します．この引数を指定
       する場合，フォームに含めたいフィールド名のリストにせねばなりません．

       例えば， ``Author`` モデルからフォームを生成するときに， ``name`` と
       ``title`` フィールドだけをフォームに含めたいなら， ``fields`` を以下
       のように定義します::

           PartialArticleForm = form_for_model(Author, fields=('name', 'title'))

.. note::

    ``form_for_model()`` に ``fields`` を指定してフォームを生成する場合，
    フォームに *含めない* フィールドは，デフォルト値を持つか ``None`` を値
    にとりえるフィールドであるかよく確認してください．フォーム内に含まれな
    いフィールドがあると，フォームを使ってオブジェクトを生成した際に，フィー
    ルドから値が提供されないことがあり，そのためにインスタンスを保存できな
    くなるからです．

.. _Overriding the default field types:

デフォルトのフィールド型をオーバライドする
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

上の `フィールド型 <#field_types>`_ に挙げたデフォルトフィールド型は，いわ
ゆる「気の利いたデフォルト値」にすぎません．モデルに ``DateField`` が入って
いる場合，普通はフォームにも ``DateField`` が入っていてほしいでしょう．
とはいえ， ``form_for_model()`` は，特定のモデルフィールドに対してフォー
ムのフィールド型を変更できるという柔軟さも備えています．フィールド型の変更
は「フォームフィールドコールバック (formfield callback)」で行います．

フォームフィールドコールバック関数は，モデルフィールドを指定して呼び出すと，
フォームフィールドのインスタンスを返します．フォームを生成する際，
``form_for_model()`` はフォームフィールドコールバックを使って，フォームフィー
ルドの型を決定します．

デフォルトでは， ``form_for_model()`` は，モデルフィールドの
``formfield()`` メソッドを呼び出します::

    def default_callback(field, **kwargs):
        return field.formfield(**kwargs)

``kwargs`` は， ``required=True`` や ``label='Foo'`` のような，フォームフィー
ルドに渡されることになるキーワード引数です．

例えば，モデル上の全ての ``DateField`` に対して ``MyDateFormField`` を使い
たい場合，以下のようにコールバックを定義します::

    >>> def my_callback(field, **kwargs):
    ...     if isinstance(field, models.DateField):
    ...         return MyDateFormField(**kwargs)
    ...     else:
    ...         return field.formfield(**kwargs)

    >>> ArticleForm = form_for_model(formfield_callback=my_callback)

コールバックは，自分がデフォルト設定に対して手を加えたい対象のフィールド以
外も含めた， *全ての* モデルフィールドを扱えねばならないので注意が必要です．
上の例で ``else`` 節にデフォルトの挙動を実装しているのはそのためです．

.. _Finding the model associated with a form:

フォームに関連づけられたモデルを取り出す
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

フォームの構築に使われたモデルクラスは，生成されたフォームの ``_model`` プ
ロパティからアクセスできます::

    >>> ArticleForm = form_for_model(Article)
    >>> ArticleForm._model
    <class 'myapp.models.Article'>

``form_for_instance()``
-----------------------

``form_for_instance()`` は ``form_for_model()`` に似ていますが，モデルのク
ラスではなく，モデルのインスタンスを引数にとります::

    # Author オブジェクトを生成
    >>> a = Author(name='Joe Smith', title='MR', birth_date=None)
    >>> a.save()

    # 特定の Author オブジェクト用のフォームを生成
    >>> AuthorForm = form_for_instance(a)

    # フォームのインスタンス化
    >>> f = AuthorForm()

``form_for_instance()`` で生成したフォームクラスでインスタンスを生成すると，
フォームフィールドの初期値はインスタンスから取り出されます．ただし，このデー
タはフォームに結びつけられていません．従って，フォームを保存する前に，デー
タをフォームに結びつける必要があります．

``form_for_instance()`` で生成したフォームのインスタンスに対して ``save()``
を呼び出すと，データベース上のインスタンスが更新されます．
``form_for_model()`` と同様，データの検証に失敗すると， ``save()`` は
``ValueError`` 例外を送出します．

``form_for_instance()`` は， ``form``, ``fields`` および
``formfield_callback`` パラメタをとります．これらの引数の挙動は
``form_for_model()`` の同名の引数と同じです．

.. _When should you use form_for_model() and form_for_instance():

``form_for_model()`` や ``form_for_instance()`` はいつ使うもの?
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

``form_for_model()`` や ``form_for_instance()`` は，一般的なケースを扱うた
めのショートカットにすぎません．こうしたショートカットは，複数のモデルのフィー
ルドをマップするフォームや，モデル上に *ない* フィールドの入ったフォームを
生成したい場合には利用できません．それに，フォームクラスをこつこつ作成する
のはちっとも難しい作業ではありません．


.. _More coming soon:

つづく
======

現時点でのドキュメントはこれだけです．詳しくは ``django.newforms`` のユニッ
トテストである
http://code.djangoproject.com/browser/django/trunk/tests/regressiontests/forms/tests.py
を参照してください． newforms でできることをよく理解できるはずです．

このライブラリを使ってみたくてうずうずしているなら，もう少しだけ我慢してく
ださいね．今，コードとドキュメントの仕上げにかかっているところなんです．

