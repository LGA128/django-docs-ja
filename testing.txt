==============================
Djangoアプリケーションのテスト
==============================

:revision-up-to: 7127 (0.97pre SVN)

今日の Web 開発者にとって、自動化されたテストはバグ潰しの工程で極めて有用な
ツールです。複数のテストを集めた **テストスイート** を使えば、Web開発におけ
るいくつもの問題を解決したり回避したりできます:

  * 新たなコードを書く際、コードが期待通りに動作するかテストできます。

  * 以前のコードを修正したりリファクタする場合、テストによって、コードの変
    更がアプリケーションに意図しない影響を及ぼさないか調べられます。

Web アプリケーションは、 HTTP レベルのリクエスト処理、フォームの検証と処理、
そしてテンプレートレンダリングまで、複数のロジックレイヤから構成されていま
す。そのため、Webアプリケーションのテストは複雑なタスクです。 Django のテス
ト実行フレームワークと関連ユーティリティを使えば、仮想的なリクエストを発行
したり、テストデータを挿入したり、アプリケーションの出力を調べて、コードが
期待通りに動作しているか検証したりできます。

しかも素晴らしいことに、テストはとても簡単なのです。

このドキュメントは前後半の 2 つの節に別れています。前半では Django における
テストの書き方を、後半ではテストの実行方法を説明します。

.. admonition:: note
    
    このテストフレームワークは現在開発中なので、次の公式リリースまでに多少
    の変更が加わるかもしれません。

    (だからといって、テスト書きをサボる理由にはなりませんよ！)

.. _Writing tests:

テストを書く
============

Django でテストを書く方法は主に 2 つあり、それぞれ Python の標準ライブラリ
についてくる二つのテストフレームワークに対応しています。フレームワークは以
下の 2 つです:

    * **doctest** -- 関数やクラスの docstring (ドキュメンテーション文字列)
      に埋め込まれたテストで、例えば以下のように Python の対話インタプリタ
      セッションを模した方法で書かれています::

          def my_func(a_list, idx):
              """
              >>> a = ['larry', 'curly', 'moe']
              >>> my_func(a, 0)
              'larry'
              >>> my_func(a, 1)
              'curly'
              """
              return a_list[idx]

    * **ユニットテスト (unit test)** -- 以下の例のように、テストを
      ``unittest.TestCase``` のサブクラスのメソッドとして表現したものです::

          import unittest

          class MyFuncTestCase(unittest.TestCase)
              def testBasic(self):
                  a = ['larry', 'curly', 'moe']
                  self.assertEquals(my_func(a, 0), 'larry')
                  self.assertEquals(my_func(a, 1), 'curly')

好みに応じて、どちらのテストを使ってもかまいませんし、両方のテストを組み合
わせてもかまいません。また、後でほんの少しだけ説明しますが、他のテストフレー
ムワークを使っても構いません。

.. _Writing doctests:

doctest を書く
--------------

doctest は、Python の標準モジュール、 doctest_ によるテストです。 doctest
は docstring (ドキュメンテーション文字列) から、 Python の対話インタプリタ
セッションの形式をとる部分を探し出して実行します。 doctest の詳しい構造につ
いての解説はこのドキュメントの範囲を超えた話なので、公式ドキュメントを参照
してください。

.. admonition:: **docstring** とは?

    docstring の詳しい説明 (と、効果的な docstring の書き方) は、
    :PEP:`257` (訳注: PEP 257 の和訳は 
    http://www.python.jp/doc/contrib/peps/pep-0257.txt にあります) に書かれ
    ています:
        
        docstring とは、モジュールや関数、クラス、メソッド定義のブロック中
        の先頭に置かれた文字列リテラルです。 docstring を定義すると、オブジェ
        クトの ``__doc__`` という特殊な属性になります。
        

    例えば、下の関数には、関数の説明の入った docstring があります::

        def add_two(num):
            "引数に指定した数に 2 を加えて返します。"
            return num + 2

    テストはそれ自体素晴らしいドキュメントになることも多いので、テストをそ
    のまま docstring に入れておけば、ドキュメント化とコードのテストの 
    *両方を* 効率的に行えます。

テストランナは、 Django アプリケーションの中の以下のファイルから doctest を
探して実行します:

    * ``models.py`` ファイル。モジュールレベル、かつ/またはモデルレベルの
      doctest を記述します。一般には、アプリケーションレベルの doctest はモ
      ジュールの docstring として記述し、モデルレベルの docstring はモデル
      クラスの docstring として記述します。

    * アプリケーションディレクトリ、すなわち ``models.py`` の入ったディレク
      トリ下に置かれた ``tests.py`` という名前のファイル。このファイルは、
      モデルに関係しないような doctest を書きたい場合のフックとして使えます。

doctest の文字列は ``models.py`` の全てのオブジェクトに対して記述できますが、
慣習的には、アプリケーションレベルの doctest はモジュールの docstring に、
モデルレベルの doctest は各モデルの docstring に配置します。

モデル定義で doctest を使った例を示します::

    # models.py

    from django.db import models
    
    class Animal(models.Model):
        """
        鳴き声から動物を調べるテスト
        
        # 動物インスタンスを生成する
        >>> lion = Animal.objects.create(name="lion", sound="roar")
        >>> cat = Animal.objects.create(name="cat", sound="meow")
        
        # speak() を呼び出す
        >>> lion.speak()
        'The lion says "roar"'
        >>> cat.speak()
        'The cat says "meow"'
        """
        
        name = models.CharField(max_length=20)
        sound = models.CharField(max_length=20)
        
        def speak(self):
            return 'The %s says "%s"' % (self.name, self.sound)


`テストを実行する`_ と、テストユーティリティは上の docstring を探し出して、
Python の対話セッションに見える部分を検出し、そこに書かれた命令を実行して、
docstring に書かれた結果と実際の実行結果が一致するかどうかを確かめます。

モデルテストの場合、テストランナが独自にテストデータベースを作成します。す
なわち、データベースに対してアクセスするテスト -- 例えば、モデルインスタン
スを生成して保存するようなテスト -- が、実運用のためのデータベースに影響を
及ぼすことはありません。 doctest はいずれも「白紙状態」、すなわち、各モデル
のデータベーステーブルが空の状態で実行されます (詳しくは、後述のフィクスチャ
の節を参照してください) 。この機能を使うには、 Django がデータベースに接続
するときのユーザに ``CREATE DATABASE`` の権限を持たせておかねばならないので
注意してください。

doctest の詳しい動作原理は、 `標準ドキュメントの doctest の項`_
を参照してください。

.. doctest: http://docs.python.org/lib/module-doctest.html
.. _standard library documentation for doctest: doctest_
.. _doctest: http://python.jp/doc/release/lib/module-doctest.html
.. _`標準ドキュメントの doctest の項`: doctest_

.. _Writing unit tests:

ユニットテストを書く
--------------------

Django の単体テストもまた、doctest と同様、標準ライブラリモジュールの
unittest_ を使います。このモジュールは、 doctest_ とは違った、 クラスベース
のやり方でテストを定義します。

doctest と同様、 Django のテストランナは、以下の二つの場所からユニットテス
トを探します:

    * ``models.py`` ファイル。テストランナはこのモジュールから
      ``unittest.TestCase`` のサブクラスを探します。

    * アプリケーションディレクトリ、すなわち ``models.py`` の入ったディレク
      トリ下に置かれた ``tests.py`` という名前のファイル。上と同様に、テス
      トランナはこのモジュールから ``unittest.TestCase`` のサブクラスを探し
      ます。

以下の ``unittest.TestCase`` のサブクラスは、前節の doctest と同じテストを
実現しています::

    import unittest
    from myapp.models import Animal
    
    class AnimalTestCase(unittest.TestCase):

        def setUp(self):
            self.lion = Animal.objects.create(name="lion", sound="roar")
            self.cat = Animal.objects.create(name="cat", sound="meow")
        
        def testSpeaking(self):
            self.assertEquals(self.lion.speak(), 'The lion says "roar"')
            self.assertEquals(self.cat.speak(), 'The cat says "meow"')
            
`テストを実行する`_ と、テストユーティリティはデフォルトの動作として、
``models.py`` と ``tests.py`` に入っている全てのテストケース (つまり
``unittest.TestCase`` のサブクラス) を捜し出し、そこからテストスイートを自
動的に構築して、スイートを実行します。

開発バージョンの Django には、あるモジュールのテストスイートを定義する方法
をもう一つ提供しています:  ``models.py`` や ``tests.py`` で ``suite()`` メ
ソッドを定義している場合、 Django のテストランナはこのメソッドを使ってテス
トスイートを構築します。この仕様は、ユニットテストにおいて 
`推奨されているテストスイートの構築方法`_ に従っています。複雑なテストスイー
トの構築方法についての詳細は Python のドキュメントを参照してください。

``unittest`` の詳細は `標準ライブラリドキュメントの unittest の項`_ を参照
してください。

.. unittest: http://docs.python.org/lib/module-unittest.html
.. _standard library unittest documentation: unittest_
.. _run your tests: `Running tests`_
.. _suggested organization: http://docs.python.org/lib/organizing-tests.html
.. _`テストを実行する`: `Running tests`_
.. _unittest: http://python.jp/doc/release/lib/module-unittest.html
.. _`標準ライブラリドキュメントの unittest の項`: unittest_
.. _`推奨されているテストスイートの構築方法`: 
  http://python.jp/doc/release/lib/organizing-tests.html

.. _Which should I use?:

どちらのテストを使うべきか
--------------------------

Django は標準的な Python テストフレームワークの両方をサポートしているので、
どちらを選ぶかは、開発者個々人の好み次第です。もちろん、 *両方* を同時に使っ
てもかまいません。

とはいえ、テストを初めて書く開発者にとっては、この選択は混乱
のもとになるでしょう。そこで、どちらのテストを使うべきかを決める手がかりに
なるよう、 doctest と単体テストの主な違いについて示します:

  * そこそこ Python に慣れているなら、 ``doctest`` の方がより「Python的
    (pythonic)」に感じることでしょう。 doctest はテストをできるだけ楽に書け
    るように設計されているので、クラスやメソッドを書くときのオーバヘッドが
    ほとんどありません。単に docstring にテストを書くだけでよいのです。それ
    に、モジュールに対してドキュメントを自動生成させられるという利点もあり
    ます。つまり、 doctest を上手に書けば、ドキュメント作成とテストを同時に
    片付けられて一石二鳥、というわけです。

    また、テストにまだ慣れていない開発者は、 doctest を使った方が早くテスト
    について学べることでしょう。

  * Java での開発経験のある開発者なら、 ``unittest`` フレームワークはとても
    理解しやすいはずです。 ``unittest`` は Java の JUnit に影響を受けている
    ので、他の言語で JUnit から派生したテストフレームワークを使ったことがあ
    るのなら、``unittest`` はかなりしっくりくるはずです。

  * 同じコードを含むような一連のテストを書くときには、 ``unittest`` フレー
    ムワークのクラスとメソッドによる設計が気に入るでしょう。共通のタスクを
    抽象化して、メソッド化できるからです。また、 ``unittest`` フレームワー
    クは ``unittest`` はテストの初期化／終了処理のルーチンをサポートしてい
    るので、テストケースを実行するときの環境を高い水準でコントロールできま
    す。

繰り返しになりますが、(一つのアプリケーションの中であっても) 両方のシステム
を並べて使えることを忘れないでください。どちらのテストシステムにも、状況に
応じて適した部分があるので、大抵のプロジェクトでは、最終的には両方のテスト
システムを使うことになるものです。

.. _Running tests:

テストを実行する
================

テストを実行するには、プロジェクトの ``manage.py`` ユーティリティを使います::

    $ ./manage.py test

特定のアプリケーションに対してテストを実行したければ、コマンドラインにアプ
リケーションの名前を追加します。例えば、 ``INSTALLED_APPS`` に
``myproject.polls`` と ``myproject.animals`` というアプリケーションが入って
おり、 animals の単体テストを実行したいだけなら、以下のようにします::
 
    $ ./manage.py test animals

**開発バージョンの Django で新たに追加された機能:**
単体テストを実行する際、どのテストを実行するかを指定できます。あるアプリケー
ション用のテストケースを実行する場合 (例えば、上で解説した AnimalTestCase
の場合) は、コマンドラインにテストケースの名前を追加してください::

    $ ./manage.py test animals.AnimalTestCase

**開発バージョンの Django で新たに追加された機能:**
テストケース中の個別のテストメソッドを実行したければ、メソッド名を指定して
ください::

    $ ./manage.py test animals.AnimalTestCase.testFluffyAnimals

.. _The test database:

テストデータベース
-------------------
 
データベースを必要とするテスト (モデルのテスト) に、「本番の (実運用環境の)」
データベースは必要ありません。テストの際には、空の別のデータベースが作成さ
れます。

テストがパスするか失敗するかに関わらず、テストデータベースは全てのテストを
実行し終えると消去されます。

デフォルトでは、
.. _Understanding the test output:

テストの出力を理解する
----------------------

テストを実行すると、まずテストランナ自身の初期化メッセージが表示されます::

    Creating test database...
    Creating table myapp_animal
    Creating table myapp_mineral
    Loading 'initial_data' fixtures...
    No fixtures found.

このメッセージは、テストランナがテストデータベースを作成したことを示してい
ます。テストデータベースは、空の、何もない状態から作成したデータベースで、
(モデルテストのような) データベースの必要なテストで使われます。

デフォルトでは、テストデータベースの名前は、 ``DATABASE_NAME`` に指定した
データベース名の前に ``test_`` を付けたものです。 SQLite データベースエンジ
ンを使っている場合、デフォルトではテストをメモリ上のデータベースで行います
(すなわち、データベースをメモリ上に生成し、ファイルシステムを全く経由しませ
ん！) 。テストデータベースの名前をデフォルト意外の値にしたければ、
``TEST_DATABASE_NAME`` 設定を使って指定します。
 
テスト用に別のデータベースを使うことを除けば、テストランナは設定ファイルの
データベースに関する他の設定、 ``DATABASE_ENGINE``, ``DATABASE_USER``,
``DATABASE_HOST`` などをそのまま使います。テストデータベースは
``DATABASE_USER`` の権限で作成されるので、このユーザは新たに生成されたデー
タベースを操作する権限を備えていなければなりません。

**開発バージョンの Django で新たに追加された機能:** 
テスト用データベースの文字セットエンコーディング設定を細かく調整したいのな
ら、 ``TEST_DATABASE_CHARSET`` 設定を使ってください。 MySQL を使っているなら、
``TEST_DATABASE_COLLATION`` でテストデータベースで使うコレーション
(collation) を指定できます。これらの設定については、 settings_ ファイルのド
キュメントを参照してください。

.. _settings: ../settings/

.. _Understanding the test output:

テストプログラムの出力を理解する
---------------------------------

テストを実行すると、テストランナ自体が大量に出力するメッセージに出くわすで
しょう。コマンドラインの ``verbosity`` オプションを使えば、メッセージの詳細
レベルを制御できます::

    Creating test database...
    Creating table myapp_animal
    Creating table myapp_mineral
    Loading 'initial_data' fixtures...
    No fixtures found.

上のメッセージは、テストランナがデータベースをテストしたことを示します。

テストデータベースが生成されると、 Django はテストを実行します。全てのテス
トにパスすると、最後には以下のようなメッセージが表示されます::

    ----------------------------------------------------------------------
    Ran 22 tests in 0.221s

    OK

一方、失敗したテストがあると、失敗したテストに関する詳しい情報が表示されま
す::

    ======================================================================
    FAIL: Doctest: ellington.core.throttle.models
    ----------------------------------------------------------------------
    Traceback (most recent call last):
      File "/dev/django/test/doctest.py", line 2153, in runTest
        raise self.failureException(self.format_failure(new.getvalue()))
    AssertionError: Failed doctest test for myapp.models
      File "/dev/myapp/models.py", line 0, in models

    ----------------------------------------------------------------------
    File "/dev/myapp/models.py", line 14, in myapp.models
    Failed example:
        throttle.check("actor A", "action one", limit=2, hours=1)
    Expected:
        True
    Got:
        False

    ----------------------------------------------------------------------
    Ran 2 tests in 0.048s

    FAILED (failures=1)

エラー出力の詳細はこのドキュメントの範囲を超えるので解説はしませんが、ほと
んど直感的に理解できる内容のはずです。詳しくは、 Python の ``unittest`` ラ
イブラリのドキュメントを参照してください。

スクリプトのリターンコードは失敗したテストや出力のおかしかったテストの総数で
す。全てのテストにパスしていれば、リターンコードは 0 です。この仕様は、テス
トランナをシェルスクリプト上で動かしたり、テストが成功したかどうかをテスト
ランナのレベルで調べたい場合に便利です。

.. _Testing tools:

テスト用のツール
================

Django は、テストを書くときに便利なツールをいくつか提供しています。

.. _The test client:

テストクライアント
------------------

テストクライアント (test client) は、簡単なダミーブラウザとして動作する
Python のクラスです。テストクライアントを使うと、ビューをテストしたり、
プログラムを使ってDjango で作られたアプリケーションとやりとりできます。

テストクライアントを使ってできることをいくつか挙げましょう:

  * ある URL に対する GET や POST をシミュレートでき、低水準の HTTP (レスポ
    ンスヘッダや状態コード) 情報から、ページの内容まで、リクエストに対するレ
    スポンスの全てを調べられます。

  * 特定の URL に対して正しいビューが呼び出されるかどうかを調べられます。

  * 特定のリクエストに対して、特定のテンプレートを使ったレンダリングが行わ
    れ、その際に特定の値が入ったコンテキストが使われているかどうかを調べら
    れます。

テストクライアントは Twill_ や Selenium_ やその他のブラウザ自動化フレームワー
クを置き換えようとするものではありません。 Django のテストクライアントはもっ
と別の部分に焦点を当てているのです。すなわち:

  * 正しいビューが呼び出され、ビューが正しいコンテキストデータを生成してい
    るかどうかは、 Django のテストクライアントを使って調べてください。

  * Twill や Selenium は、 *レンダリング済みの* HTML や、 JavaScript の機能
    のような Web ページの *ビヘイビア* のテストに使ってください。
   
網羅的なテストスイートでは、両方のタイプのテストを組み合わせて使うはずです。

.. _Twill: http://twill.idyll.org/
.. _Selenium: http://www.openqa.org/selenium/

.. _Overview and a quick example:

テストの概要と簡単な例
~~~~~~~~~~~~~~~~~~~~~~

テストクライアントを使うには、 ``django.test.client.Client`` をインスタンス
化して、 Web ページを取得します::

    >>> from django.test.client import Client
    >>> c = Client()
    >>> response = c.post('/login/', {'username': 'john', 'password': 'smith'})
    >>> response.status_code
    200
    >>> response = c.get('/customer/details/')
    >>> response.content
    '<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 ...'

上の例でわかるように、 ``Client`` は Python 対話インタプリタのセッション中
でもインスタンス化できます。

テストクライアントの動作には重要な点がいくつかあります:

    * テストクライアントを実行するために Web サーバを起動する必要は
      *ありません* 。実際、 Web サーバがまったく動いていなくても、テストは
      何の問題もなく実行できるのです。というのも、テストクライアントは HTTP
      通信のオーバヘッドを回避して、 Django フレームワークに直接アクセスし
      ているからです。このからくりによって、ユニットテストを高速に実行でき
      ます。

    * ページを取得するときには、ドメインを含まない *パス部分だけ* を指定す
      るよう気をつけてください。例えば、以下の呼び出し::

          >>> c.get('/login/')

      は正しいですが、次の呼び出し::

          >>> c.get('http://www.example.com/login/')

      は正しくありません。

      Django のプロジェクトから生成されていない Web ページは、テストクライ
      アントで取得できません。Django 以外の Web ページを取得したければ、
      urllib_ や urllib2_ のような Python 標準ライブラリを使ってください。

    * テストクライアントは URL の解決に ``ROOT_URLCONF`` に指定された
      URLconf を使います。

    * 上の例は Python の対話インタプリタ中でも動作しますが、一部のテンプレー
      ト関連の機能などは *テストの実行中だけ* でしか使えません。

      というのも、 Django のテストランナは、あるビューでどのテンプレートが
      ロードされるかを決定するためにちょっとした黒魔術的なコードを使ってい
      るからです。この黒魔術 (実際には、メモリ上のテンプレートシステムに対
      するパッチ) は、テスト実行時にしか適用されません。

.. _urllib: http://docs.python.org/lib/module-urllib.html
.. _urllib2: http://docs.python.org/lib/module-urllib2.html

.. _Making requests:

リクエスト生成
~~~~~~~~~~~~~~

リクエストの生成には、 ``django.test.client.Client`` クラスを使います。
``Client`` は引数なしで生成します。::

    >>> c = Client()

``Client`` のインスタンスからは、以下のメソッドを呼び出せます:

``get(path, data={})``
    ``path`` に対する GET リクエストを行い、 ``Response`` オブジェクトを返
    します。 ``Response`` オブジェクトについては後で説明します。

    引数 ``data`` は辞書オブジェクトで、キー／値のペアが GET データのペイロー
    ドの生成に使われます。例えば::

        >>> c = Client()
        >>> c.get('/customers/details/', {'name':'fred', 'age':7})

    は、以下のような GET リクエストの送信と同じです::

        /customers/details/?name=fred&age=7

``post(path, data={}, content_type=MULTIPART_CONTENT)``
    ``path`` に対する POST リクエストを行い、 ``Response`` オブジェクトを返
    します。

    引数 ``data`` は辞書オブジェクトで、キー／値のペアが POST データのペイ
    ロード生成に使われます。例えば::

        >>> c = Client()
        >>> c.post('/login/', {'name': 'fred', 'passwd': 'secret'})

    は、以下のパス::

        /login/

    への POST リクエストで、以下の POST データ::

        name=fred&passwd=secret

    を伴います。

    ``content_type`` を指定した場合 (例えば XML ペイロードの場合には
    ``text/xml``)、引数 ``data`` の中身は POST リクエストそのままで送信され、 
    ``Content-Type`` ヘッダに ``content_type`` の値を使います。

    ``content_type`` を指定しなければ、 ``data`` の中身は
    ``multipart/form-data`` で送信されます。この場合、 ``data`` の中のキー／
    値のペアは、マルチパートメッセージにエンコードされ、 POST データのペイ
    ロード生成に使われます。

    あるキーに対して複数の値を提出 (submit) する場合 (例えば、
    ``<select multiple>`` の選択結果を指定する場合など) は、キーに対する値
    をリストやタプルにしてください。例えば、``choices`` という名前のフィー
    ルドから 3 つの行を選択して提出したければ::

      ``{'choices': ('a', 'b', 'd')}``

    のようにします。

    ファイルの送信には特別な扱いが必要です。ファイルの POST を行う場合、以
    下のように、ファイル名フィールドの名前をキーに、アップロードしたいファ
    イルのファイルハンドルを値に設定します::

        >>> c = Client()
        >>> f = open('wishlist.doc')
        >>> c.post('/customers/wishes/', {'name':'fred', 'attachment':f})
        >>> f.close()

    (``attachment`` という名前には特に意味はありません。ファイルを処理する
    コードで使いたい名前を指定してください)

    送信するファイルのハンドルは、 ``post()`` 後に手動で閉じねばならないの
    で注意してください。


``login(**credentials)``
    **開発バージョンの Django で新たに追加されました**

    Django の `認証システム`_ を使っていて、ログイン済みのユーザを扱う必要
    がある場合、テストクライアントの ``login()`` メソッドを使えば、サイトへ
    ログインするユーザをシミュレートできます。

    このメソッドを呼び出すと、テストクライアントはログインに必要なクッキー
    とセッションデータを持つようになり、テスト対象のビューのうち、ログイン
    の必要なテストをパスできるようになります。

    ``credentials`` 引数の形式は、使っている `認証バックエンド`_ によって変
    わります (認証バックエンドは ``AUTHENTICATION_BACKENDS`` で設定します)。
    Django が提供している標準の認証バックエンド (``ModelBackend``) を使う場
    合、 ``credentials`` にはユーザのユーザ名とパスワードをキーワード引数で
    指定します::

        >>> c = Client()
        >>> c.login(username='fred', password='secret')
        >>> # これでログイン保護されたビューに入れるようになりました。

    認証バックエンドを変えた場合、このメソッドは違った認証情報を要求するか
    もしれません。その場合、 ``login()`` は、認証バックエンドの
    ``authenticate()`` メソッドが必要とする認証情報をそのまま要求します。

    ``login()`` は、指定した認証情報が承認され、ログインに成功した場合に
    ``True`` を返します。

    このメソッドを使うには、事前にユーザを登録しておかねばなりません。上で説
    明したように、テストランナはテストデータベースを使ってテストを実行する
    ので、デフォルトではユーザが登録されていません。そのため、運用環境で使
    えるユーザはテスト環境では使えないのです。テストスイートの一環として、
    手動で (Django のモデル API を使って) ユーザを作成するか、フィクスチャ
    でユーザを登録してください。

``logout()``
    Django の `認証システム`_ を使っている場合、 ``logout()`` メソッドで、
    サイトからユーザをログアウトさせる効果をシミュレートできます。

    このメソッドを呼び出すと、テストクライアントはクッキーとセッションデー
    タを全て消去して、デフォルトの状態に戻します。それ以降のリクエストは、
    ビューからは ``AnonymousUser`` から送信されたリクエストとみなされます。

.. _authentication system: ../authentication/
.. _authentication backend: ../authentication/#other-authentication-sources
.. _`認証システム`: `authentication system`_
.. _`認証バックエンド`: `authentication backend`_

.. _Testing Responses:

レスポンスのテスト
~~~~~~~~~~~~~~~~~~

``get()`` および ``post()`` メソッドは、いずれも ``Response`` オブジェクト
を返します。 ``Response`` オブジェクトは Django のビューが返す
``HttpResponse`` オブジェクトと同じ *ではありません* 。このオブジェクトは
検証用のテストコード作成に便利なデータをいくつか備えています。

``Response`` オブジェクトには以下のようなプロパティがあります:

    ================  ========================================================
    属性              説明
    ================  ========================================================
    ``client``        レスポンス要求の生成に使われたテストクライアントです。

    ``content``       レスポンスの本体部分 (body) です。ビューがレンダリン
                      グによって生成した最終的なページコンテンツか、エラー
                      メッセージです。

    ``context``       レスポンスのページコンテンツのレンダに使われた
                      Context オブジェクトです。
                      
                      ``template`` と同様、複数のテンプレートを使ってレンダ
                      リングを行った場合、 ``context`` は Context オブジェ
                      クトをレンダリングで使った順に並べたリストになります。
 
    ``request``       レスポンスを得るために使用したリクエストデータです。
 
    ``headers``       レスポンスの HTTP ヘッダです。辞書形式です。
 
    ``status_code``   レスポンスの HTTP 状態コードです。全ての HTTP 状態コー
                      ドのリストは RFC2616_ を参照してください。

    ``template``      最終的なページコンテンツのレンダリングに使われた
                      Template のインスタンスです。テンプレートをファイルか
                      らロードした場合、テンプレートのファイル名を
                      ``template.name`` で調べられます
                      (``'admin/index.html'`` のような形式の文字列です)。
                      
                      複数のテンプレートをレンダリングしている場合 (例えば
                      `テンプレートの継承`_ を使っている場合) 、 
                      ``template`` はレンダリング順に並んだ  Template オブ
                      ジェクトのリストになります。
    ================  ========================================================

.. _RFC2616: http://www.w3.org/Protocols/rfc2616/rfc2616-sec10.html
.. _template inheritance: ../templates/#template-inheritance
.. _`テンプレートの継承`: `template inheritance`_

.. _Exceptions:

例外
~~~~

テストクライアントのアクセス先のビューが例外を送出するような場合、テストケー
ス内で例外にアクセスできます。例外のテストを行うには、通常の
``try...catch`` ブロックか、 ``unittest.TestCase.assertRaises()`` を使いま
す。

ただし、 ``Http404`` や ``PermissionDenied``, ``SystemExit`` といった例外は
テストケースからアクセスできません。 Django はこれらの例外を内部的に捕捉し
て、対応する適切な HTTP 応答コードに変換してしまうからです。これらの例外に
対しては、 ``response.status_code`` のチェックで対応してください。

.. _Persistent state:

セッションの永続性
~~~~~~~~~~~~~~~~~~

テストクライアントの動作はステートフルです。あるレスポンスにクッキーが入っ
ていると、クッキーはテストクライアント中に保存され、それ以降の ``get()`` や
``post()`` リクエストで使われます。

テストクライアントは、クッキーの有効期限ポリシを守りません。クッキーを期限
切れにしたければ、該当クッキーを ``client.cookies`` から手動で削除するか、
新たな ``Client`` インスタンスを生成してください (全てのクッキーを除去しま
す)。

テストクライアントには、永続セッション情報 (persistent state information)
を保存するためのプロパティが二つあります。これらのプロパティは、必要に応じ
てテスト条件の一部として検査できます。

    ===============  ====================================================
    プロパティ       説明
    ===============  ====================================================
    ``cookies``      Python の ``SimpleCookie`` 型のオブジェクトで、
                     全てのクライアントクッキーの現在値が入っています。
                     詳しくは `Cookie モジュールのドキュメント`_ を参照
                     してください。

    ``session``      セッション情報の入った辞書ライクなオブジェクトです。
                     詳しくは `セッションのドキュメント`_ を参照してくださ
                     い。
    ===============  ====================================================

.. _Cookie module documentation: http://docs.python.org/lib/module-Cookie.html
.. _session documentation: ../sessions/
.. _`Cookie モジュールのドキュメント`: `Cookie module documentation`_
.. _`セッションのドキュメント`: `session documentation`_

.. _Example:
             
ユニットテストの例
~~~~~~~~~~~~~~~~~~

テストクライアントを使った簡単なユニットテストを以下に示します::

    import unittest
    from django.test.client import Client

    class SimpleTest(unittest.TestCase):
        def setUp(self):
            # unittest を使う場合、毎回 Client を生成する必要があります。
            self.client = Client()

        def test_details(self):
            # GET リクエストを発行します。
            response = self.client.get('/customer/details/')

            # レスポンスが 200 OK であるか調べます。
            self.failUnlessEqual(response.status_code, 200)

            # レンダリングされるコンテキストの customers の長さが 5 である
            # か確かます。
            self.failUnlessEqual(len(response.context['customers']), 5)


.. _TestCase:

TestCaseクラス
--------------

通常の Python のユニットテストクラスは、 ``unittest.testCase`` ベースクラス
を拡張して使います。 Django では、 ``unittest.testCase`` を更に拡張した独自
のベースクラス、 ``django.test.TestCase`` を提供しています。このクラスは、
Web サイトのテスト時に便利な機能をいくつか追加しています。

通常のユニットテストを ``unittest.TestCase`` から Django 独自の 
``TestCase`` に移行するのは簡単で、単にベースクラスを ``unittest.TestCase``
から ``django.test.TestCase`` に変更するだけです。 ``django.test.TestCase``
は、標準の Python ユニットテスト機能はそのままに、さらに便利な機能を提供し
ています。

.. _Default Test Client:

デフォルトのテストクライアント
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

**開発バージョンの Django で新たに追加されました**

``django.test.TestCase`` クラスのインスタンス内に入っているテストケースは全
て、デフォルトの `テストクライアント`_ にアクセスできます。このテストクライ
アントは ``self.client`` で参照できます。テストクライアントはテストごとに再
生成されるので、テスト間でクッキーのような状態情報が継承される心配はありま
せん。

例えば、以下のコード::

    import unittest
    from django.test.client import Client

    class SimpleTest(unittest.TestCase):
        def test_details(self):
            client = Client()
            response = client.get('/customer/details/')
            self.failUnlessEqual(response.status_code, 200)

        def test_index(self):
            client = Client()
            response = client.get('/customer/index/')
            self.failUnlessEqual(response.status_code, 200)

では、各テストで ``Client`` をインスタンス化していますが、実際は次のコード
のように、 ``self.client`` を参照するだけでよいのです::

    from django.test import TestCase

    class SimpleTest(TestCase):
        def test_details(self):
            response = self.client.get('/customer/details/')
            self.failUnlessEqual(response.status_code, 200)

        def test_index(self):
            response = self.client.get('/customer/index/')
            self.failUnlessEqual(response.status_code, 200)

.. _Fixture loading:

フィクスチャの読み込み
~~~~~~~~~~~~~~~~~~~~~~

データベースがバックにあるウェブサイトのテストで、データベース上に何もデー
タが入っていなければあまり意味はありません。データベースにテストデータを入
れやすくするために、 Django の独自 ``TestCase`` クラスは 
**フィクスチャ (fixture)** の読み込み機能を提供しています。

フィクスチャとは、一群のデータを Django がデータベースに取り込める形式にし
たものです。例えば、ユーザアカウントを持つようなサイトを作っている場合、テ
スト中は仮のユーザアカウントの入ったフィクスチャを作り、データベースに入れ
ておくと便利です。

最も素直なフィクスチャの作成方法は、 ``manage.py dumpdata`` コマンドを使う
というものです。 ``dumpdata`` を使うにはデータベースに既に何らかのデータが
入っていなければなりません。詳しくは `dumpdata のドキュメント`_ を参照して
ください。

データベースに入れるデータをシリアライズして
格納したファイル群を指します。各フィクスチャファイルには固有の名前を付けら
れますが、ある名前のフィクスチャを複数のディレクトリに入れても構いませんし、
複数のアプリケーション内に配置してもかまいません。

.. note::
    ``manage.py syncdb`` を実行したことがあるなら、あなたの知らないうちにフィ
    クスチャは使われています。最初に ``syncdb`` を実行したときに、 Django
    は ``initial_data`` という名前のフィクスチャをインストールします。この
    メカニズムを使えば、 (カテゴリのデフォルトセットのような) 新たなデータ
    セットをデータベースに組み込めます。 

    ``initial_data`` 以外の名前のフィクスチャは、 
    ``django-admin.py loaddata`` で手動で組み込めます。
    
単体テストでフィクスチャを使う場合、フィクスチャを作成して Django のプロジェ
クトディレクトリ下に置き、 ``dhango.test.TestCase`` のサブクラスの
``fixtures`` クラス属性を指定します::

    from django.test import TestCase
    from myapp.models import Animal

    class AnimalTestCase(TestCase):
        fixtures = ['mammals.json', 'birds']

        def setUp(self):
            # 従来通りのテスト定義

        def testFluffyAnimals(self):
            # フィクスチャを使うテスト


ユニットテストは、以下のように動作します:

  * テストケースの開始時で、かつ ``setUp()`` の実行前に、 Django はデータベー
    スを一掃して、データベースを ``syncdb`` 直後の状態に戻します。

  * 次に、テストケースクラスに指定した全てのフィクスチャをインストールしま
    す。上の例では、 ``mammals`` という名前の JSON フィクスチャと、
    ``birds`` という名前のフィクスチャがインストールされます。フィクスチャ
    の定義とインストールに関する詳細は `loaddata のドキュメント`_ を参照して
    ください。

このフラッシュ／ロードの作業はテストケースの実行毎に繰り返されるので、テス
トの結果が他のテストや以前に実行したテストの影響を受けたり、テストの順番に
左右されることはありません。

.. _dumpdata documentation: ../django-admin/#dumpdata-appname-appname
.. _loaddata documentation: ../django-admin/#loaddata-fixture-fixture
.. _`dumpdata のドキュメント`: `dumpdata documentation`_
.. _`loaddata のドキュメント`: `loaddata documentation`_

.. _Emptying the test outbox:

メール送信箱の内容抹消
~~~~~~~~~~~~~~~~~~~~~~

**開発バージョンの Django で新たに追加されました**

Django 独自の ``TestCase`` クラスを使うと、テストランナは各テストケースの開
始時にメールの送信箱に入っている内容を消去します。

テスト中のメールサービスの詳細は `メールサービス`_ を参照してください。

.. _Assertions:

アサーション
~~~~~~~~~~~~

**開発バージョンの Django で新たに追加されました**

通常の Python ``unittest.TestCase`` クラスが備えている ``assertTrue`` や
``assertEquals`` のようなアサーションメソッドと同様、 Django 独自の
``TestCase`` クラスでも Web アプリケーションをテストする上で便利な様々な
独自のアサーションメソッドを提供しています。

``assertContains(response, text, count=None, status_code=200)``
    ``status_code`` に指定した状態コードで ``Response`` インスタンスが生成
    され、レスポンスのコンテンツ内に ``text`` が入っているかどうか調べるア
    サーションです。 ``count`` を指定すると、 ``text`` は正確に ``count``
    回出現せねばなりません。

``assertFormError(response, form, field, errors)``
    ``form`` に指定したフォーム上のフィールド ``field`` で、 ``errors`` に
    指定したエラーリストと同じエラーが送出されるかどうか調べるアサーション
    です。

    ``form`` はテンプレートコンテキスト上の ``Form`` インスタンスの名前です。
    ``form`` を指定できるのは、フォームが ``oldforms.Form`` ではなく
    ``newforms.Form`` のインスタンスである場合だけです。

    ``field`` はフォーム内のフィールドの名前です。 ``field`` の値が
    ``None`` であれば、非フィールドエラー (特定のフィールドに関連付けられて
    いない、 ``form.non_field_errors()`` でアクセスできるエラー) がチェック
    されます。

    ``errors`` はエラー文字列か、エラー文字列のリストです。フォームの検証結
    果として返されるのと同じ形式です。

``assertRedirects(response, expected_url, status_code=302, target_status_code=200)``
    レスポンスが ``status_code`` に指定したリダイレクト状態コードを持ち、か
    つ ``expected_url`` へのリダイレクトを指示しており、さらにリダイレクト
    先の内容を HTTP 状態コード ``target_status_code`` で取得できるかどうか
    調べるアサーションです。

``assertTemplateNotUsed(response, template_name)``
    ``template_name`` に指定したテンプレートがレスポンスのレンダリングに使
    われて *いない* かどうか調べるアサーションです。

   ``template_name`` は ``'admin/index.html'`` のような文字列です。

``assertTemplateUsed(response, template_name)``
    ``template_name`` に指定したテンプレートがレスポンスのレンダリングに使
    われているか調べるアサーションです。

.. _E-mail services:

メールサービス
--------------
**開発バージョンの Django で新たに追加されました**

ビューが `Django のメールサービス`_ を使っている場合、ビューをテストするた
びにメールが送信されてほしくはないでしょう。 Django のテストランナは、テス
ト中に Django から送信されたすべてのメールをダミーの送信箱に振り分けます。
これによって、送信したメールの数から、各メールのメッセージに至るまで、メー
ル送信機能のすべてを (実際にメールを送らずに) テストできます。

Django は、テストフレームワークを初期化する際、通常の `SMTPConnection`_ ク
ラスをダミーの SMTPConnection 実装に切替えます (Django の外部のメール送信機
構、例えば Django を動かしているホストで動いているメールサーバには一切影響
を及ぼしません)。

テストの実行中、 Django から送信されたメールは ``djnago.core.mail.outbox``
に保存されます。 ``djnago.core.mail.outbox`` はその時点で送信された全ての
`EmailMessage`_ インスタンスからなるリストで、テスト時以外には存在しません。
このダミー送信箱は、テストのセットアップ時に、ダミーの `SMTPConnection`_ と
組で初期化されます。テストが終了すると、通常の `SMTPConnection`_ が復帰し、
ダミー送信箱は削除されます。

``django.core.mail.outbox`` を調べて、メール送信数やメールの内容をチェック
するコード例を以下に示します::

    from django.core import mail
    from django.test import TestCase

    class EmailTest(TestCase):
        def test_send_email(self):
            # Send message.
            mail.send_mail('Subject here', 'Here is the message.',
                'from@example.com', ['to@example.com'],
                fail_silently=False)

            # Test that one message has been sent.
            self.assertEqual(len(mail.outbox), 1)

            # Verify that the subject of the first message is correct.
            self.assertEqual(mail.outbox[0].subject, 'Subject here')


`前節で`_ 述べたように、テスト用の送信箱の内容は TestCase 内の各テストケー
スの開始時点で抹消されます。手動で送信箱の内容を空にしたければ、空のリスト
を ``mail.outbox`` に代入してください::

    from django.core import mail

    # Empty the test outbox
    mail.outbox = []

.. _`Django's e-mail functionality`: ../email/
.. _`SMTPConnection`: ../email/#the-emailmessage-and-smtpconnection-classes
.. _`EmailMessage`: ../email/#the-emailmessage-and-smtpconnection-classes
.. _`previously`: #emptying-the-test-outbox
.. _`Django のメールサービス`: `Django's e-mail functionality`_
.. _`前節で`: `previously`_

.. _Using a different testing framework:

他のテストフレームワークを使う
==============================

``doctest`` と ``unittest`` だけが Python のテストフレームワークではありま
せん。Django は他のテストフレームワークを明にサポートしているわけではありま
せんが、他のテストフレームワークで作成したテストを Django の通常のテストと
同じように呼び出すためのメカニズムは提供しています。

``./manage.py test`` を実行すると、 Django は ``TEST_RUNNER`` 設定を探して、
実行すべきテストランナを決定します。デフォルトでは、 ``TEST_RUNNER`` は
``django.test.simple.run_tests`` です。このメソッドは Django のデフォルトの
テスト動作を実装しており、以下のように動作します:

  #. テスト前の全体的な準備を行います。

  #. テストデータベースを生成します。

  #. ``syncdb`` を実行して、モデルと初期データをデータベースにインストールし
     ます。

  #. インストールされている全てのアプリケーションの ``models.py`` や
     ``tests.py`` から、単体テストと doctest を探します。

  #. 見つかった単体テストと doctest を実行します。

  #. テストデータベースを破壊します。

  #. テスト後の全体的な後始末を行います。

テストランナメソッドを自作して、そのメソッド名を ``TEST_RUNNER`` に指定して
おき、 ``./manage.py test`` を実行すると、 Django はそのテストランナメソッ
ドを実行します。これによって、 Python コードから任意のテストフレームワーク
を実行できます。

.. _Defining a test runner:

テストランナを定義する
----------------------

**開発バージョンの Django で新たに追加された機能です**

慣習的に、テストランナは ``run_tests`` と名付けます。テストランナは以下のよ
うに Django テストランナと同じ引数をとらねばなりません:

``run_tests(test_labels, verbosity=1, interactive=True, extra_tests=[])``

  ``test_labels`` には、実行したいテストを表す文字列 (ラベル) のリストを指
  定します。ラベルは以下の 3 つの形式で指定できます:

    * ``app.TestCase.test_method`` - テストケース中の個別のテストメソッドを
      実行します。
    * ``app.TestCase`` - テストケース中の全てのテストメソッドを実行します。
    * ``app`` - アプリケーション中の全てのテストを探して実行します。

  ``test_labels`` が ``None`` の場合、テストランナは ``INSTALLED_APPS`` に
  登録されている全てのアプリケーションからテストを探して実行します。

  ``verbosity`` には、コンソールに出力される通知情報やデバッグ情報の量を指
  定します。  ``0`` にすると何も出力しません。 ``1`` は通常の出力、 ``2``
  は多めの出力です。

  ``interactive`` を ``True`` にすると、テストスイートの実行時に、テストス
  イートからユーザに質問できるようになります。例えば、テストデータベースを削
  除してよいか尋ねるといった使い方です。 ``interactive`` を ``False`` にす
  る場合、テストスイートは手動操作なしで実行できねばなりません。
  
  ``extra_tests`` には、このテストランナに追加で実行させたい ``TestCase``
  インスタンスを指定します。 ``extra_tests`` を指定すると、 ``module_list``
  から発見したテストに加えて、指定したテストを実行します。
    
  このメソッドは失敗したテストの数を返さねばなりません。


.. _Testing utilities:

テスト用のユーティリティ
------------------------

``django.test.utils`` モジュールには、テストランナの自作に役立つユーティリ
ティメソッドが定義されています。

``setup_test_environment()``
    テンプレートレンダリングシステム構成のインストールなど、テスト前の全
    体的な準備を行い、ダミーの ``SMTPConnecton`` をセットアップします。

``teardown_test_environment()``
    テンプレートレンダリングシステムに組み込まれた黒魔術的なフックの除去な
    ど、テスト後の全体的な後始末を行い、メールサービスを通常の状態に復帰し
    ます。

``create_test_db(verbosity=1, autoclobber=False)``
    新たなテストデータベースを生成し、 ``syncdb`` を実行します。

    ``verbosity`` は ``run_tests()`` の同名の引数と同じ意味です。

    ``autoclobber`` には、テストデータベースと同名のデータベースが見つかっ
    た際の挙動を指定します:

        * ``autoclobber`` が ``False`` なら、既存のデータベースを破壊しても
          よいかユーザに尋ねます。ユーザが「いいえ」を選択すると、その時点
          で ``sys.exit`` を呼び出して終了します。

        * ``autoclobber`` が ``True`` なら、既存のデータベースを破壊すると
          きにユーザに了解を求めません。

    ``create_test_db()`` には ``settings.DATABASE_NAME`` を変更してテストデー
    タベースの名前にするという副作用があります。

    開発バージョンの Django では、この関数は生成されたテストデータベースの
    名前を返します。

``destroy_test_db(old_database_name, verbosity=1)``
    このメソッドを呼び出した時点で ``DATABASE_NAME`` に設定されているデータ
    ベースを破壊し、 ``DATABASE_NAME`` の値を ``old_database_name`` に指定
    したデータベース名に戻します。

    ``verbosity`` は ``run_tests()`` の同名の引数と同じ意味です。


