.. _topics-serialization:

=================================
Django オブジェクトのシリアライズ
=================================

:revision-up-to: 11321 (1.1) unfinished

Django のシリアライズフレームワークを使うと、 Django オブジェクトを他の形式
に「翻訳」できます。通常、こうした形式はテキストベースで、 Django オブジェ
クトをネットワーク越しに伝送するために使われますが、 Django のシリアライザ
は任意の形式 (テキストベースもそうでないものも) 扱えます。

.. seealso::

    If you just want to get some data from your tables into a serialized
    form, you could use the :djadmin:`dumpdata` management command.

データのシリアライズ
--------------------

高水準では、データのシリアライズは極めて簡単な操作です::

    from django.core import serializers
    data = serializers.serialize("xml", SomeModel.objects.all())

``serialize`` 関数の引数には、データのシリアライズに使うフォーマット
(`シリアライズの形式`_ 参照) と、シリアライズ対象の
:class:`~django.db.models.QuerySet` (実際には、第二引数は Django オブジェク
トを返す任意のイテレータにできますが、大抵の場合は QuerySet を使うことにな
るでしょう)。

シリアライザオブジェクトを直接使ってもかまいません::

    XMLSerializer = serializers.get_serializer("xml")
    xml_serializer = XMLSerializer()
    xml_serializer.serialize(queryset)
    data = xml_serializer.getvalue()
    
シリアライザオブジェクトを直接使うと、以下のようにファイルライクオブジェク
ト (もちろん :class:`~django.http.HttpResponse` も使えます) に対して直接シ
リアライズできるので便利です::

    out = open("file.xml", "w")
    xml_serializer.serialize(SomeModel.objects.all(), stream=out)

一部のフィールドだけをシリアライズする
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

一部のフィールドだけをシリアライズしたい場合には、シリアライザに ``fields``
引数を指定します::

    from django.core import serializers
    data = serializers.serialize('xml', SomeModel.objects.all(), fields=('name','size'))

上の例では、 ``name`` と ``size`` だけがシリアライズされます。

.. note::

    モデルによっては、フィールドの一部だけをシリアライズすると、そこからデ
    シリアライズできない場合があります。シリアライズ後のオブジェクトに、モ
    デル上で必須のフィールドがひとつでも抜け落ちていると、デシリアライザは
    デシリアライズ後のインスタンスを保存できないでしょう。

継承を行っているモデルインスタンスのシリアライズ
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

:ref:`抽象ベースクラス <abstract-base-classes>` を使って定義したモデルを扱っ
ていても、モデルのシリアライズのために特に行うことはありません。単にシリア
ライズしたオブジェクトに対してシリアライザを呼び出せば、完全なシリアライズ
済みオブジェクトが出力されます。

ただし、 :ref:`マルチテーブル継承 <multi-table-inheritance>` を使って定義さ
れているモデルを扱う場合、モデルの全てのベースクラスをシリアライズする必要
があります。これは、モデルごとに固有に定義されたフィールドがシリアライズさ
れるためです。例えば、以下のようなモデルを考えましょう::
	
    class Place(models.Model):
        name = models.CharField(max_length=50)

    class Restaurant(Place):
        serves_hot_dogs = models.BooleanField()

ここで、 ``Restaurant`` モデルだけをシリアライズしたとします::

    data = serializers.serialize('xml', Restaurant.objects.all())

シリアライズ後の出力には、 ``serves_hot_dogs`` という属性しか入りません。
ベースクラスの ``name`` 属性は無視されるのです。

上の ``Restaurant`` インスタンスを完全にシリアライズするには、以下のように
して ``Place`` モデルもシリアライズする必要があります::

    all_objects = list(Restaurant.objects.all()) + list(Place.objects.all())
    data = serializers.serialize('xml', all_objects)

データのデシリアライズ
----------------------

データのデシリアライズもまた、かなり単純な操作です::

    for obj in serializers.deserialize("xml", data):
        do_something_with(obj)

見ての通り、 ``deserialize`` 関数は ``serialize`` 関数と同様、文字列または
データストリームを引数にとり、イテレータを返します。

しかしながら、少しだけややこしい部分もあります。 ``deserialize`` イテレータ
の返すオブジェクトは単純な Django オブジェクト *ではなく* 、
``DeserializedObject`` という特殊なインスタンスです。このインスタンスは
作成されただけでまだ保存されていないデータであり、リレーションも張られてい
ません。

``DeserializedObject.save()`` を呼び出すと、データベースにオブジェクトを保
存します。

上のような仕様から、デシリアライズは、たとえシリアライズされていたデータの
表現形式が現在のデータベースの構成と一致していなかったとしても非破壊的な操
作になるよう保証されています。通常、 ``DeserializedObject`` インスタンスの
操作は以下のように行います::

    for deserialized_object in serializers.deserialize("xml", data):
        if object_should_be_saved(deserialized_object):
            deserialized_object.save()
            
すなわち、デシリアライズしたオブジェクトを保存する場合、前もって保存に適し
ているかどうかを調べるのが普通のやり方なのです。もちろん、データソースを信
頼できるのなら、単にデータを保存してもかまいません。

Django オブジェクト自体に対するインスペクションは、
``deserialized_object.object`` で行えます。

.. _serialization-formats:

シリアライズの形式
------------------

Django supports a number of serialization formats, some of which require you
to install third-party Python modules:

    ==========  ==============================================================
    名前        情報
    ==========  ==============================================================
    ``xml``     単純な XML シリアライザです。

    ``json``    JSON_ シリアライザ (Django に付属の simplejson_ を使ったも
                の) です。 

    ``python``  「単純な」Python オブジェクト (リスト、辞書、文字列など) の
                シリアライザです。単体では取り立てて便利ではありませんが、
                他のシリアライザのベースになっています。

    ``yaml``    YAML (YAML Ain't a Markup Language) へのシリアライザです。
                このシリアライザは PyYAML_ がインストールされている場合のみ
                利用できます。
    ==========  ==============================================================

.. _json: http://json.org/
.. _simplejson: http://undefined.org/python/#simplejson
.. _PyYAML: http://www.pyyaml.org/
 
各シリアライズ形式についての注意
--------------------------------

json
~~~~

UTF-8 (や、非 ASCII エンコーディング) でエンコードされたデータを JSON シリ
アライザで扱うには、 ``serialize()`` のパラメタに ``ensure_ascii=False`` を
指定してください。さもないと、出力のエンコードがおかしくなってしまいます。

例::

    json_serializer = serializers.get_serializer("json")()
    json_serializer.serialize(queryset, ensure_ascii=False, stream=response)

Django のソースコードには simplejson_ モジュールが付属しています。
However, if you're
using Python 2.6 (which includes a builtin version of the module), Django will
use the builtin ``json`` module automatically. If you have a system installed
version that includes the C-based speedup extension, or your system version is
more recent than the version shipped with Django (currently, 2.0.7), the
system version will be used instead of the version included with Django.

注意してほしいのは、このモジュールを直接使ってシリアライズを実行すると、一
部のDjango オブジェクトは何らかの変更が加えられた上で simplejson に渡されて
しまうということです。特に、 :ref:`遅延翻訳オブジェクト
<lazy-translations>` をシリアライズする場合は、 `特殊なエンコーダ`_ が必要
です。以下のように書くと、うまくいくでしょう::

    from django.utils.functional import Promise
    from django.utils.encoding import force_unicode

    class LazyEncoder(simplejson.JSONEncoder):
        def default(self, obj):
            if isinstance(obj, Promise):
                return force_unicode(obj)
            return obj

.. _simplejson: http://undefined.org/python/#simplejson
.. _special encoder: http://svn.red-bean.com/bob/simplejson/tags/simplejson-1.7/docs/index.html
.. _`特殊なエンコーダ`: `special encoder`_
