========================
ファイルアップロード
========================

:revision-up-to: 8001 (1.0pre SVN)

**開発版の Django で新たに追加された機能です**

多くの Web サイトにとって、ファイルアップロードのサポートは不可欠ですね。
Django がアップロードされたファイルを扱うとき、ファイルデータは最終的に
``request.FILES`` に入ります (``request`` オブジェクトの詳細は
`リクエストオブジェクトとレスポンスオブジェクト`_ のドキュメントを参照して
ください)。このドキュメントでは、ファイルがどのようにしてディスクやメモリ上
に保存されるかを説明し、そのデフォルトの動作をカスタマイズする方法について
説明します。

.. _request and response objects: ../request_response/#attributes
.. _`リクエストオブジェクトとレスポンスオブジェクト`: `request and response objects`_

.. _Basic file uploads:

ファイルアップロードの基本
============================

``FileField`` を含む以下のような簡単なフォームを考えてみましょう::

    from django import newforms as forms

    class UploadFileForm(forms.Form):
        title = forms.CharField(max_length=50)
        file  = forms.FileField()

このフォームからの入力を扱うビューは、ファイルデータを ``request.FILES`` で
受け取ります。 ``request.FILES`` はファイルデータの入った辞書で、辞書のキー
はフォームクラス中の ``FileField`` (または ``ImageField`` や ``FileField``
のサブクラス) の名前です。従って、上の例では、 ``request.FILES['file']`` で
ファイルデータにアクセスできます。

ほとんどの場合は、「 `アップロードファイルデータをフォームに結びつける`_ 」
の節で説明した方法に従って、 ``request`` からデータを取り出してフォームに渡
すだけでアップロードファイルを処理できます::

    from django.http import HttpResponseRedirect
    from django.shortcuts import render_to_response

    # アップロードファイルを処理する関数を import します
    from somewhere import handle_uploaded_file

    def upload_file(request):
        if request.method == 'POST':
            form = UploadFileForm(request.POST, request.FILES)
            if form.is_valid():
                handle_uploaded_file(request.FILES['file'])
                return HttpResponseRedirect('/success/url/')
        else:
            form = UploadFileForm()
        return render_to_response('upload.html', {'form': form})

.. _binding uploaded files to a form: ../newforms/#binding-uploaded-files-to-a- form
.. _`アップロードファイルデータをフォームに結びつける`: `binding uploaded files to a form`_

``request.FILES`` を明示的にフォームのコンストラクタに渡さねばならないので
注意してください。これはフォームにファイルデータを結びつけるために必要な手
順です。

.. _Handling uploaded files:

アップロードファイルの処理
----------------------------

ファイルアップロードというパズルの最後のピースは、 ``request.FILES`` の
ファイルデータを実際に処理する部分です。 ``request.FILES`` の各エントリは
``UploadedFile`` オブジェクトです。 ``UploadedFile`` は単純なアップロードファ
イルデータのラッパです。このインスタンスには、以下のようなメソッドがあり、
アップロードされたデータにアクセスできます:

    ``UploadedFile.read()``
        アップロードされたデータ全体をファイルから読み出します。このメソッ
        ドを使うときに十分注意してください。というのも、アップロードされた
        ファイルが巨大だと、メモリに読み込む際にシステムの容量を越してしま
        うかもしれないからです。そのようなときは、後述の ``chunks()`` を使う
        とよいでしょう。
        
    ``UploadedFile.multiple_chunks()``
        ファイルが大きくて、複数のチャンクに分けて読み出すべきである場合に
        ``True`` を返します。デフォルトの設定では、 2.5 Mbtes より大きなファ
        イルに対して ``True`` を返します。サイズの閾値は設定でき、後で説明
        します。
    
    ``UploadedFile.chunk()``
        ファイルのチャンクを返すジェネレータです。 ``multiple_chunks()`` が
	``True`` の場合には、 ``read()`` ではなくこのメソッドを使ってくださ
        い。
        
	実際には、常に ``chunks()`` を使うのがよいでしょう。後述の例を参照
	してください。
    
    ``UploadedFile.file_name``
        ``my_file.txt`` のような、アップロードされたファイルの名前です。
        
    ``UploadedFile.file_size``
        アップロードファイルのサイズ(単位バイト)です。
        
``UploadedFile`` オブジェクトは他にもいくつかメソッドや属性を備えています。
詳しくは `UploadedFile オブジェクト`_ を参照してください。

まとめると、アップロードファイルの一般的な処理例は以下の通りです::
    
    def handle_uploaded_file(f):
        destination = open('some/file/name.txt', 'wb+')
        for chunk in f.chunks():
            destination.write(chunk)

上の例では、巨大なファイルを ``read()`` してシステムの容量を超えないように、
``UploadedFile.chunks()`` を使っています。

.. _Where uploaded data is stored:

アップロードされたファイルの保存先
----------------------------------------

アップロードされたファイルデータは、処理され保存される前に、システムのどこ
かに一時的に記憶されていなければなりません。

デフォルトの設定では、アップロードされたファイルデータが 2.5 Mbytes より小
さければ、 Django はファイルデータ全体をメモリに保持します。そのため、ファ
イルデータの保存処理はメモリからディスクへの書き込みだけで実現され、高速で
す。

しかし、ファイルデータが大きすぎる場合、 Django はファイルデータをシステム
のテンポラリディレクトリに一時ファイルとして保存します。従って、 *nix ライ
クのプラットフォームでは、 Django は ``/tmp/tmpzfp6I6.upload`` のような
ファイルを生成します。ファイルデータがとても大きければ、 Django がデータを
ディスクにストリーム書き込みするにつれて、一時ファイルのサイズが増えてゆく
のを観察できるでしょう。

2.5 Mbytes や ``/tmp`` といった仕様は、単に「妥当なデフォルト値」にすぎませ
ん。アップロード時の挙動をカスタマイズしたり完全に置き換えたりしたければ、
この後の詳細説明に進んでください。

.. _Changing upload handler behavior:

アップロードファイルハンドラの挙動を変更する
----------------------------------------------

ファイルアップロードの挙動は、以下の 3 つの `設定`_ で制御できます:

    ``FILE_UPLOAD_MAX_MEMORY_SIZE``
        アップロードされたファイルをメモリに保存する上限のサイズです。
	設定値よりも大きなファイルがアップロードされると、ファイルデータは
        ディスクに書き込まれます。
        
        デフォルト値は 2.5 Mbytes です。
        
    ``FILE_UPLOAD_TEMP_DIR``
        ``FILE_UPLOAD_MAX_MEMORY_SIZE`` より大きなファイルがアップロードさ
        れたときにファイルデータを保存するディレクトリです。
        
        デフォルト値はシステム標準の一時ファイルディレクトリです
	(UNIX ライクのシステムでは ``/tmp`` です)。
        
    ``FILE_UPLOAD_HANDLERS``
        アップロードファイルを処理する実際のハンドラです。
        この設定を変更すると、ファイルアップロードの処理を完全にカスタマイ
        ズでき、 Django のアップロード処理全体の置き換えすらできます。
	詳しくは後述の `アップロードハンドラ`_ を参照してください。
        
        デフォルト値は以下の通りです::
        
            ("django.core.files.uploadhandler.MemoryFileUploadHandler",
             "django.core.files.uploadhandler.TemporaryFileUploadHandler",)
            
        このデフォルトの設定では、アップロードされたファイルをまずメモリに
        保存しようと試み、その後ファイルへの保存を試みます。

.. _settings: ../settings/

.. _UploadedFile objects:

``UploadedFile`` オブジェクト
=================================

``UploadedFile`` オブジェクトは、以下のメソッドや属性を定義しています。

    ``UploadedFile.read(self, num_bytes=None)``
        ファイル中から最大 ``num_bytes`` バイトの文字列を返します。
	``num_bytes`` が ``None`` ならファイル全体を返します。

    ``UploadedFile.chunks(self, chunk_size=None)``
        ファイルからチャンクをとりだすジェネレータです。 ``chunk_size``
	を指定しない場合のチャンクサイズは 64kb です。

    ``UploadedFile.multiple_chunks(self, chunk_size=None)``
        ``UploadedFile.chunks(self, chunk_size)`` が複数のチャンクを返すよう
        な場合に ``True`` を返します。

    ``UploadedFile.file_size``
        アップロードされたファイルのサイズをバイトで表したものです。
    
    ``UploadedFile.file_name``
        ファイルのアップロード時にユーザが指定したファイル名です。
    
    ``UploadedFile.content_type``
        ``content-type`` ヘッダの内容 (``text/plain`` や
        ``application/pdf`` など) です。ユーザが指定した他のデータ同様、こ
        の値がアップロードされたファイルのコンテンツタイプを正確に表してい
        ると信用してはなりません。アップロードされたファイルのコンテンツタ
        イプが ``content-type`` ヘッダと一致しているか確かめておく必要があ
        ります。「値は一応信用するが、検証し」てください。
    
    ``UploadedFile.charset``
        ``content-type`` が ``text/*`` のときに、ブラウザが指定した文字セッ
        ト (``utf8`` など) です。「値は一応信用するが、検証する」ようにして
        ください。

    ``UploadedFile.__iter__()``
        ファイル中の各行を取り出すイテレータです。

    ``UploadedFile.temporary_file_path()``
        アップロードファイルがディスクに一時保存されているときにのみ使える
        メソッドで、一時ファイルの完全なパスを返します。

.. _Upload Handlers:

アップロードハンドラ
=====================

ユーザがファイルをアップロードすると、 Django はファイルデータを 
*アップロードハンドラ (upload handler)* と呼ばれるクラスに渡します。このク
ラスはアップロードされたファイルデータを処理するためのクラスです。
デフォルトのアップロードハンドラは ``FILE_UPLOAD_HANDLERS`` で以下のように
定義されています::

    ("django.core.files.uploadhandler.MemoryFileUploadHandler",
     "django.core.files.uploadhandler.TemporaryFileUploadHandler",)

``MemoryFileUploadHandler`` と ``TemporaryFileUploadHandler`` は、Django の
デフォルトのファイルアップロード処理、すなわち、小さいファイルはメモリに読
み込み、大きいファイルはディスクに読み込むという動作を実現します。

カスタムのハンドラを書けば、ファイルの処理方法をカスタマイズできます。例え
ば、カスタムハンドラによってユーザレベルで容量制限を課したり、データをオン
ザフライで圧縮したり、プログレスバーを描画したり、受け取ったデータをローカ
ルに保存せず、直接別のストレージに送ったりできます。

.. _Modifying upload handlers on the fly:

アップロードハンドラをオンザフライで変更する
----------------------------------------------

Sometimes particular views require different upload behavior. In these cases,
you can override upload handlers on a per-request basis by modifying
``request.upload_handlers``. By default, this list will contain the upload
handlers given by ``FILE_UPLOAD_HANDLERS``, but you can modify the list as you
would any other list.

For instance, suppose you've written a ``ProgressBarUploadHandler`` that
provides feedback on upload progress to some sort of AJAX widget. You'd add this
handler to your upload handers like this::

    request.upload_handlers.insert(0, ProgressBarUploadHandler())

You'd probably want to use ``list.insert()`` in this case (instead of
``append()``) because a progress bar handler would need to run *before* any
other handlers. Remember, the upload handlers are processed in order.

If you want to replace the upload handlers completely, you can just assign a new
list::

   request.upload_handlers = [ProgressBarUploadHandler()]

.. note::

    You can only modify upload handlers *before* accessing ``request.FILES`` --
    it doesn't make sense to change upload handlers after upload handling has
    already started. If you try to modify ``request.upload_handlers`` after
    reading from ``request.FILES`` Django will throw an error.

    Thus, you should always modify uploading handlers as early in your view as
    possible.

.. _Writing custom upload handlers:

カスタムのアップロードハンドラを書く
---------------------------------------

All file upload handlers should be subclasses of
``django.core.files.uploadhandler.FileUploadHandler``. You can define upload
handlers wherever you wish.

.. _Required methods:

必須のメソッド
~~~~~~~~~~~~~~~~

カスタムのファイルアップロードハンドラは以下のメソッドを **必ず**
定義せねばなりません:

    ``FileUploadHandler.receive_data_chunk(self, raw_data, start)``
        ファイルアップロード時に、データの「チャンク」を受け取ったときに呼
        び出されます。

        ``raw_data`` はアップロードされたデータの入ったバイト文字列です。

        ``start`` は ``raw_data`` チャンクのファイルデータ中の開始位置です。

	このメソッドが返すデータは、次のアップロードハンドラの
	``receive_data_chunk`` メソッドにフィードされます。この仕組みによっ
	て、あるハンドラにデータを「フィルタ」させ、他のハンドラに入力でき
	ます。

        ``receive_data_chunk`` で受け取ったデータを後続のハンドラに処理させ
	たくない場合には ``None`` を返してください。このメソッドは、アップ
	ロードされたデータを自分で処理して、他のハンドラにデータを保存させ
	たくない場合に便利です。

        ``StopUpload`` や ``SkipFile`` といった例外を送出すると、アップロー
        ド処理は中断し、アップロードファイルの処理を行いません。

    ``FileUploadHandler.file_complete(self, file_size)``
        ファイルのアップロードが終了したときに呼び出されます。

        このハンドラは ``request.FILES`` に入れるための ``UploadedFile`` オ
        ブジェクトを返さねばなりません。後続のアップロードハンドラに
        ``UploadedFile`` を返させたい場合は ``None`` を返してください。

.. _Optional methods:

オプションのメソッド
~~~~~~~~~~~~~~~~~~~~~~

カスタムのアップロードハンドラでは、以下のオプションのメソッドや属性を定義
できます:

    ``FileUploadHandler.chunk_size``
        Django がアップロードファイルをメモリ上に読み込み、ハンドラに渡すと
        きに使うチャンクのサイズです。バイト単位です。この属性は、
	``FileUploadHandler.receive_data_chunk`` で読み込まれるチャンクのサ
        イズ指定でもあります。

	パフォーマンスを最大化するには、チャンクのサイズを ``4`` の倍数とし、
	2GB (2\ :sup:`31` バイト) 以下とすべきです。複数のハンドラがそれぞ
	れ別々のチャンクサイズを提供していた場合、 Django は最小のチャンク
	サイズを使います。

        デフォルト値は 64*2\ :sup:`10` バイトまたは 64 KB です。

    ``FileUploadHandler.new_file(self, field_name, file_name, content_type, content_length, charset)``
        新たなファイルアップロードが開始されるときに呼び出されるコールバッ
        クです。このメソッドは、アップロードハンドラがまだデータを受け取っ
        ていない段階で呼び出されます。

        ``field_name`` はファイルの ``<input>`` フィールドの名前です。

        ``file_name`` は unicode のファイル名としてブラウザから提供された値
        です。

        ``content_type`` は ``'image/jpeg'`` のような MIME タイプで、ブラウ
	ザから提供された値です。

        ``content_length`` はファイルの長さで、ブラウザから提供された値です。
	ブラウザがファイルサイズを提供しないこともあり、その場合は ``None``
	です。

        ``charset`` は (``utf8`` のような) 文字セットで、ブラウザから提供さ
        れた値です。 ``content_length`` と同様、指定されないこともあります。

	他のハンドラにファイルを処理させたくない場合、このメソッドから
	``StopFutureHandlers`` 例外を送出してもかまいません。

    ``FileUploadHandler.upload_complete(self)``
        ファイル全体のアップロードが終了したときに呼び出されるコールバック
        です。

    ``FileUploadHandler.handle_raw_input(self, input_data, META, content_length, boundary, encoding)``
        このメソッドを使うと、生の HTTP 入力の解析を完全にオーバライドでき
        ます。

        ``input_data`` は ``read()`` をサポートするファイルライクオブジェク
        トです。

        ``META`` は ``request.META`` と同じです。

        ``content_length`` は ``input_data`` に入っているデータの長さです。
	``input_data`` から ``content_length`` バイト以上を読み出そうとして
	はなりません。

        ``boundary`` はリクエストの MIME バウンダリです。

        ``encoding`` はリクエストのエンコーディングです。

        アップロードの処理を他のハンドラに継続させたい場合には ``None`` を、
	リクエストの直接処理に適したデータ構造を新たに生成して返したければ
	``(POST, FILES)`` のタプルを返してください。
