==============================================
リクエストオブジェクトとレスポンスオブジェクト
==============================================

:revision-up-to: 3918 (0.96-pre SVN)

.. _`Quick overview`:

簡単な概要
==========

Django はシステム全体に渡り，リクエストとレスポンスオブジェクトを使って処理
状態を受け渡します．

あるページへのリクエストを受け取ると，Django は ``HttpRequest`` オブジェク
トを生成します．このオブジェクトにはリクエストのメタデータが入っています．
次に Django は適切なビューをロードして， ``HttpRequest`` をビュー関数の最初
の引数に渡します．各ビューは ``HttpResponse`` オブジェクトを返さねばなりま
せん．

このドキュメントでは  ``HttpRequest`` および ``HttpResponse`` オブジェクト
の API について説明します．

.. _HttpRequest objects:

HttpRequest オブジェクト
========================

属性
----

``session`` 以外の属性は全て読み出し専用です．

``path``
    リクエストしているページのフルパスを表す，ドメインを含まない文字列です．

    例: ``"/music/bands/the_beatles/"``

``method``
    リクエストに使われた HTTP メソッドを表す文字列です．必ず大文字になります．
    例::

        if request.method == 'GET':
            do_something()
        elif request.method == 'POST':
            do_something_else()


``GET``
    全ての HTTP GET パラメタが入った辞書ライクなオブジェクトです．後述の
    ``QueryDict`` も参照してください．

``POST``
    全ての HTTP POST パラメタが入った辞書ライクなオブジェクトです．後述の
    ``QueryDict`` も参照してください．

    フォームを POST HTTP メソッドで要求し，その際に何らフォームデータを伴わ
    ないような場合には，リクエストが POST で送られていながらも ``POST`` 辞
    書が空になることがあります．従って，リクエストが POST メソッドであるか
    どうかを調べるために ``if request.POST`` を使うべきではありません．代わ
    りに ``if request.method == "POST"`` を使ってください (上参照)．

    ``POST`` にはファイルアップロードに関する情報は *入っていない* ので注意
    してください． ``FILES`` を参照してください．

``REQUEST``
    便宜的な辞書オブジェクトで， ``POST`` パラメタをまず検索してから，次に
    ``GET`` パラメタを検索します． PHP の ``$_REQUEST`` にインスパイアされ
    た機能です．

    例えば， ``GET = {"name": "john"}`` で ``POST = {"age": '34'}`` の場合，
    ``REQUEST["name"]`` は ``"john"`` になり， ``REQUEST["age"]`` は
    ``"34"`` になります．

    通常は ``GET`` および ``POST`` を使うように強く勧めます．その方が明示的
    だからです．

``COOKIES``
    全てのクッキーが入った標準の Python 辞書オブジェクトです．キーと値は文
    字列です．

``FILES``
    アップロードされたファイル全てが入っている辞書ライクオブジェクトです．
    ``FILES`` の各キーは ``<input type="file" name="" />`` の ``name`` 
    です． ``FILES`` の各値は標準の Python 辞書オブジェクトで，以下の 3 つ
    のキーを持っています:

        * ``filename`` -- アップロードされたファイルの名前を Python 文字列
          で表したものです．
        * ``content-type`` -- アップロードされたファイルのコンテンツ形式で
          す．
        * ``content`` -- アップロードされたファイルの内容そのものです．

    ``FILES`` にデータが入るのは，リクエストが ``POST`` であり，かつリクエ
    ストをポストした ``<form>`` に ``enctype="multipart/form-data`` がある
    場合だけです．それ以外の場合， ``FILES`` は空の辞書ライクオブジェクトに
    なります．

``META``
    標準の Python 辞書オブジェクトで，利用できる全ての HTTP ヘッダが入って
    います．利用可能なヘッダはクライアントとサーバごとに違いますが，例えば
    以下のようなヘッダを利用できます:

        * ``CONTENT_LENGTH``
        * ``CONTENT_TYPE``
        * ``HTTP_ACCEPT_ENCODING``
        * ``HTTP_ACCEPT_LANGUAGE``
        * ``HTTP_REFERER`` -- リクエスト対象のページを参照しているページが
          ある場合，そのページの URL です．
        * ``HTTP_USER_AGENT`` -- クライアントのユーザエージェントを表す文字
          列です．
        * ``QUERY_STRING`` -- パース前の単一のクエリ文字列です．
        * ``REMOTE_ADDR`` -- クライアントの IP アドレスです．
        * ``REMOTE_HOST`` -- クライアントのホスト名です．
        * ``REQUEST_METHOD`` -- ``"GET"`` や ``"POST"`` のような文字列です．
        * ``SERVER_NAME`` -- サーバのホスト名です．
        * ``SERVER_PORT`` -- サーバのポート番号です．

``user``
    現在ログインしているユーザを表す ``django.models.auth.models.User`` オブ
    ジェクトです．ユーザが現在ログインしていない場合には， ``user`` は 
    ``django.contrib.auth.models.AnonymousUser`` のインスタンスになります．
    ``is_authenticated()`` を使うと，これら二種類のユーザを区別できます::

        if request.user.is_authenticated():
            # Do something for logged-in users.
        else:
            # Do something for anonymous users.

    ``user`` を利用できるのは， インストールした Django で
    ``AuthenticationMiddleware`` を有効にした場合だけです．詳しくは
    `Web リクエストの認証`_ を参照してください．

    .. _`Web リクエストの認証`: authentication.html#authentication-in-web-requests

``session``
    読み書き可能な辞書ライクオブジェクトで，現在のセッションを表現しています．
    この辞書はインストールされている Django でセッションが有効な場合にのみ
    利用できます．詳しくは `セッションのドキュメント`_ を参照してください．

    .. _`セッションのドキュメント`: sessions.html
    .. _`session documentation`: http://www.djangoproject.com/documentation/sessions/

``raw_post_data``
    HTTP POST データそのものです．高度な処理を行いたいときに便利です．普段
    は ``POST`` を使ってください．

メソッド
--------

``__getitem__(key)``
    キーに対する GET/POST 値を返します． POST をまず調べ，次に GET を調べま
    す．キーが存在しなければ  ``KeyError`` を送出します．

    このメソッドによって， ``HttpRequest`` インスタンスを辞書のように扱えま
    す．例えば， ``request.POST`` または ``request.GET`` に ``"foo"`` とい
    うキーがあれば， ```request["foo"]`` は ``True`` を返します．

``has_key()``
    ``request.GET`` または ``request.POST`` に指定の値が入っているかどうか
    によって ``True`` または ``False`` を返します．

``get_full_path()``
    ``path`` と，そのあとに続くクエリ文字列があれば返します．

    例: ``"/music/bands/the_beatles/?print=true"``

``is_secure()``
    リクエストがセキュアである，すなわち HTTPS を介したリクエストのときに
    ``True`` を返します．

.. _QueryDict objects:

QueryDict オブジェクト
----------------------

``HttpRequest`` オブジェクト内では， ``GET`` と ``POST`` 属性は
``django.http.QueryDict`` のインスタンスです． ``QueryDict`` は辞書ライクな
クラスで，同じキーに対して複数の値を取り得るようにカスタマイズされています．
これは， HTML のフォーム要素には，例えば ``<select multiple="multiple">``
のように，同じキーに対して複数の値を渡すものがあるからです．

``QueryDict`` インスタンスは， ``copy()`` を作らないかぎり変更できません．
これは， ``request.POST`` や ``request.GET`` の属性を直接変更できないと
いうことです．

``QueryDict`` は辞書型のサブクラスなので，全ての標準的な辞書型のメソッドを
実装しています．ただし，以下の点が異なります:

    * ``__getitem__(key)`` -- 指定のキーに対する値を返します．一つのキーに
      複数の値が存在する場合， ``__getitem__()`` はリストの末尾の値を返しま
      す．

    * ``__setitem__(key, value)`` -- 指定のキーに対する値を ``[value]`` 
      (``value`` という値が一つだけ入ったリスト) にします．副作用をともなう
      他の関数と同じく，このメソッドを呼び出せるのは (``copy()`` を使って生
      成したオブジェクトのような) 変更可能な ``QueryDict`` だけです．

    * ``__contains__(key)`` -- 指定のキーが設定されている場合に ``True`` を
      返します．これにより， ``if "foo" in request.GET`` のように書けます．

    * ``get(key, default)`` -- 上の ``__getitem__()`` と同じロジックですが，
      キーに対応する値がないときにデフォルト値を返すフックがあります．

    * ``has_key(key)``

    * ``setdefault(key, default)`` -- 標準の辞書型の ``setdefault()`` と同
      じですが，内部的に ``__setitem__`` を使います．

    * ``update(other_dict)`` -- ``QueryDict`` または標準の辞書型を引数にと
      ります．標準の辞書型の ``update()`` メソッドと同じですが，現在の値を
      置き換えるのではなく，現在の値のリストに *追加* します．例えば::

          >>> q = QueryDict('a=1')
          >>> q = q.copy() # to make it mutable
          >>> q.update({'a': '2'})
          >>> q.getlist('a')
          ['1', '2']
          >>> q['a'] # returns the last
          ['2']

    * ``items()`` -- 標準の辞書型の ``items()`` メソッドと同じですが，
      ``__getitem()__`` と同じ，最後の値を返すロジックを使います．例えば::

           >>> q = QueryDict('a=1&a=2&a=3')
           >>> q.items()
           [('a', '3')]

    * ``values()`` -- 標準の辞書型の ``values()`` メソッドと同じですが，
      ``__getitem()__`` と同じ，最後の値を返すロジックを使います．例えば::

           >>> q = QueryDict('a=1&a=2&a=3')
           >>> q.values()
           ['3']

加えて， ``QueryDict`` には以下のメソッドがあります:

    * ``copy()`` -- Python 標準ライブラリの ``copy.deepcopy()`` を使って
      オブジェクトのコピーを生成して返します．コピーは変更可能になり，
      値を変更できます．

    * ``getlist(key)`` -- 要求されたキーに対して， Python のリスト型を返し
      ます．キーに対応する値がなければ空のリストを返します．このメソッドは
      確実に何らかのリストを返します．

    * ``setlist(key, list_)`` -- キーに対して ``list_`` を対応づけます 
      (``__setitem__()`` と違うところです)．

    * ``appendlist(key, item)`` -- キーに関連づけられている内部的なリストに
      要素を追加します．

    * ``setlistdefault(key, default_list)`` -- ``setdefault`` に似ています
      が，単一の値ではなく値のリストを引数にとります．

    * ``lists()`` -- ``items()`` に似ていますが，全ての値をリストで返しま
      す．例えば::

           >>> q = QueryDict('a=1&a=2&a=3')
           >>> q.lists()
           [('a', ['1', '2', '3'])]

    * ``urlencode()`` -- データをクエリ文字列形式にフォーマットした文字列を
      返します．例えば: ``"a=2&b=3&b=5"`` のようになります．

使用例
------

HTML フォームの例と，それに対して Django がどのように入力を扱うかを例で説明
しましょう::

    <form action="/foo/bar/" method="post">
    <input type="text" name="your_name" />
    <select multiple="multiple" name="bands">
        <option value="beatles">The Beatles</option>
        <option value="who">The Who</option>
        <option value="zombies">The Zombies</option>
    </select>
    <input type="submit" />
    </form>

ユーザが ``your name`` フィールドに ``"John Smith"`` を指定し，複数選択ボッ
クスで "The Beatles" と "The Zombies" にチェックを入れたとします． Django
のリクエストオブジェクトは以下のようになります::

    >>> request.GET
    {}
    >>> request.POST
    {'your_name': ['John Smith'], 'bands': ['beatles', 'zombies']}
    >>> request.POST['your_name']
    'John Smith'
    >>> request.POST['bands']
    'zombies'
    >>> request.POST.getlist('bands')
    ['beatles', 'zombies']
    >>> request.POST.get('your_name', 'Adrian')
    'John Smith'
    >>> request.POST.get('nonexistent_field', 'Nowhere Man')
    'Nowhere Man'

実装上に関する注意
------------------

``GET``, ``POST``, ``COOKIES``, ``FILES``, ``META``, ``REQUEST``,
``raw_post_data`` および ``user`` といった属性はすべて遅延読み込み (lazily
load) されます．すなわち， Django はコード中で要求されるまで，これらの値を
計算するためにリソースを消費しません．

.. _HttpResponse objects:

HttpResponse オブジェクト
=========================

Django によって自動生成される ``HttpRequest`` オブジェクトとは対象的に，
``HttpResponse`` オブジェクトは自分で生成せねばなりません．ビューを書くとき
にはいつでも， ``HttpResponse`` インスタンスを生成して，値を設定し，戻り値
として返さねばなりません．


``HttpResponse`` クラスの定義は ``django.http.HttpResponse``
にあります．

使いかた
--------


文字列を渡す
~~~~~~~~~~~~

``HttpResponse`` の典型的な使い方は，ページの内容を文字列としてコンストラク
タに渡すというものです::

    >>> response = HttpResponse("Here's the text of the Web page.")
    >>> response = HttpResponse("Text only, please.", mimetype="text/plain")


コンテンツを累積的に追加していきたい場合には， ``response`` をファイルライ
クオブジェクトのようにも使えます::

    >>> response = HttpResponse()
    >>> response.write("<p>Here's the text of the Web page.</p>")
    >>> response.write("<p>Here's another paragraph.</p>")

ヘッダの追加や削除は辞書とおなじ書法で書けます::

    >>> response = HttpResponse()
    >>> response['X-DJANGO'] = "It's the best."
    >>> del response['X-PHP']
    >>> response['X-DJANGO']
    "It's the best."

該当するヘッダがなくても， ``del`` は ``KeyError`` を送出しないので気をつけ
てください．

イテレータを渡す
~~~~~~~~~~~~~~~~

最後に，ハードコードされた文字列ではなくイテレータも ``HttpResponse`` に渡
せます．このテクニックを使う場合は以下のガイドラインに従って下さい:

    * イテレータは文字列を返さねばなりません．
    * イテレータをコンテンツに指定して ``HttpResponse`` を初期化すると，
      ``HttpResponse`` インスタンスをファイルライクオブジェクトとして扱えな
      くなり， ``Exception`` を送出するようになります．

メソッド
--------

``__init__(content='', mimetype=DEFAULT_CONTENT_TYPE)``
    指定のページコンテンツ (文字列) と MIME タイプで ``HttpResponse`` オブ
    ジェクトをインスタンス化します． ``DEFAULT_CONTENT_TYPE`` は
    ``'text/html'`` です．

    ``content`` はイテレータまたは文字列にできます．イテレータにする場合，
    文字列を返すイテレータでなければなりません．イテレータ中の文字列は全て
    結合され，レスポンスの内容になります．

``__setitem__(header, value)``
    ヘッダ名と値を設定します． ``header`` と ``value`` は文字列にせねばなり
    ません．

``__delitem__(header)``
    指定の名前のヘッダを削除します．ヘッダが存在しなければ，暗黙のうちに失
    敗します．大小文字を区別します．

``__getitem__(header)``
    指定のヘッダ名に対応する値を返します．大小文字を区別します．

``has_header(header)``
    大小文字を区別せずに指定の名前のヘッダがあるか調べ， ``True`` または
    ``False`` を返します．

``set_cookie(key, value='', max_age=None, expires=None, path='/', domain=None, secure=None)``
    クッキーを設定します．パラメタは Python 標準ライブラリの
    `Morsel オブジェクト`_ と同じ形式です．

        * ``max_age`` には秒数または ``None`` (デフォルト値) を指定します．
          デフォルト値では，クッキーはクライアントブラウザとのセッションの
          間だけ持続します．
        * ``expires`` は ``"Wdy, DD-Mon-YY HH:MM:SS GMT"`` の形式の文字列で
          す．
        * 別のドメインのクッキー (cross-domain cookie) を設定したい場合には，
          ``domain`` を使います．例えば， ``domain=".lawrence.com"`` にする
          と， www.lawrence.com, blogs.lawrence.com, calendars.lawrence.com
          といったサイトでだけ読めるようになります．それ以外の場合，クッキー
          はクッキーを設定したドメインでしか読めません．

    .. _`Morsel オブジェクト`: http://www.python.jp/doc/current/lib/morsel-objects.html
    .. _`cookie Morsel`: http://www.python.org/doc/current/lib/morsel-objects.html

``delete_cookie(key, path='/', domain=None)``
    指定のキーに対するクッキーを削除します．キーが存在しなければ，暗黙のう
    ちに失敗します．

    開発版の Django では， ``path`` と ``domain`` という 2 つの引数が追加さ
    れました． cookie の動作原理上， ``path`` と ``domain`` を
    ``set_cookie()`` に指定した値と同じにしないと，クッキーを削除できなくな
    ります．

``content``
    Python 文字列の内容を返します．必要ならば Unicode オブジェクトにエンコー
    ドします．メソッドではなくプロパティなので， ``r.content()`` ではなく 
    ``r.content`` になることに注意して下さい．

``write(content)``, ``flush()``, ``tell()``
    ``HttpResponse`` インスタンスをファイルライクオブジェクトのように扱うた
    めのメソッドです．

.. _HttpResponse subclasses:

HttpResponse のサブクラス
-------------------------

Django には，様々なタイプの HTTP レスポンスを扱うための ``HttpResponse`` の
サブクラスがあります．これらのサブクラスは ``HttpResponse`` と同じく
``django.http`` モジュールにあります．

``HttpResponseRedirect``
    コンストラクタはリダイレクト先のパスを示す引数を一つだけ取ります．リダ
    イレクト先は完全指定の URL (例えば ``"http://www.yahoo.com/search/"``) 
    でも，ドメイン名のない絶対 URL ( ``"/search/"``) でもかまいません．この
    レスポンスオブジェクトは HTTP 状態コード 302 を返します．

``HttpResponsePermanentRedirect``
    ``HttpResponseRedirect`` と同じですが，"found" リダイレクト (HTTP 状態
    コード 302) ではなく永続リダイレクト (状態コード 301) を使います．

``HttpResponseNotModified``
    コンストラクタは引数をとりません．ユーザが最後にリクエストしたときから
    ページが変更されていないことを知らせるために使います．

``HttpResponseNotFound``
    ``HttpResponse`` と同じですが，状態コード 404 を使います．

``HttpResponseForbidden``
    ``HttpResponse`` と同じですが，状態コード 403 を使います．

``HttpResponseNotAllowed``
    ``HttpResponse`` と同じですが，状態コード 405 を使います．許可されてい
    る HTTP メソッドのリスト (例えば ``['GET', 'POST']``) を必須の引数とし
    てとります．

``HttpResponseGone``
    ``HttpResponse`` と同じですが，状態コード 410 を使います．

``HttpResponseServerError``
    ``HttpResponse`` と同じですが，状態コード 500 を使います．
