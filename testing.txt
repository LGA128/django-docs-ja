==============================
Djangoアプリケーションのテスト
==============================

:revision-up-to: 4805 (release 0.96)

今日の開発者にとって，テストの自動化はバグ潰しの工程で極めて有用な武器にな
ります．テストスイートを使えば，最初にコードを書くときにコードが期待通りの
挙動になるか検証できます．コードのリファクタリングや修正の際には，リファク
タによって意外な動作が起きないようにする助けになります．

Web アプリケーションのテストは，いくつものコンポーネントを検証したりテスト
したりせねばならないため，複雑なタスクになるものです． Django では，アプリ
ケーションのテストを行いやすくするためのテスト実行フレームワークと，Web ア
プリケーションの様々な部分を駆動したり，内部を調べたりするためのユーティリ
ティを提供しています．

.. note::
    
    このテストフレームワークは現在開発中なので，次の公式リリースまでに多少
    の変更が加わるかもしれません．

    (だからといって，テスト書きをサボる理由にはなりませんよ！)

.. _Writing tests:

テストを書く
============

Django におけるテストは doctest と単体テストの二つの形式をとります．

.. _Writing doctests:

doctest を書く
--------------

doctest には， docstring (ドキュメンテーション文字列) 内のテストを探して実
行するための Python の標準モジュール， doctest_ を使います． Django のテス
トランナは ``models.py`` ファイル内の doctest を探し，見つかったテストを実
行します． Django はまた，アプリケーションのディレクトリ (``models.py`` ファ
イルがあるのと同じディレクトリ) 内の ``test.py`` というファイルを探し，
``tests.py`` があれば，その中に doctest がないか探します．


.. admonition:: **docstring** とは?

    docstring の詳しい説明 (と，効果的な docstring の書き方) は，
    :PEP:`257` (`和訳
    <http://www.python.jp/doc/contrib/peps/pep-0257.txt>`__) に書かれていま
    す:
        
        docstring とは，モジュールや関数，クラス，メソッド定義のブロック中
        の先頭に置かれた文字列リテラルです． docstring を定義すると，オブジェ
        クトの ``__doc__`` という特殊な属性になります．
        
    テストはそれ自体が素晴らしいドキュメントになります． doctest を使うと，
    テストを直接 docstring の中に配置できます．

doctest の文字列は ``models.py`` の全てのオブジェクトに対して記述できますが，
慣習的には，アプリケーションレベルの doctest はモジュールの docstring に，
モデルレベルの doctest は各モデルの docstring に配置します．

例を示します::

    from django.db import model
    
    class Animal(models.Model):
        """
        鳴き声から動物を調べるテスト
        
        # 動物インスタンスを生成する
        >>> lion = Animal.objects.create(name="lion", sound="roar")
        >>> cat = Animal.objects.create(name="cat", sound="meow")
        
        # speak() を呼び出す
        >>> lion.speak()
        'The lion says "roar"'
        >>> cat.speak()
        'The cat says "meow"'
        """
        
        name = models.CharField(maxlength=20)
        sound = models.CharField(maxlength=20)
        
        def speak(self):
            return 'The %s says "%s"' % (self.name, self.sound)


`テストを実行する`_ と，テストユーティリティは上の docstring を探し出して，
Python の対話セッションに見える部分を検出し，そこに書かれた命令を実行して，
docstring に書かれた結果と実際の実行結果が一致するかどうかを確かめます．

doctest の詳しい動作原理は， `標準ドキュメントの doctest の項`_
を参照してください．

.. doctest: http://docs.python.org/lib/module-doctest.html
.. _standard library documentation for doctest: doctest_
.. _doctest: http://python.jp/doc/release/lib/module-doctest.html
.. _`標準ドキュメントの doctest の項`: doctest_

.. _Writing unittests:

unittest を書く
---------------

Django の単体テストもまた，doctest と同様，標準ライブラリモジュールの
unittest_ を使います． doctest と同様， Django のテストランナは，アプリケー
ションディレクトリ内の ``models.py`` または ``test.py`` 内に定義されている
単体テストを探します．

上の例と同じ内容のテストを unittest のテストケースで書くと以下のようになり
ます::

    import unittest
    from myapp.models import Animal
    
    class AnimalTestCase(unittest.TestCase):
        
        def setUp(self):
            self.lion = Animal.objects.create(name="lion", sound="roar")
            self.cat = Animal.objects.create(name="cat", sound="meow")
        
        def testSpeaking(self):
            self.assertEquals(self.lion.speak(), 'The lion says "roar"')
            self.assertEquals(self.cat.speak(), 'The cat says "meow"')
            
`テストを実行する`_ と，テストユーティリティは ``models.py`` と
``tests.py`` に入っている全てのテストケース (``unittest.TestCase`` のサブク
ラス) を探しだし，そこからテストスイートを自動的に構築して，スイートを実行
します．

``unittest`` の詳細は `標準ライブラリドキュメントの unittest の項`_ を参照
してください．

.. unittest: http://docs.python.org/lib/module-unittest.html
.. _standard library unittest documentation: unittest_
.. _run your tests: `Running tests`_
.. _`テストを実行する`: `Running tests`_
.. _unittest: http://python.jp/doc/release/lib/module-unittest.html
.. _`標準ライブラリドキュメントの unittest の項`: unittest_

.. _Which should I use?:

どちらのテストを使うべきか
--------------------------

テストフレームワークの選択にまつわる議論は時として過熱ぎみになります．そこ
で，Django では二つの Python 標準テストフレームワークの両方をサポートしまし
た．どちらを選ぶかは，開発者個々人の好みに任せますし，どちらかをひいきにす
るということもありません．二つのテストフレームワークにはそれぞれの長所があ
るので，書きたいテストのタイプに合ったテストシステムをその都度選びながら，
両方を使いこなすのがベストだと思います．

とはいえ，テストを初めて書く開発者にとって，選択を行わねばならないのは混乱
のもとになるでしょう．ですから，ここでは doctest と単体テストの主な違いにつ
いて示し，どちらのテストを使うべきかを決める時の手がかりにしてもらおうと思
います．

そこそこ Python に慣れているなら， ``doctest`` の方がより "pythonic" だと感
じることでしょう． doctest はテストをできるだけ楽に書けるように設計されてい
るので，クラスやメソッドを書くときのオーバヘッドがほとんどありません．単に
docstring にテストを書くだけでよいのです．それに，モジュールに対してドキュ
メントを自動生成させられるという利点もあります．つまり， doctest を上手に書
けば，ドキュメント作成とテストを同時に片付けられて一石二鳥，というわけです．

また，テストにまだ慣れていない開発者は， doctest を使った方が早くテストにつ
いて学べることでしょう．

Java での開発経験のある開発者なら， ``unittest`` フレームワークはとても理解
しやすいはずです． ``unittest`` は Java の JUnit に影響を受けているので，
他の言語で JUnit から派生したテストフレームワークを使ったことがあるのなら，
``unittest`` はかなりしっくりくるはずです．

``unittest`` はクラスとメソッドを使って構築するので，一連のテストを書くとき
にコードを共有でき，より短く，きれいにテストコードを書けます．また，
``unittest`` はテストの初期化／終了処理のルーチンをサポートしているので，テ
ストケースを実行するときの環境を高い水準でコントロールできます．

繰り返しになりますが，(一つのアプリケーションの中であっても) 両方のシステム
を並べて使えることを忘れないでください．どちらのテストシステムにも，状況に
応じて適した部分があるので，大抵のプロジェクトでは，最終的には両方のテスト
システムを使うことになるものです．

.. _Testing Tools:

テストツール
====================

Django は，アプリケーションの様々な機能に対するテストを補助するために，テス
ト自体やテスト環境の構築に使えるツールを提供しています．

* `テストクライアント`_
* `フィクスチャ`_

_`テストクライアント`: `Test Client`_
_`フィクスチャ`: `Fixtures`_

.. _Test Client:

テストクライアント
------------------

テストクライアント (Test Client) は簡単なダミーブラウザです．テストクライア
ントを使うと，ある URL に対する GET や POST をシミュレートでき，リクエスト
に対するレスポンスを調べられます．テストクライアントを使えば，特定の URL に
対して正しいビューが呼び出されるかどうか，また，ビューが正しいレスポンスを
生成しているかどうかをテストできます．

テストクライアントは，ビューがレスポンスを生成する際に，ビューが利用した
``Template`` オブジェクトと ``Context`` オブジェクトに関する情報を取得しま
す．これらの情報はビューからのレスポンスの一部として返され，テスト条件とし
て利用できます．

.. admonition:: テストクライアントか，それともブラウザを自動化すべきか？

    テストクライアントは Twill_ や Selenium_ やその他ブラウザ自動化フレーム
    ワークの置き換えを狙ったものではありません．テストクライアントの目的は，
    エンドユーザに提供される HTML 自体のチェックではなく，ビューが使うコン
    テキストやテンプレートの内容のテストにあります．
    
    網羅的なテストスイートを実現したいのなら，テストクライアントと自動化ブ
    ラウザの両方を使うべきでしょう．テストクライアントは，正しいビューが呼
    び出されているか，そしてビューが正しいコンテキストデータを用意している
    かのテストを行います．一方，自動化ブラウザは，ユーザインタフェースが期
    待通りに動作しているかのテストを行います．
    
.. _Twill: http://twill.idyll.org/
.. _Selenium: http://www.openqa.org/selenium/

.. _Making requests:

リクエスト生成
~~~~~~~~~~~~~~

``Client`` (``django.test.client.Client``) のインスタンスは引数なしで生成し
ます． ``Client`` のインスタンスからは，以下のメソッドを呼び出せます．

``get(path, data={})``
    ``path`` に対する GET リクエストを行います．引数 ``data`` は辞書オブジェ
    クトで，キー／値のペアが GET データのペイロードの生成に使われます．例え
    ば::

        c = Client()
        c.get('/customers/details/', {'name':'fred', 'age':7})

    は，以下のような GET リクエストの送信と同じです::

        http://yoursite.com/customers/details/?name=fred&age=7

``post(path, data={}, content_type=MULTIPART_CONTENT)``
    ``path`` に対する POST リクエストを行います． ``content_type`` を
    指定した場合 (例えば XML ペイロードの場合には ``text/xml``)，引数
    ``data`` の中身は POST リクエストそのままで送信され， 
    ``Content-Type`` ヘッダの値は ``content_type`` の値になります．

    ``content_type`` を指定しなければ， ``data`` の中身は
    ``multipart/form-data`` で送信されます．

    ``data`` の中のキー／値のペアは，マルチパートメッセージにエンコードされ，
    POST データのペイロードになります．

    あるキーに対して複数の値を提出 (submit) する場合 (複数選択可能なリスト
    に対する選択内容を指定する場合など) は，キーに対する値をリストやタプル
    にしてください．例えば， ``{'choices': ('a', 'b', 'd')}`` のようにする
    と， ``choices`` という名前のフィールドから 3 つの行を選択して提出した
    のと同じになります．

    ただし，ファイルの送信は特別な扱いが必要です．ファイルの POST を行う場
    合，ファイル名フィールドの名前をキーに，アップロードしたいファイルのファ
    イルハンドルを値に設定します．テストクライアントは FileField が要求する
    二つの POST フィールド (``field`` と ``field_file``) に値を設定します．
    例えば::

        c = Client()
        f = open('wishlist.doc')
        c.post('/customers/wishes/', {'name':'fred', 'attachment':f})
        f.close()

    のようにすると， ``/customers/wishes/`` に対する POST リクエストの送信
    と同じになります．ビュー側の ``request.POST`` 辞書には `name`,
    `aatachment` (ファイル名), `attachment_file` (ファイルデータ) が入りま
    す．送信するファイルのハンドルは， POST データの送信後に手動で閉じる必
    要があります．

``login(path, username, password)``
    運用環境では，一部のビューを ``django.contrib.auth`` の
    ``@login_required`` デコレータで保護することがあります．ログインの有無
    で保護されている URL とのやりとりをテストするのはちょっと厄介なので，テ
    ストクライアントはログイン処理を自動化するための単純なメソッドを提供し
    ています．
    ``login()`` を呼び出すと， ``@login_required`` で保護されたビューにユー
    ザをログインさせる上で必要な一連の GET/POST 呼び出しを行います．

    ログインが可能なら， ``login()`` の戻り値は保護された URL に対する GET
    リクエストに応じて生成されたレスポンスになります．ログインが不可能なら，
    ``login()`` は False を返します．

    テストスイートはテスト用データベース上で実行されるので，デフォルトでは
    ユーザが一切登録されておらず，運用環境のユーザ情報を使おうとしてもうま
    くいかないので注意してください．自作のアプリケーションのログイン機能を
    試したければ，テストスイートの中でユーザを作成する必要があります．

.. _Testing Responses:

応答のテスト
~~~~~~~~~~~~

``get()``, ``post()`` および ``login()`` といったメソッドは，いずれも
Response オブジェクトを返します． Response オブジェクトには以下のようなプロ
パティがあり，テストに利用できます:

    ================  ========================================================
    プロパティ        説明
    ================  ========================================================
    ``status_code``   レスポンスの HTTP 状態コードです．全ての HTTP 状態コー
                      ドのリストは RFC2616_ を参照してください．

    ``content``       レスポンスの本体部分 (body) です．ビューがレンダリン
                      グによって生成した最終的なページコンテンツか，エラー
                      メッセージ (302 リダイレクトの場合のリダイレクト先
                      URL など) です．

    ``template``      最終的なページコンテンツのレンダリングに使われた
                      Template のインスタンスです．とりわけ，
                      ``template.name`` を調べると便利でしょう．テンプレー
                      トをファイルからロードしている場合， ``name`` はロー
                      ドされたファイル名になります．
                      
                      複数のテンプレートをレンダリングしている場合 (例えば
                      テンプレートが他のテンプレートを include している場合)，
                      ``template`` は Template オブジェクトをレンダリングし
                      た順に並べたリストになります．

    ``context``       レスポンスのページコンテンツのレンダに使われた
                      Context オブジェクトです．
                      
                      ``template`` と同様，複数の Context オブジェクトを使っ
                      てレンダリングを行った場合， ``context`` は Context
                      オブジェクトをレンダリングで使った順に並べたリストに
                      なります．
    ================  ========================================================

.. _RFC2616: http://www.w3.org/Protocols/rfc2616/rfc2616-sec10.html

.. _Exceptions:

例外
~~~~

テストクライアントのアクセス先のビューが例外を送出するような場合，その例外
はテストケース内でアクセスできます．例外のテストを行うには，通常の
``try...catch`` ブロックか， ``unittest.TestCase.assertRaises()`` を使いま
す．

ただし， ``Http404`` や ``PermissionDenied``, ``SystemExit`` といった例外は
テストケースからアクセスできません． Django はこれらの例外を内部的に捕捉し
て，対応する適切な HTTP 応答コードに変換してしまうからです．

.. _Persistent state:

セッションの永続性
~~~~~~~~~~~~~~~~~~

テストクライアントの動作はステートフルです．すなわち，ある時点でクライアン
トがクッキーつきのレスポンスを受け取ると，それ以降のリクエストはクッキー情
報つきになります．テストクライアントは，クッキーの有効期限ポリシを守りませ
ん．クッキーを期限切れにしたければ，該当クッキーを ``client.cookies`` から
手動で削除するか，新たな ``Client`` インスタンスを生成 (全てのクッキーを除
去) します．

テストクライアントには，永続セッション情報 (persistent state information)
を保存するためのプロパティが二つあります．これらのプロパティは，必要に応じ
てテスト条件の一部として検査できます．

    ===============  ====================================================
    プロパティ       説明
    ===============  ====================================================
    ``cookies``      Python の ``SimpleCookie`` 型のオブジェクトで，
                     全てのクライアントクッキーの現在値が入っています．

    ``session``      セッション情報の入った辞書ライクなオブジェクトです．
                     詳しくは `セッションのドキュメント <../sessions/>`_
                     を参照してください．
    ===============  ====================================================

.. _`session documentation`: ../sessions/
        
.. _Example:
             
テスト例
~~~~~~~~

テストクライアントを使った簡単な単体テストを以下に示します::
    
    import unittest
    from django.test.client import Client
    
    class SimpleTest(unittest.TestCase):
        def setUp(self):
            # Client 生成はいつも必要．
            self.client = Client()
        def test_details(self):        
            # GET リクエストを発行
            response = self.client.get('/customer/details/')

            # レスポンスが 200 OK であるか調べる    
            self.failUnlessEqual(response.status_code, 200)
            # レンダリングされるコンテキストの customers の長さが 5 である
            # か確かめる
            self.failUnlessEqual(len(response.context['customers']), 5)


.. _Fixtures:

フィクスチャ
------------

データベースがバックにあるウェブサイトのテストで，データベース上に何もデー
タが入っていなければあまり意味はありません．データベースにテストデータを入
れやすくするために， Django ではフィクスチャフレームワークを提供しています．

*フィクスチャ* (fixture) とは，データベースに入れるデータをシリアライズして
格納したファイル群を指します．各フィクスチャファイルには固有の名前を付けら
れますが，ある名前のフィクスチャを複数のディレクトリに入れても構いませんし，
複数のアプリケーション内に配置してもかまいません．

.. note::
    Django プロジェクトで syncdb を実行したことがあれば，すでに
    ``initial_data`` というフィクスチャを使っているはずです． Django はデー
    タベースの同期を行うたびに ``initial_data`` フィクスチャをインストール
    します．このメカニズムを使えば， (カテゴリのデフォルトセットのような)
    新たなデータセットをデータベースに組み込めます． ``initial_data`` 以外
    の名前のフィクスチャは， ``django-admin.py loaddata`` で手動で組み込め
    ます．
    
さて，単体テストが目的なら，各テストの開始時にデータベースの中身が何らかの
値になるよう保証せねばなりません．このため， Django はベースクラス TestCase
を用意して，フィクスチャを組み込めるようにしています．

従来の unittest の TestCase から Django の TestCase への乗り換えは簡単で，
テストクラスのベースクラス名を変更し，使いたいフィクスチャのリストを定義す
るだけです．例えば， `unittest を書く <#writing-unittests>`_ のテストケース
は以下のようになります::

    from django.test import TestCase
    from myapp.models import Animal

    class AnimalTestCase(TestCase):
        fixtures = ['mammals.json', 'birds']
        
        def setUp(self):
            # test definitions as before

テストケースの開始時で，かつ ``setUp()`` の実行前に， Django はデータベース
を一掃して，データベースを ``syncdb`` 直後の状態に戻します．次に，テストケー
スクラスに指定した全てのフィクスチャをインストールします．上の例では，
``mammals`` という名前の JSON フィクスチャと， ``birds`` という名前のフィク
スチャがインストールされます．フィクスチャの定義とインストールに関する詳細
は `フィクスチャの読み込み <../django_admin/#loaddata-fixture-fixture>`_
を参照してください．

.. _`loading fixtures`: ../django_admin/#loaddata-fixture-fixture

このフラッシュ／ロードの作業はテストケースの実行毎に繰り返されるので，他の
テストや以前のテスト実行の影響を受けることはありません．

.. _Running tests:

テストを実行する
================

テストを実行するには，プロジェクトの ``manage.py`` ユーティリティを使います::

    $ ./manage.py test

特定のアプリケーションに対してテストを実行したければ，コマンドラインにアプ
リケーションの名前を追加します．例えば， ``INSTALLED_APPS`` に
``myproject.polls`` と ``myproject.animals`` というアプリケーションが入って
おり， animals の単体テストを実行したいだけなら，以下のようにします::
 
    $ ./manage.py test animals

テストを実行すると，テストデータベースの生成やモデルの初期化の過程を示すテ
キストが表示されます．テストデータベースはテストを実行するたびに生成されま
す．

デフォルトでは，テストデータベースの名前は， ``settings.DATABASE_NAME`` に
指定したデータベース名の前に ``test_`` を付けたものになります．その他のデー
タベースに関する設定は，通常のプロジェクトで使われているものと同じです．
テストデータベースの名前をデフォルト意外の値にしたければ，
``TEST_DATABASE_NAME`` 設定を使って名前を指定します．

テスト用のデータベースが生成され，モデルが初期化され，テストが実行され，経
過を表示するテキストが流れます．

テストデータベースが生成されると， Django はテストを実行します．全てのテス
トにパスすると，最後には以下のようなメッセージが表示されます::

    ----------------------------------------------------------------------
    Ran 22 tests in 0.221s

    OK

一方，失敗したテストがあると，失敗したテストに関する詳しい情報が表示されま
す::

    ======================================================================
    FAIL: Doctest: ellington.core.throttle.models
    ----------------------------------------------------------------------
    Traceback (most recent call last):
      File "/dev/django/test/doctest.py", line 2153, in runTest
        raise self.failureException(self.format_failure(new.getvalue()))
    AssertionError: Failed doctest test for myapp.models
      File "/dev/myapp/models.py", line 0, in models

    ----------------------------------------------------------------------
    File "/dev/myapp/models.py", line 14, in myapp.models
    Failed example:
        throttle.check("actor A", "action one", limit=2, hours=1)
    Expected:
        True
    Got:
        False

    ----------------------------------------------------------------------
    Ran 2 tests in 0.048s

    FAILED (failures=1)
    
スクリプトの戻り値コードは失敗したテストの数です．テストにパスしたか否かに
関係なく，テストを全て実行し終えると，テストデータベースは消去されます．

.. _Using a different testing framework:

他のテストフレームワークを使う
==============================

Python のテストフレームワークは doctest と unittest だけではありません．
Django は他のテストフレームワークを明にサポートしているわけではありませんが，
他のテストフレームワークで作成したテストを Django の通常のテストと同じよう
に呼び出すためのメカニズムは提供しています．

``./manage.py test`` を実行すると， Django は ``TEST_RUNNER`` 設定を探して，
実行すべきテストランナを決定します．デフォルトでは， ``TEST_RUNNER`` は
``django.test.simple.run_tests`` です．このメソッドは Django のデフォルトの
テスト動作を実装しており，以下のように動作します:

#. テスト前の全体的な準備を行います．
#. テストデータベースを生成します．
#. ``syncdb`` を実行して，モデルと初期データをデータベースにインストールし
   ます．
#. インストールされている全てのアプリケーションの ``models.py`` や
   ``tests.py`` から，単体テストと doctest を探します．
#. 見つかった単体テストと doctest を実行します．
#. テストデータベースを破壊します．
#. テスト後の全体的な後始末を行います．

テストランナメソッドを自作して，そのメソッド名を ``TEST_RUNNER`` に指定して
おき， ``./manage.py test`` を実行すると， Django はそのテストランナメソッ
ドを実行します．これによって， Python コードから任意のテストフレームワーク
を実行できます．

.. _Defining a test runner:

テストランナを定義する
----------------------

慣習的に，テストランナは ``run_tests`` と呼ぶことになっていますが，実際には
どんな名前にしてもかまいません．ただし，テストランナは以下に示すように二つ
の引数をとらねばなりません．

``run_tests(module_list, verbosity=1)``
  ``module_list`` はテスト対象のモデルが入った Python モジュールのリストで，
  ``django.db.models.get_apps()`` が返すのと同じフォーマットです．

  ``verbosity`` には，コンソールに出力される通知情報やデバッグ情報の量を指
  定します．  `0` にすると何も出力しません． `1` は通常の出力， `2` は多め
  の出力です．

  このメソッドは失敗したテストの数を返さねばなりません．

.. _Testing utilities:

テスト用のユーティリティ
------------------------

``django.test.utils`` モジュールには，テストランナの自作に役立つユーティリ
ティメソッドが定義されています．

``setup_test_environment()``
    テンプレートレンダリングシステム構成のインストールなど，テスト前の全
    体的な準備を行います．

``teardown_test_environment()``
    テンプレートレンダリングシステム構成の除去など，テスト後の全体的な後始
    末を行います．

``create_test_db(verbosity=1, autoclobber=False)``
    新たなテストデータベースを生成し， ``syncdb`` を実行します．

    ``verbosity`` はテストランナの同名の引数と同じ意味です．

    ``autoclobber`` には，テスト用データベースと同じ名前のデータベースが既
    に存在する場合の挙動を指定します． ``autoclobber`` が ``False`` なら，
    既存のデータベースを破壊してもよいかユーザに尋ねます．ユーザが「いいえ」
    を選択すると，その時点で ``sys.exit`` を呼び出して終了します．
    ``autoclobber`` が ``True`` なら，既存のデータベースを破壊するときにユー
    ザに了解を求めません． 

    ``create_test_db()`` には ``settings.DATABASE_NAME`` を変更してテストデー
    タベースの名前にするという副作用があります．

``destroy_test_db(old_database_name, verbosity=1)``
    ``settings.DATABASE_NAME`` の名前 (通常は， ``create_test_db`` でテスト
    用に変更されているはずです) に一致するデータベースを破壊し，
    ``settings.DATABASE_NAME`` の値を ``old_database_name`` に指定した名前
    に戻します．

    ``verbosity`` はテストランナの同名の引数と同じ意味です．
