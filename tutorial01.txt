=====================================
はじめての Django アプリ作成，その 1 
=====================================

:revision-up-to: 4427 (0.96-pre SVN)

さあ，例を交えながら学んでゆきましょう．

このチュートリアルでは，簡単な投票 (poll) アプリケーションの作成に取り組ん
でもらいます．

Poll アプリケーションは，

    * ユーザが投票したり結果を表示したりできる公開用サイト
    * 投票項目の追加，変更，削除を行うための管理 (admin) サイト

の二つの部分に分かれているものとします． `Django は既にインストール済み`_
ですよね？ では始めましょう． Django がインストールされているかどうかは，
Python 対話シェルを起動して ``import django`` を実行してみればわかります．
エラーなく import できるなら， Django はインストールされています．

.. _`Django は既にインストール済み`: ../install/
.. _`Django installed`: ../install/

.. _Creating a project:

プロジェクトの作成
==================

初めて Django を使うのなら，最初のセットアップを行う必要があります．通常は，
Django の *プロジェクト (project)* を構成するコードを自動生成します．プロジェ
クトとは，データベースの設定や Django 固有のオプション，アプリケーション固
有の設定などといった，個々の Django インスタンスの設定をあつめたものです．

コマンドラインから，コードを置きたい場所に ``cd`` して，
``django-admin.py startproject mysite`` を実行してください．現在のディレク
トリに ``mysite`` ディレクトリが作成されます．

(``python setup.py`` ユーティリティで Django をインストールしたのなら，
``django-admin.py`` がシステムパスのどこかにあるはずです．パス上になければ，
``site-packages/django/bin`` にあります． ``site-packages`` は Python イン
ストールディレクトリの中にあります．パス上のどこか，例えば
``/usr/local/bin`` にシンボリックリンクを張っておきましょう．)

.. admonition:: コードはどこに置くの？

    PHP の経験があるなら，これまでは Web サーバのドキュメントルート下
    (``/var/www`` といった場所) にコードを配置してきたことでしょう． Django
    ではそうする必要はありません．むしろ Python コードをドキュメントルート
    下に置くのは賢明ではありません．コードをドキュメントルート下に置くと，
    誰かがコードを Web を介して読めるようになってしまうからです．これは安全
    上よろしくありません．

    コードはドキュメントルートの **外** ，例えば ``/home/mycode`` のような
    場所に置きましょう．

``startproject`` が何を作成したかをみてみましょう::

    mysite/
        __init__.py
        manage.py
        settings.py
        urls.py

ファイルはそれぞれ以下のような役割を持っています:

    * ``__init__.py``: このディレクトリが Python パッケージであることを
      Python に知らせるための空のファイルです．(Python の初心者は， Python
      の公式ドキュメントの (`パッケージの詳しい説明`_ を読んで下さい．)
    * ``manage.py``: Django プロジェクトに対する様々な操作を行うためのコマ
      ンドラインユーティリティです．
    * ``settings.py``: Django プロジェクトの設定ファイルです．
    * ``urls.py``: Django プロジェクトの URL 宣言，いうなれば Django 化サイ
      トにおける「目次」に相当します．

.. _`パッケージの詳しい説明`: http://www.python.jp/doc/release/tut/node8.html#packages
.. _more on packages: http://docs.python.org/tut/node8.html#packages

.. _The development server:

開発用サーバ
------------

プロジェクトがうまく動作するか確かめましょう． ``mysite`` ディレクトリに移
り， ``python manage.py runserver`` を実行してください．以下のようなメッセー
ジが表示されるはずです::

    Validating models...
    0 errors found.

    Django version 0.95, using settings 'mysite.settings'
    Development server is running at http://127.0.0.1:8000/
    Quit the server with CONTROL-C (Unix) or CTRL-BREAK (Windows).


これで， Django 開発サーバを起動しました． Django 開発サーバは Python だけ
で書かれた軽量な Web サーバです．このサーバは，開発を迅速に行い，運用に適し
た状態になるまで Apache のような運用サーバの設定をいじらなくても良いように
するためのものです．

ここで注意しておいたほうがよいでしょう: このサーバは開発中の利用だけを考え
て作られているため，絶対に運用環境では使わないようにしてください (筆者たち
の専門は Web フレームワークであって， Web サーバではありません)．

さあ，これでサーバが起動したので，ブラウザで http://127.0.0.1:8000/ にアク
セスしてみてください． "Welcome to Django" と表示された，愉快げなパステル調
のライトブルーのページが出るはずです．やったね！

.. admonition:: ポート番号の変更

    デフォルトでは， ``runserver`` コマンドを実行すると，開発用サーバはポー
    ト番号 8000 で起動します．サーバのポート番号を変更したければ，コマンド
    ライン引数で指定します．例えばポート番号を 8080 にしたければ以下のよう
    にしてください::

        python manage.py runserver 8080

    開発サーバの詳細な説明は `django-admin のドキュメント`_ にあります．

.. _`django-admin のドキュメント`: ../django-admin/

.. _Database setup:

Database の設定
---------------

それでは ，``settings.py`` を編集しましょう． ``settings.py`` は Django の
設定を表現する通常の Python モジュールです．設定を書き換えて，お使いのデー
タベースへの接続パラメタに合わせましょう:

    * ``DATABASE_ENGINE`` -- 'postgresql', 'mysql' または 'sqlite3'
      のいずれかです．他のデータベースもじきにサポートします．
    * ``DATABASE_NAME`` -- データベースの名前です． SQLite を使っている場合
      にはデータベースファイルのフルパス (絶対パス) にします．
    * ``DATABASE_USER`` -- データベースのユーザ名です (SQLite では使いませ
      ん)．
    * ``DATABASE_PASSWORD`` -- データベースのパスワードです．(SQLite では使
      いません)．
    * ``DATABASE_HOST`` -- データベースのあるホストです．データベースサーバ
      が物理的に同じマシン上にあるのなら空文字列にしておきます．(SQLite で
      は使いません)．

.. admonition:: Note

    PostgreSQL や MySQL を使っている場合，この時点でデータベースを作成して
    おいてください．データベースを作成するには，データベースの対話プロンプ
    トで "``CREATE DATABASE database_name;``" を実行します．

``settings.py`` を編集する際，ファイルの末尾近くにある ``INSTALLED_APPS``
設定に注意してください．この変数には，現在の Django インスタンスで有効になっ
ている全ての Django アプリケーションの名前が入ります．アプリケーションは複
数のプロジェクトで利用でき，配布もできます．

デフォルトでは ``INSTALLED_APPS`` には以下のアプリケーションが入っています．
これらのアプリケーションはいずれも Django に付属のものです:

    * ``django.contrib.auth`` -- 認証システムです．
    * ``django.contrib.contenttypes`` -- コンテンツタイプ処理フレームワーク
      です．
    * ``django.contrib.sessions`` -- セッションフレームワークです．
    * ``django.contrib.sites`` -- 一つの Django で複数のサイトを管理するた
      めのフレームワークです．

これらは，よくある状況で便利なのでデフォルトで付属しています．

これらのアプリケーションは必ず少なくとも一つのデータベーステーブルを使いま
す．そこで，アプリケーションを使う前にテーブルを作成しておく必要があります．
テーブルを作成するには以下のコマンドを使います::

    python manage.py syncdb

``syncdb`` コマンドは ``INSTALLED_APPS`` 設定を探し， ``settings.py`` の
データベース設定に従ってデータベース上に必要なテーブルを作成します．コマン
ドが生成したデータベースを示すメッセージが表示され，認証システムで使うスー
パユーザアカウントを作成したいかどうか尋ねるプロンプトが出ます．アカウント
を作成しておきましょう．

Django がどんなテーブルを作成したか興味があるなら，データベースのコマンドラ
インクライアントを使って， ``\dt`` (PostgreSQL), ``SHOW TABLES;`` (MySQL), 
あるいは ``.schema`` (SQLite) と入力してみましょう．

.. admonition:: ミニマリストのために

    上で述べたように，デフォルトのアプリケーションはよくあるケースに対応す
    るために入っているにすぎず，誰もが必要としているわけではありません．デ
    フォルトアプリケーションの一部なり全部なりが必要なければ， ``syncdb``
    を実行する前に該当する行をコメントアウトするか削除してかまいません．
    ``syncdb`` コマンドは ``INSTALLED_APPS`` にあるアプリケーションのテーブ
    ルを生成しているにすぎません．

.. _Creating models:

モデルの作成
============

さあ，これで自分用の環境，すなわちプロジェクトが立ち上がり，作業にとりかか
る準備ができました．

Django で書いたアプリケーションは Python パッケージからなり， ある規約に従っ
て `Python パス`_ のどこかに置かねばなりません．Django にはアプリケーション
の基本的なディレクトリ構造を作成するためのユーティリティがついてくるので，
ディレクトリの作成は気にせずコードの記述に集中できます．

.. admonition:: プロジェクトとアプリケーション

    プロジェクトとアプリケーションの違いとは何でしょうか？アプリケーション
    とは，実際に何らかの処理を行う Web アプリケーションを指します．例えばブ
    ログシステムや公開レコードのデータベース，単純な投票アプリといった具合
    です．プロジェクトとは，あるウェブサイト向けに設定とアプリケーションを
    集めたものです．一つのプロジェクトには複数のアプリケーションを入れられ
    ます．また，一つのアプリケーションは複数のプロジェクトで使えます．

このチュートリアルでは，簡単のため，投票アプリケーションを ``mysite`` ディ
レクトリの中に作ります．その結果，アプリケーションはプロジェクトとカップリ
ングします．すなわち， poll アプリケーション内の Python コードは
``mysite.polls`` のように参照されることになります．チュートリアルの後半
では，アプリケーションを配布用に脱カップリングする方法について議論する予定
です．

アプリケーションを作成するには， ``mysite`` ディレクトリの下に入って，以
下のようなコマンド::

    python manage.py startapp polls

を入力します．このコマンドは ``polls`` というディレクトリを作成し，その中の
レイアウトは以下のようになります::

    polls/
        __init__.py
        models.py
        views.py

このディレクトリ構造こそが， poll アプリケーションの全体像です．

Django でデータベース Web アプリケーションを書くための最初のステップは，モ
デルの定義です．本質的には，データベースのレイアウトと，追加のメタデータの
定義です．

.. admonition:: 設計哲学

   モデルは，手持ちのデータに対する唯一 (single) の決定的な (definitive) ソー
   スです．モデルには自分が格納したいデータにとって必要不可欠なフィールドと，
   そのデータの挙動を収めます． Django は `DRY 則`_ に従っています．Django
   のモデルの目的は，ただ一つの場所でデータモデルを定義し，そこから自動的に
   データを取り出せるようにすることにあります．

これから開発する簡単な poll アプリケーションでは，投票項目 (poll) と選択肢
(choice) の二つのモデルを作成します． poll には質問事項 (question) と公開日
(publication date) の情報があります． choice には選択肢のテキストと投票数
(vote) という二つのフィールドがあります．各 choice は一つの poll に関連づけ
られることになります．

Django では，こうした概念を簡単な Python クラスで表現できます．
``polls/models.py`` ファイルを以下のように編集してください::

    from django.db import models

    class Poll(models.Model):
        question = models.CharField(maxlength=200)
        pub_date = models.DateTimeField('date published')

    class Choice(models.Model):
        poll = models.ForeignKey(Poll)
        choice = models.CharField(maxlength=200)
        votes = models.IntegerField()

コードは単純明解ですね．各モデルは一つのクラスで表現され，いずれも
``django.db.models.Model`` のサブクラスになっています．各モデルには複数のク
ラス変数があり，個々のクラス変数はモデルのデータベースフィールドを表現して
います．

各フィールドは ``models.*Field`` クラスのインスタンスとして表現されています．
例えば， ``models.CharField`` は文字のフィールドで，
``models.DateTimeField`` は日時フィールドです．こうしたクラスは，各フィール
ドにどのようなデータ型を記憶させるかを Django に教えます．

``models.*Field`` インスタンスの名前 (``question`` や ``pub_date``) はフィー
ルドの名前で，計算機にとって扱いやすい名前を付けます．この名前は Python コー
ドの中で使いますし，データベースではカラム名に使います．

``Field`` の第一固定引数には，オプションとして人間可読なフィールド名も指定
できます．このフィールド名は Django の二つの内省 (introspection) 機能で使う
他，ドキュメントとしての役割も果たします．人間可読なフィールド名を指定しな
い場合， Django は機械可読な名前を使います．上の例では， ``Poll.pub_date``
にだけ人間可読なフィールド名を指定しました．モデルの他のフィールドでは，フィー
ルドの機械可読な名前は人間可読な名前としても十分なので定義していません．

``Field`` クラスの中には必須の引数を持つものがあります．例えば
``CharField`` には ``maxlength`` を指定する必要があります．この引数はデータ
ベーススキーマで使われる他，後で述べるバリデーションでも使われます．

最後に， ``models.ForeignKey`` を使ってリレーションが定義されていることに注
意して下さい．このリレーションは，各 Choice が一つの Poll に関連づけられて
いることを Django に教えます． Django は多対一，多対多，一対一といった，広
く使われているリレーション全てをサポートしています．

.. _`Python パス`: http://www.python.jp/doc/release/tut/node8.html#SECTION008110000000000000000
.. _`Python path`: http://docs.python.org/tut/node8.html#SECTION008110000000000000000
.. _`DRY 則`: http://c2.com/cgi/wiki?DontRepeatYourself
.. _DRY Principle: http://c2.com/cgi/wiki?DontRepeatYourself

.. _Activating models:

モデルを有効にする
==================

前述のようなほんのわずかなコードをモデルに書くだけで， Django はたくさんの
情報を手にします．このコードを使って， Django は:

    * アプリケーションのデータベーススキーマを作成 (``CREATE TABLE`` 文を実
      行) できます．
    * Poll や Choice オブジェクトに Python からアクセスするためのデータベー
      ス API を作成できます．

ただし，その前に ``polls`` アプリケーションをインストールしたことをプロジェ
クトに教えてやる必要があります．

.. admonition:: 設計哲学

    Django アプリケーションは「プラグ可能 (pluggable)」です．アプリケーショ
    ンは特定の Django インストールに結び付いていないので，アプリケーション
    を複数のプロジェクトで使ったり，単体で配布したりできます．

再度 ``settings.py`` ファイルを編集して，``INSTALLED_APPS`` 設定を変更し，
``'mysite.polls'`` を入れます．以下のようになるはずです::

    INSTALLED_APPS = (
        'django.contrib.auth',
        'django.contrib.contenttypes',
        'django.contrib.sessions',
        'django.contrib.sites',
        'mysite.polls'
    )

これで Django は ``mysite`` に ``polls`` アプリケーションが入っているこ
とを知りました．もう一つコマンドを実行してみましょう::

    python manage.py sql polls

以下のような (polls アプリケーション用の CRATE TABLE SQL 文) が表示されるは
ずです::

    BEGIN;
    CREATE TABLE "polls_poll" (
        "id" serial NOT NULL PRIMARY KEY,
        "question" varchar(200) NOT NULL,
        "pub_date" timestamp with time zone NOT NULL
    );
    CREATE TABLE "polls_choice" (
        "id" serial NOT NULL PRIMARY KEY,
        "poll_id" integer NOT NULL REFERENCES "polls_poll" ("id"),
        "choice" varchar(200) NOT NULL,
        "votes" integer NOT NULL
    );
    COMMIT;

以下の点に注意してください:

    * テーブル名はアプリケーションの名前 (``polls``) とモデルの小文字表記
      (``poll`` および ``choice``) を使って自動的に生成されます (この挙動は
      オーバライドできます．)

    * 主キー (primary key, ID) は自動的に生成されます (この挙動もオーバライ
      ド可能です)

    * 便宜上， Django は外部キーのフィールド名に ``"_id"`` を追加します．も
      ちろんこの挙動もオーバライド可能です．

    * 外部キーのリレーションは ``REFERENCES`` 文で明示的に作成されます．

    * SQL 文は使っているデータベースに応じて細かく調整されます．従って，
      ``auto_increment`` (MySQL)， `serial`` (PostgreSQL)， 
      ``integer primary key`` (SQLite) といったデータベース固有のフィールド
      タイプは自動的に指定されます．クオートの仕方，すなわち一重と二重のど
      ちらの引用符を使うか，といったことも自動で調整します．このチュートリ
      アルの作者は PostgreSQL を使っており，例題での出力は PostgreSQL の文
      法に準じています．

    * `sql` コマンドを実行しても，実際にデータベースで SQL を実行するわけで
      はありません． `sql` コマンドは，ユーザが Django の挙動を知りたいと考
      えたときのため，単に SQL 文をスクリーンに表示しているだけです．必要な
      ら，この SQL 文をコピーしてデータベースクライアントのプロンプトにペー
      ストできますが，後ですぐ述べるように， Django では SQL をデータベース
      に commit させる簡単な方法を提供しています．

興味があるなら，以下のコマンドも実行してみてください:

    * ``python manage.py validate polls`` -- モデルの構成にエラーがないか調
      べます．

    * ``python manage.py sqlinitialdata polls`` -- Django の admin フレーム
      ワークとモデルで必要な全ての初期データを出力します．

    * ``python manage.py sqlclear polls`` -- アプリケーション用のテーブルの
      うち，データベース上に存在するものについて必要に応じて ``DROP TABLE``
      文を出力します．

    * ``python manage.py sqlindexes polls`` -- アプリケーション用の 
      ``CREATE INDEX`` 文を出力します．

    * ``python manage.py sqlall polls`` -- 'sql', 'sqlinitialdata',
      'sqlindexes' コマンドを合わせたものです．


これらのコマンドの出力を見れば，水面下で実際に行われていることを理解する助
けになるでしょう．

``syncdb`` を再度実行して，モデルテーブルをデータベース上に作成しましょう::

    python manage.py syncdb

``syncdb`` コマンドは ``INSTALLED_APPS`` に登録されているアプリケーションの
うち，データベース上にまだ存在しないものに対して ``sqlall`` で生成した SQL
を生成します．こにれよって，最後に ``syncdb`` を実行した時以後に新たにプロ
ジェクトに追加されたアプリケーションのテーブルと初期データ，インデクスを生
成します．  ``syncdb`` はその都度存在しないテーブルだけを生成するので，繰り
返し実行してもかまいません．

``manage.py`` ユーティリティでできることについては
`django-admin.py のドキュメント`_ を読んで下さい．

.. _`django-admin.py のドキュメント`: ../django-admin/
.. _django-admin.py documentation: ../django_admin/

API で遊んでみる
================

さて，Python 対話シェルを起動して， Django が提供する API で遊んでみましょ
う． Python シェルを起動するには，以下のコマンドを実行します::

    python manage.py shell

単に "python" を実行しないのは， ``manage.py`` でプロジェクトの環境を設定し
ているからです．ここでいう「環境の設定」とは:

    * ``mysite`` を ``sys.path`` に入れます．柔軟性を持たせるために，
      Django を構成するコードの中には Python のドット表記 (例えば
      ``'mysite.polls.models'``) でプロジェクトを参照するものがあります．
      この表記でプロジェクトをうまく参照できるようにするには， ``mysite``
      パッケージは  ``sys.path`` 上になければなりません．

      こうした表記法の例は，すでに見たことがあるはずです: 例えば
      ``INSTALLED_APPS`` 設定は，ドット表記のパッケージ名からなるリストです．

    * 環境変数 ``DJANGO_SETTINGS_MODULE`` を設定して， ``settings.py`` ファ
      イルの在処を Django に教えます．

.. admonition:: manage.py を使わずに済ませる方法

    ``manage.py`` を使いたくなくても，問題はありません． ``mysite`` が
    Python パス上にあるように (``import mysite`` が通るように) して，環境変
    数 ``DJANGO_SETTINGS_MODULE`` を  ``mysite.settings`` に設定してくださ
    い．

    詳しくは `django-admin.py のドキュメント`_ を参照してください．

シェルに入ったら，データベース API の世界を探検してみましょう::

    # さきほど書いておいたモデルクラスを import します．
    >>> from mysite.polls.models import Poll, Choice

    # まだ Poll は一つもできていません．
    >>> Poll.objects.all()
    []

    # 新たな Poll を作成しましょう．
    >>> from datetime import datetime
    >>> p = Poll(question="What's up?", pub_date=datetime.now())

    # 出来たオブジェクトをデータベースに保存します． save() は明示的に呼ば
    # ねばなりません．
    >>> p.save()

    # これでオブジェクトに ID が割り当てられました．お使いのデータベースに
    # よっては，この値は "1" ではなく "1L" のときもあります．心配することは
    # ありません．単にデータベースバックエンドが Python 長整数型で値を返す
    # ようになっているだけのことです．
    >>> p.id
    1

    # データベースの各カラムに Python の属性としてアクセスします．
    >>> p.question
    "What's up?"
    >>> p.pub_date
    datetime.datetime(2005, 7, 15, 12, 00, 53)

    # 属性を変更して save() を呼び出すとカラムの値を変更します．
    >>> p.pub_date = datetime(2005, 4, 1, 0, 0)
    >>> p.save()

    # objects.all() はデータベース上の全ての Poll を返します．
    >>> Poll.objects.all()
    [<Poll: Poll object>]


おっと，ちょっと待って下さい． ``<Poll: Poll object>`` なんて全然親切な表現
ではありませんね．そこで (``polls/models.py`` ファイルに定義されている)
polls 関係のモデルを少し修正して， ``Poll`` と ``Choice`` に ``__str__()``
メソッドを追加しましょう::

    class Poll(models.Model):
        # ...
        def __str__(self):
            return self.question

    class Choice(models.Model):
        # ...
        def __str__(self):
            return self.choice

``__str__()`` をモデルに追加しておくのは，対話プロンプトで扱うときに精神的
によいだけでなく，オブジェクトの表現 (representation) は Django 自動 admin
のいたるところで使われているという点でも重要です．

``__str__()`` は通常の Python メソッドということに注意してください．デモ用
にカスタムのメソッドを追加してみましょう::

    import datetime
    # ...
    class Poll(models.Model):
        # ...
        def was_published_today(self):
            return self.pub_date.date() == datetime.date.today()

``import datetime`` で Python の標準モジュール ``datetime`` を参照している
ことに注意してください．

``python manage.py shell`` を実行して，Python 対話シェルに戻りましょう::

    >>> from mysite.polls.models import Poll, Choice

    # __str__() がきちんと働いていることを確認します．
    >>> Poll.objects.all()
    [<Poll: What's up?>]

    # Django は様々なデータベース照合 API を提供しています． API はキーワー
    # ド引数で隅々まで操作できます．
    >>> Poll.objects.filter(id=1)
    [<Poll: What's up?>]
    >>> Poll.objects.filter(question__startswith='What')
    [<Poll: What's up?>]

    # 2005 年の Poll を取り出しましょう．あなたがこのチュートリアルを実行
    # しているのが 2005 年でないのなら，適当に値を読みかえてください．
    >>> Poll.objects.get(pub_date__year=2005)
    <Poll: What's up?>

    >>> Poll.objects.get(id=2)
    Traceback (most recent call last):
        ...
    DoesNotExist: Poll matching query does not exist.
    >>> Poll.objects.filter(question__startswith='What')
    [<Poll: What's up?>]

    # 主キーの照合はよくあることなので， Django は主キーの厳密一致を照合
    # するショートカットを提供しています．
    # 以下の実行文は Poll.objects.get(id=1) と同じです．
    >>> Poll.objects.get(pk=1)
    <Poll: What's up?>

    # カスタムメソッドが動作するか確かめてみましょう．
    >>> p = Poll.objects.get(pk=1)
    >>> p.was_published_today()
    False

    # Poll に二つの Choice を指定しましょう． create を呼び出すと，新たな
    # Choice オブジェクトを生成し， INSERT 文を実行し， Poll からアクセス可
    # 能な Choice オブジェクトの集合に追加して，新たに作成された Choice オ
    # ブジェクトを返します．

    >>> p = Poll.objects.get(pk=1)
    >>> p.choice_set.create(choice='Not much', votes=0)
    <Choice: Not much>
    >>> p.choice_set.create(choice='The sky', votes=0)
    <Choice: The sky>
    >>> c = p.choice_set.create(choice='Just hacking again', votes=0)

    # Choice オブジェクトは自分に関連づけされた Poll オブジェクトに
    # アクセスするための API を備えています．
    >>> c.poll
    <Poll: What's up?>

    # 逆も行えます: Poll オブジェクトから Choice オブジェクトにアクセスでき
    # ます．
    >>> p.choice_set.all()
    [<Choice: Not much>, <Choice: The sky>, <Choice: Just hacking again>]
    >>> p.choice_set.count()
    3

    # API は必要に応じて自動的にリレーションを追跡します．リレーションを辿
    # るには二重アンダースコアを使います．この表記法には制限がなく，何段階
    # でも連鎖できます．以下の例では， pub_date が 2005 の全ての Poll に関
    # 連づけられている Choice を返します．
    >>> Choice.objects.filter(poll__pub_date__year=2005)
    [<Choice: Not much>, <Choice: The sky>, <Choice: Just hacking again>]

    # choice を一つ削除しましょう． delete() を使います．
    >>> c = p.choice_set.filter(choice__startswith='Just hacking')
    >>> c.delete()

データベース API の詳細は， `データベース API リファレンス`_ を参照してくだ
さい．

API を使いこなせるようになったら， `チュートリアル第 2 部`_ に進んで，
Django の自動 admin を動かしてみましょう．

.. _`データベース API リファレンス`: ../db-api/
.. _`チュートリアル第 2 部`: ../tutorial02/
.. _Database API reference: ../db_api/
.. _part 2 of this tutorial: ../tutorial02/
