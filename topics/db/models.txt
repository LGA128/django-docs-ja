.. _topics-db-models:

==============
Writing models
==============

.. module:: django.db.models

モデルとは、サイトを構成するデータの、ただ一つかつ最終的なデータソースを指
します。モデルには、保存したいデータに不可欠なデータフィールドと、その振舞
いが収められています。一般的に、各モデルは単一のデータベーステーブルに対応
づけられています。

基本として、まず以下のことを知っておきましょう:

    * 各モデルは Python のクラスで、 :class:`django.db.models.Model` のサブ
      クラスです。

    * モデルの各属性値は、データベース上のあるフィールドを表現します。

    * これらの情報をもとに、 Django はデータベース API を自動生成します。
      API の詳細は :ref:`topics-db-queries` で解説します。

.. seealso::

    このドキュメントを理解する上で、 `モデル例の公式リポジトリ`_ 
    が参考になるでしょう。 (Django のソース配布物中では、これらの例は
    ``tests/modeltests`` ディレクトリに収められています。)

    .. _official repository of model examples: http://www.djangoproject.com/documentation/models/
    .. _`モデル例の公式リポジトリ`: `official repository of model examples`_

.. _Quick example:

簡単な例
========

以下のモデル例では、 ``first_name`` および ``last_name`` というフィールドを
持った ``Person`` を定義しています::

    from django.db import models

    class Person(models.Model):
        first_name = models.CharField(max_length=30)
        last_name = models.CharField(max_length=30)

``first_name`` と ``last_name`` はモデルの *フィールド (fields)* です。各
フィールドはクラス属性として定義され、各属性がデータベースのカラムに対応し
ます。

上の ``Person`` モデルは、以下のようなデータベーステーブルを生成します:

.. code-block:: sql

    CREATE TABLE myapp_person (
        "id" serial NOT NULL PRIMARY KEY,
        "first_name" varchar(30) NOT NULL,
        "last_name" varchar(30) NOT NULL
    );

以下に技術的な注意点を示します:

    * テーブルの名前、 ``myapp_person`` はモデルのメタデータから自動的に導
      出したものですが、オーバライドもできます。 :ref:`table-names` を参照
      してください。

    * ``id`` は自動的に追加されますが、この挙動もまたオーバライドできます。
      :ref:`automatic-primary-key-fields` を参照してください。

    * この例の ``CREATE TABLE`` SQL 文は PostgreSQL の書式で書かれています
      が、 Django は :ref:`settings file <topics-settings>` に指定されたデー
      タベースバックエンド向けの SQL を使います。


.. _Using models:

モデルを使う
============

モデルを定義したら、そのモデルを *使う* と Django に教えます。設定ファイル
を編集して、 ``models.py`` の入ったモジュールの名前を
:setting:`INSTALLED_APPS` 設定に追加してください。

例えば、アプリケーションのモデルが ``mysite.myapp.models`` モジュール
( :djadmin:`manage.py startapp <startapp>` スクリプトで作成した、アプリケー
ションのパッケージ構造) に収められている場合、 :setting:`INSTALLED_APPS` は
以下のようになります::

    INSTALLED_APPS = (
        #...
        'mysite.myapp',
        #...
    )

新しいアプリケーションを :setting:`INSTALLED_APPS` に追加したら、
:djadmin:`manage.py syncdb <syncdb>` を忘れずに実行してください。


.. _Fields:

フィールド
==========

モデルで最も重要であり、かつモデル定義で最小限必要な部分は、モデル内が定義
しているデータベースフィールドのリストです。フィールドはクラスの属性として
定義されています。

例を示します::

    class Musician(models.Model):
        first_name = models.CharField(max_length=50)
        last_name = models.CharField(max_length=50)
        instrument = models.CharField(max_length=100)

    class Album(models.Model):
        artist = models.ForeignKey(Musician)
        name = models.CharField(max_length=100)
        release_date = models.DateField()
        num_stars = models.IntegerField()

.. _Field types:

フィールドのタイプ
------------------

モデルの各フィールドは適切な :class:`~django.db.models.Field` クラスのイン
スタンスにせねばなりません。 Django はフィールドクラス型を以下のいくつかの
判定に使います:

    * データベースのカラム型 (``INTEGER``, ``VARCHAR`` など)。

    * Django の admin サイトで使うウィジェットの選択 
      (``<input type="text">``, ``<select>`` など)。

    * Django の admin やマニピュレータで使われている最小限のバリデーション
      (validation)。

.. TBD

Django ships with dozens of built-in field types; you can find the complete list
in the :ref:`model field reference <model-field-types>`. You can easily write
your own fields if Django's built-in ones don't do the trick; see
:ref:`howto-custom-model-fields`.

.. _Field options:

フィールドのオプション
----------------------

Each field takes a certain set of field-specific arguments (documented in the
:ref:`model field reference <model-field-types>`). For example,
:class:`~django.db.models.CharField` (and its subclasses) require a
:attr:`~django.db.models.CharField.max_length` argument which specifies the size
of the ``VARCHAR`` database field used to store the data.

There's also a set of common arguments available to all field types. All are
optional. They're fully explained in the :ref:`reference
<common-model-field-options>`, but here's a quick summary of the most often-used
ones:

    :attr:`~Field.null`
        ``True`` にすると、 Django は空の値を ``NULL`` としてデータベースに
        入れます。デフォルト値は ``False`` です。

    :attr:`~Field.blank`
        ``True`` にすると、フィールドの値を空白 (blank) にできます。デフォ
        ルト値は ``False`` です。

        :attr:`~Field.null` とは違うことに注意してください。
        :attr:`~Field.null` が純粋にデータベース上の表現に関わる概念である
        のに対し、 :attr:`~Field.blank` とは値の検証 (validation) に関わ
        る概念です。あるフィールドに :attr:`blank=True <Field.blank>` を指
        定すると、 Djangoの adminサイト上で、空の値のエントリを作れるように
        なります。 :attr:`blank=False <Field.blank>` にすると、そのフィール
        ドには必ず値を入れねばなりません。

    :attr:`~Field.choices`
        2 要素のタプルからなる iterable (リストまたはタプル) を、フィールド
        の値の選択肢にします。この値を指定すると、 Django の admin には標準
        的なテキストフィールドの代わりに選択ボックスが表示され、指定された
        選択肢だけをえらべるようになります。

        選択肢リストは以下のようになります::

            YEAR_IN_SCHOOL_CHOICES = (
                ('FR', 'Freshman'),
                ('SO', 'Sophomore'),
                ('JR', 'Junior'),
                ('SR', 'Senior'),
                ('GR', 'Graduate'),
            )

    :attr:`~Field.default`
        フィールドのデフォルト値です。この値は、何らかの値でも、呼び出し可
        能オブジェクトでもかまいません。呼び出し可能オブジェクトの場合、新
        たなオブジェクトが生成されるたびに呼び出されます。

    :attr:`~Field.help_text`
        オブジェクトの admin フォームの下に表示される、追加の「ヘルプ」テキ
        ストです。オブジェクトが admin のフォームを持っていなくても、ドキュ
        メントとして有用でしょう。

    :attr:`~Field.primary_key`
        ``True`` を指定すると、フィールドをモデルの主キーにします。

        .. TBD

        If you don't specify :attr:`primary_key=True <Field.primary_key>` for
        any fields in your model, Django will automatically add an
        :class:`IntegerField` to hold the primary key, so you don't need to set
        :attr:`primary_key=True <Field.primary_key>` on any of your fields
        unless you want to override the default primary-key behavior. For more,
        see :ref:`automatic-primary-key-fields`.

    :attr:`~Field.unique`
        ``True`` であれば、フィールドはテーブル全体で一意の値を取らねばなり
        ません。

Again, these are just short descriptions of the most common field options. Full
details can be found in the :ref:`common model field option reference
<common-model-field-options>`.

.. _automatic-primary-key-fields:
.. _Automatic primary key fields:

自動的な主キーフィールド
----------------------------

デフォルトでは、 Django は各モデルに以下のフィールド::

    id = models.AutoField(primary_key=True)

を追加します。これは自動的に値をインクリメントして追加してゆくフィールドで、
主キーに使われます。

カスタムの主キーを指定したければ、いずれかのフィールドに
:attr:`primary_key=True <Field.primary_key>` を指定してください。
:attr:`Field.primary_key` の設定を見つけると、Django は ``id`` カラムを自動
的に追加しません。

各モデルには必ず一つ :attr:`primary_key=True <Field.primary_key>` のフィー
ルドが必要です。

.. _Verbose field names:

詳細なフィールド名
------------------

各フィールドの型は、  :class:`~django.db.models.fields.ForeignKey`,
:class:`~django.db.models.fields.ManyToManyField` および
:class:`~django.db.models.fields.OneToOneField` を除き、オプションの固定引
数 (positional argument) を第一引数として指定できます。この引数には人間可読
なカラム名を指定します。引数を指定しなければ、 Django はカラム名のアンダー
スコアをスペースに変換して、自動的に人間可読なカラム名を生成します。

下の例では、人間可読なカラム名は ``"Person's first name"`` です::

    first_name = models.CharField("Person's first name", max_length=30)

下の例では ``"first name"`` です::

    first_name = models.CharField(max_length=30)

:class:`~django.db.models.fields.ForeignKey`,
:class:`~django.db.models.fields.ManyToManyField` および
:class:`~django.db.models.fields.OneToOneField` では、第一引数は必須で、モ
デルのクラスにします。従って、人間可読なカラム名を指定するには、
:attr:`~Field.verbose_name` キーワード引数を使います::

    poll = models.ForeignKey(Poll, verbose_name="the related poll")
    sites = models.ManyToManyField(Site, verbose_name="list of sites")
    place = models.OneToOneField(Place, verbose_name="related place")

慣習的に、 :attr:`~Field.verbose_name` の先頭の文字は大文字にしません。
Django は必要なときに先頭の文字を自動的に大文字にします。

.. _Relationships:

リレーション
------------

関係データベースの威力はテーブルを相互に関連づけることにあるのはいうまでも
ありません。Django ではよく使われるデータベースリレーション (relationship)、
多対一 (many-to-one)、多対多 (many-to-many)、一対一 (one-to-one) を定義する
方法を提供しています。

.. _Many-to-one relationships:

多対一のリレーション
~~~~~~~~~~~~~~~~~~~~

多対一のリレーションを定義するには
:class:`~django.db.models.fields.ForeignKey` を使います。このフィールドは他
のフィールド型と同じように、モデルのクラス属性に含めて使えます。

:class:`~django.db.models.fields.ForeignKey` には、固定引数が一つあり、リレー
ションを張る対象のクラスを指定します。

例えば、 ``Car`` モデルに ``Manufacturer`` というフィールドを持たせたいとし
ましょう。すなわち、ある ``Manufacturer`` には複数の ``Car`` が対応するが、
各 ``Car`` には一つだけ ``Manufacturer`` が対応するようにしたいとしましょう。
この場合、以下のように定義します::

    class Manufacturer(models.Model):
        # ...

    class Car(models.Model):
        manufacturer = models.ForeignKey(Manufacturer)
        # ...
        
.. TBD

You can also create :ref:`recursive relationships <recursive-relationships>` (an
object with a many-to-one relationship to itself) and :ref:`relationships to
models not yet defined <lazy-relationships>`; see :ref:`the model field
reference <ref-foreignkey>` for details.

It's suggested, but not required, that the name of a
:class:`~django.db.models.ForeignKey` field (``manufacturer`` in the example
above) be the name of the model, lowercase. You can, of course, call the field
whatever you want. For example::

    class Car(models.Model):
        company_that_makes_it = models.ForeignKey(Manufacturer)
        # ...

.. seealso::

    See the `Many-to-one relationship model example`_ for a full example.

.. _Many-to-one relationship model example: http://www.djangoproject.com/documentation/models/many_to_one/

:class:`~django.db.models.ForeignKey` fields also accept a number of extra
arguments which are explained in :ref:`the model field reference
<foreign-key-arguments>`. These options help define how the relationship should
work; all are optional.

.. _Many-to-many relationships:

多対多のリレーション
~~~~~~~~~~~~~~~~~~~~

多対多の (many-to-many) リレーションを定義するには
:class:`~django.db.models.fields.ManyToManyField` を使います。このフィール
ドは他のフィールド型と同じように、モデルのクラス属性に含めて使えます。

:class:`~django.db.models.fields.ManyToManyField` には固定引数が一つあり、
リレーションを張る対象のクラスを指定します。

例えば、 ``Pizza`` には複数の ``Topping`` オブジェクトを持たせられます。
すなわち、ある ``Topping`` は複数のピザの上に置けて、逆にそれぞれのピザには
複数のトッピングを置けるというわけです。このリレーションを表すには次のように
します::

    class Topping(models.Model):
        # ...

    class Pizza(models.Model):
        # ...
        toppings = models.ManyToManyField(Topping)

.. TBD

As with :class:`~django.db.models.ForeignKey`, you can also create
:ref:`recursive relationships <recursive-relationships>` (an object with a
many-to-one relationship to itself) and :ref:`relationships to models not yet
defined <lazy-relationships>`; see :ref:`the model field reference
<ref-manytomany>` for details.

必須ではありませんが、 :class:`~django.db.models.fields.ManyToManyField` の
名前 (上の例では ``toppings``)は、リレーション先のモデル名の複数形にするよ
う勧めます。

どちらのモデルで :class:`~django.db.models.fields.ManyToManyField` を定義し
てもかまいませんが、どちらか片方のモデルにしか必要ありません -- 両方には指
定できません。

一般的に、 Django の admin を使っている場合、
:class:`~django.db.models.fields.ManyToManyField` インスタンスを入れておく
のは、 admin インタフェースで編集される側のオブジェクトにしておきます。上の
例では、 ``topping`` は (``Topping`` に
:class:`~django.db.models.fields.ManyToManyField` の ``pizzas`` をもたせる
のではなく) ``Pizza`` に入れておきます。というのも、「トッピングを乗せるピ
ザ」と考えるよりも「ピザの上に乗せるトッピング」を考える方が自然だからです。
こうして上の例では、 ``Pizza`` の admin フォームでユーザにトッピングを選ば
せることになります。

.. seealso:: 

    完全な例は `多対多のリレーションを持つモデルの例`_ を参照してください。

.. _Many-to-many relationship model example: http://www.djangoproject.com/documentation/models/many_to_many/
.. _`多対多のリレーションを持つモデルの例`: `Many-to-many relationship model example`_

.. TBD

:class:`~django.db.models.ManyToManyField` fields also accept a number of extra
arguments which are explained in :ref:`the model field reference
<manytomany-arguments>`. These options help define how the relationship should
work; all are optional.

Extra fields on many-to-many relationships
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

.. versionadded:: 1.0

When you're only dealing with simple many-to-many relationships such as
mixing and matching pizzas and toppings, a standard :class:`~django.db.models.ManyToManyField` is all you need. However, sometimes
you may need to associate data with the relationship between two models.

For example, consider the case of an application tracking the musical groups
which musicians belong to. There is a many-to-many relationship between a person
and the groups of which they are a member, so you could use a
:class:`~django.db.models.ManyToManyField` to represent this relationship.
However, there is a lot of detail about the membership that you might want to 
collect, such as the date at which the person joined the group.

For these situations, Django allows you to specify the model that will be used
to govern the many-to-many relationship. You can then put extra fields on the
intermediate model. The intermediate model is associated with the
:class:`~django.db.models.ManyToManyField` using the 
:attr:`through <ManyToManyFields.through>` argument to point to the model
that will act as an intermediary. For our musician example, the code would look
something like this::

    class Person(models.Model):
        name = models.CharField(max_length=128)

        def __unicode__(self):
            return self.name

    class Group(models.Model):
        name = models.CharField(max_length=128)
        members = models.ManyToManyField(Person, through='Membership')

        def __unicode__(self):
            return self.name

    class Membership(models.Model):
        person = models.ForeignKey(Person)
        group = models.ForeignKey(Group)
        date_joined = models.DateField()
        invite_reason = models.CharField(max_length=64)

When you set up the intermediary model, you explicitly specify foreign 
keys to the models that are involved in the ManyToMany relation. This
explicit declaration defines how the two models are related.

There are a few restrictions on the intermediate model:

    * Your intermediate model must contain one - and *only* one - foreign key
      on the target model (this would be ``Person`` in our example). If you
      have more than one foreign key, a validation error will be raised.
  
    * Your intermediate model must contain one - and *only* one - foreign key 
      on the source model (this would be ``Group`` in our example). If you
      have more than one foreign key, a validation error will be raised.

    * The only exception to this is a model which has a many-to-many
      relationship to itself, through an intermediary model. In this
      case, two foreign keys to the same model are permitted, but they
      will be treated as the two (different) sides of the many-to-many
      relation.
    
    * When defining a many-to-many relationship from a model to
      itself, using an intermediary model, you *must* use
      :attr:`symmetrical=False <ManyToManyFields.symmetrical>` (see 
      :ref:`the model field reference <manytomany-arguments>`).

Now that you have set up your :class:`~django.db.models.ManyToManyField` to use
your intermediary model (Membership, in this case), you're ready to start
creating some many-to-many relationships. You do this by creating instances of
the intermediate model::
    
    >>> ringo = Person.objects.create(name="Ringo Starr")
    >>> paul = Person.objects.create(name="Paul McCartney")
    >>> beatles = Group.objects.create(name="The Beatles")
    >>> m1 = Membership(person=ringo, group=beatles,
    ...     date_joined=date(1962, 8, 16), 
    ...     invite_reason= "Needed a new drummer.")
    >>> m1.save()
    >>> beatles.members.all()
    [<Person: Ringo Starr>]
    >>> ringo.group_set.all()
    [<Group: The Beatles>]
    >>> m2 = Membership.objects.create(person=paul, group=beatles,
    ...     date_joined=date(1960, 8, 1), 
    ...     invite_reason= "Wanted to form a band.")
    >>> beatles.members.all()
    [<Person: Ringo Starr>, <Person: Paul McCartney>]

Unlike normal many-to-many fields, you *can't* use ``add``, ``create``,
or assignment (i.e., ``beatles.members = [...]``) to create relationships::

    # THIS WILL NOT WORK
    >>> beatles.members.add(john)
    # NEITHER WILL THIS
    >>> beatles.members.create(name="George Harrison")
    # AND NEITHER WILL THIS
    >>> beatles.members = [john, paul, ringo, george]
    
Why? You can't just create a relationship between a Person and a Group - you
need to specify all the detail for the relationship required by the
Membership table. The simple ``add``, ``create`` and assignment calls
don't provide a way to specify this extra detail. As a result, they are
disabled for many-to-many relationships that use an intermediate model.
The only way to create a many-to-many relationship with an intermediate table
is to create instances of the intermediate model.

The ``remove`` method is disabled for similar reasons. However, the
``clear()`` method can be used to remove all many-to-many relationships
for an instance::

    # Beatles have broken up
    >>> beatles.members.clear()

Once you have established the many-to-many relationships by creating instances
of your intermediate model, you can issue queries. Just as with normal 
many-to-many relationships, you can query using the attributes of the 
many-to-many-related model::

    # Find all the groups with a member whose name starts with 'Paul'
    >>> Groups.objects.filter(person__name__startswith='Paul')
    [<Group: The Beatles>]

As you are using an intermediate table, you can also query on the attributes 
of the intermediate model::

    # Find all the members of the Beatles that joined after 1 Jan 1961
    >>> Person.objects.filter(
    ...     group__name='The Beatles',
    ...     membership__date_joined__gt=date(1961,1,1))
    [<Person: Ringo Starr]
    

.. _One-to-one relationships:

一対一のリレーション
~~~~~~~~~~~~~~~~~~~~

一対一のリレーションを定義するには、
:class:`~django.db.models.fields.OneToOneField` を使います。このフィールド
は他のフィールド型と同じように、モデルのクラス属性に含めて使えます。

このリレーションがもっとも有用なのは、あるオブジェクトが別のオブジェクトを
何らかの形で「拡張」している場合の主キーとして使う場合です。

:class:`~django.db.models.fields.OneToOneField` には固定引数が一つあり、リ
レーションを張る対象のクラスを指定します。

例えば、「場所 (place)」のデータベースを作るときには、アドレス、電話番号、
といった標準的なものを作成します。その上で、レストランデータベースを作成
するときに、 ``Restaurant`` モデルの中に同じフィールドをつくるような
繰り返し作業 (repeat yourself) をする代わりに、場所データベースを基盤にして
レストランのデータベースを作成したいとしましょう。このとき、 ``Restaurant`` 
には ``Place`` への :class:`~django.db.models.fields.OneToOneField` をもた
せられます (レストランは場所に対して "is-a" の関係だからです。実際には、こ
のような状況を扱うのに :ref:`モデルの継承 <model-inehritance>` を使いますが、
モデル継承は :class:`~django.db.models.fields.OneToOneField` で実現されてい
ます)。

.. TBD

As with :class:`~django.db.models.ForeignKey`, a
:ref:`recursive relationship <recursive-relationships>`
can be defined and
:ref:`references to as-yet undefined models <lazy-relationships>`
can be made; see
:class:`the model field reference <django.db.models.fields.OneToOneField>`
for details.

.. seealso::

    詳細な例は `一対一のリレーションを持つモデルの例`_ を参照してください。

.. _One-to-one relationship model example: http://www.djangoproject.com/documentation/models/one_to_one/
.. _`一対一のリレーションを持つモデルの例`: `One-to-one relationship model example`_

.. versionadded:: 1.0

.. TBD

:class:`~django.db.models.OneToOneField` fields also accept one optional argument
described in the :ref:`model field reference <ref-onetoone>`.

以前は、モデル中で :class:`~django.db.models.fields.OneToOneField` を使うと、
そのフィールドは自動的にモデルの主キーになっていました。この仕様はもうなく
なりましたが、主キーにしたければ手動で ``primary_key`` に指定できます。この
変更により、一つのモデル中で複数の
:class:`~django.db.models.fields.OneToOneField` を使えるようになりました。

.. _Models across files:

ファイル間にまたがるモデル
-----------------------------

あるモジュールから別のモジュールへのリレーションは全く問題なく張れます。リ
レーションを張るには、モデル定義の先頭でリレーション対称のモデルを import
しておき、必要なところでそのモデルクラスを参照します。例えば::

    from mysite.geography.models import ZipCode

    class Restaurant(models.Model):
        # ...
        zip_code = models.ForeignKey(ZipCode)

.. _Field name restrictions:

フィールド名の制約
------------------

Django がモデルのフィールド名に課している制約は二つしかありません:

    1. フィールド名は Python の予約語であってはなりません。さもなければ
       Python のシンタクスエラーを引き起こすからです。例えば::

           class Example(models.Model):
               pass = models.IntegerField() # 'pass' is a reserved word!

    2. フィールド名には二つ以上の連続するアンダースコアを入れてはなりません。
       なぜなら、Django のクエリ照合構文で使われているからです。例えば::

           class Example(models.Model):
               foo__bar = models.IntegerField() # 'foo__bar' has two underscores!

フィールドの名前は必ずしもデータベースのカラム名と一致していなくてもよいの
で、これらの制約は回避可能です。詳しくは後述の :attr:`~Field.db_column` を
参照してください。

``join`` や ``where``, ``select`` のような SQL の予約語は、モデルのフィール
ド名に使っても *かまいません* 。というのも、Django はいかなる SQL クエリ文
でも全てのデータベーステーブル名やカラム名をエスケープするからです。エスケー
プにはデータベースエンジン固有のクオートシンタクスを使います。

.. _Custom field types:

カスタムのフィールド型
-----------------------

.. versionadded:: 1.0

既存のモデルフィールドが目的とするアプリケーションに合わない場合や、あまり
一般的でないデータベースカラムタイプを活用したい場合のために、独自のフィー
ルドクラスを作成できます。独自のフィールドの作成方法の詳細は
:ref:`howto-custom-model-fields` で説明しています。

.. _meta-options:
.. _Meta options:

Meta オプション
===============

モデルにメタデータを指定するには、以下のようにモデルの内部クラス
``Meta`` を使います::

    class Ox(models.Model):
        horn_length = models.IntegerField()

        class Meta:
            ordering = ["horn_length"]
            verbose_name_plural = "oxen"

.. TBD

Model metadata is "anything that's not a field", such as ordering options
(:attr:`~Options.ordering`), database table name (:attr:`~Options.db_table`), or
human-readable singular and plural names (:attr:`~Options.verbose_name` and
:attr:`~Options.verbose_name_plural`). None are required, and adding ``class
Meta`` to a model is completely optional.

A complete list of all possible ``Meta`` options can be found in the :ref:`model
option reference <ref-models-options>`.

.. _model-methods:
.. _Model methods:

モデルのメソッド
================

カスタムの行レベル ("row-level") の機能をオブジェクトに実装するには、カスタ
ムのメソッドを定義します。 :class:`~django.db.models.Manager` メソッドの目
的が「テーブル級 (table-wide)」 の操作であるのに対し、モデルメソッドは個々
のモデルインスタンスに対して作用します。

このモデルメソッドは、ビジネスロジックをモデルというただ一箇所にまとめてお
くのに有用なテクニックになります。

例えば、以下のモデル例にはいくつかカスタムメソッドがあります::

    from django.contrib.localflavor.us.models import USStateField
    class Person(models.Model):
        first_name = models.CharField(max_length=50)
        last_name = models.CharField(max_length=50)
        birth_date = models.DateField()
        address = models.CharField(max_length=100)
        city = models.CharField(max_length=50)
        state = USStateField() # Yes, this is America-centric...

        def baby_boomer_status(self):
            "Returns the person's baby-boomer status."
            import datetime
            if datetime.date(1945, 8, 1) <= self.birth_date <= datetime.date(1964, 12, 31):
                return "Baby boomer"
            if self.birth_date < datetime.date(1945, 8, 1):
                return "Pre-boomer"
            return "Post-boomer"

        def is_midwestern(self):
            "Returns True if this person is from the Midwest."
            return self.state in ('IL', 'WI', 'MI', 'IN', 'OH', 'IA', 'MO')

        def _get_full_name(self):
            "Returns the person's full name."
            return '%s %s' % (self.first_name, self.last_name)
        full_name = property(_get_full_name)

この例の最後のメソッドは :term:`プロパティ` (:term:`property`) です。詳しく
は `プロパティの説明`_ を参照してください。

.. _Read more about properties: http://www.python.org/download/releases/2.2/descrintro/#property
.. _`プロパティの説明`: `Read more about properties`_

.. TBD

The :ref:`model instance reference <ref-models-instances>` has a complete list
of :ref:`methods automatically given to each model <model-instance-methods>`.
You can override most of these -- see `overriding predefined model methods`_,
below -- but there are a couple that you'll almost always want to define:

    :meth:`~Model.__unicode__`
        A Python "magic method" that returns a unicode "representation" of any
        object. This is what Python and Django will use whenever a model
        instance needs to be coerced and displayed as a plain string. Most
        notably, this happens when you display an object in an interactive
        console or in the admin.
        
        You'll always want to define this method; the default isn't very helpful
        at all.
        
    :meth:`~Model.get_absolute_url`
        This tells Django how to calculate the URL for an object. Django uses
        this in its admin interface, and any time it needs to figure out a URL
        for an object.
        
        Any object that has a URL that uniquely identifies it should define this
        method.

.. TBD

Overriding predefined model methods
-----------------------------------

There's another set of :ref:`model methods <model-instance-methods>` that
encapsulate a bunch of database behavior that you'll want to customize. In
particular you'll often want to change the way :meth:`~Model.save` and
:meth:`~Model.delete` work.

You're free to override these methods (and any other model method) to alter
behavior.

組み込みメソッドをオーバライドする古典的なユースケースは、オブジェクトを保
存する際に何か別の処理を行うというものです。例を示しましょう
(:meth:`~Model.save` のパラメタはドキュメントを参照してください。)::

    class Blog(models.Model):
        name = models.CharField(max_length=100)
        tagline = models.TextField()

        def save(self, force_insert=False, force_update=False):
            do_something()
            super(Blog, self).save(force_insert, force_insert) # 「実際の」 save() を呼び出します。
            do_something_else()

また、以下のようにすれば保存を抑止できます::

    class Blog(models.Model):
        name = models.CharField(max_length=100)
        tagline = models.TextField()

        def save(self, force_insert=False, force_update=False):
            if self.name == "Yoko Ono's blog":
                return # Yoko は自分のブログを持っていません！
            else:
                super(Blog, self).save(force_insert, force_update) # Call the "real" save() method.

.. TBD

It's important to remember to call the superclass method -- that's that
``super(Blog, self).save()`` business -- to ensure that the object still gets
saved into the database. If you forget to call the superclass method, the
default behavior won't happen and the database won't get touched.

.. _Executing custom SQL:

カスタム SQL の実行
--------------------

Another common pattern is writing custom SQL statements in model methods and
module-level methods. The object :class:`django.db.connection
<django.db.backends.DatabaseWrapper>` represents the current database
connection. To use it, call :meth:`connection.cursor()
<django.db.backends.DatabaseWrapper.cursor>` to get a cursor object. Then, call
``cursor.execute(sql, [params])`` to execute the SQL and
:meth:`cursor.fetchone() <django.db.backends.CursorWrapper.fetchone>` or
:meth:`cursor.fetchall() <django.db.backends.CursorWrapper.fetchall>` to return
the resulting rows. For example::

    def my_custom_sql(self):
        from django.db import connection
        cursor = connection.cursor()
        cursor.execute("SELECT foo FROM bar WHERE baz = %s", [self.baz])
        row = cursor.fetchone()
        return row

:class:`connection <django.db.backends.DatabaseWrapper>` and
:class:`<django.db.backends.CursorWrapper>` mostly implement the standard Python
DB-API -- see :pep:`249` -- with the addition of Django's :ref:`transaction
handling <topics-db-transactions>`. If you're not familiar with the Python
DB-API, note that the SQL statement in :meth:`cursor.execute()
<django.db.backends.CursorWrapper.execute>` uses placeholders, ``"%s"``, rather
than adding parameters directly within the SQL. If you use this technique, the
underlying database library will automatically add quotes and escaping to your
parameter(s) as necessary. (Also note that Django expects the ``"%s"``
placeholder, *not* the ``"?"`` placeholder, which is used by the SQLite Python
bindings. This is for the sake of consistency and sanity.)

A final note: If all you want to do is a custom ``WHERE`` clause, you can use
the :meth:`~QuerySet.extra` lookup method, which lets you add custom SQL to a
query.

.. _model-inheritance:
.. _Model inheritance:

モデルの継承
=================

.. versionadded:: 1.0

Django のモデルクラス継承は、 Python の通常のクラス継承とほぼ同じように動作
します。モデル継承を実現するには、一つだけきめておかねばならないことがあり
ます。それは、親クラスに独自のデータベーステーブルを持たせるか、親クラスを
単なるホルダとして使い、子クラスで共通の情報を持たせるだけにするかです。

複数の子モデルクラスでいちいち同じ情報を入力せずに済ませるために、親モデル
クラスに共通の情報を持たせたいことはよくあります。親モデルクラスを単体で使
うことがないのなら、 :ref:`abstract-base-classes` を使うのがよいでしょう。
一方、(他のアプリケーションなどにある) 既存のモデルをサブクラス化して拡張し
たり、個々のモデルに固有のデータベースを持たせたいような場合には、 
:ref:`multi-table-inheritance` を使うのがよいでしょう。

.. _abstract-base-classes:
.. _Abstract base classes:

抽象ベースクラス
---------------------

抽象ベースクラスは、たくさんのモデルに共通する情報を入れておきたいときに便
利な仕組みです。抽象ベースクラスを定義するには、ベースクラス定義の、
:ref:`Meta <meta-options>` に ``abstract=True`` を入れておきます。モデルを
抽象ベースクラスとして定義すると、そのクラスはデータベーステーブルを生成し
ません。その代り、他のモデルを定義するときに抽象ベースクラスを親にすると、
ベースクラスのフィールドが子クラスに追加されます。抽象ベースクラスで定義し
たフィールドと同じ名前のフィールドを子クラスで定義しようとするとエラーを引
き起こします (Django は例外を送出します)。

例を示しましょう::

    class CommonInfo(models.Model):
        name = models.CharField(max_length=100)
        age = models.PositiveIntegerField()

        class Meta:
            abstract = True

    class Student(CommonInfo):
        home_group = models.CharField(max_length=5)

このように定義すると、 ``Student`` モデルは ``name``, ``age`` および
``home_group`` の三つのフィールドを持つようになります。. ``CommonInfo`` モ
デルは抽象ベースクラスなので、通常の Django モデルとしては使えません。
``CommonInfo`` はデータベーステーブルを作らず、マネジャなども持ちません。

ほとんどの用途で使えるのは、このタイプのモデル継承でしょう。抽象ベースクラ
スは、子クラスで共通の情報を Python レベルに切り出しながらも、データベース
レベルでは、各子クラスに一つのデータベーステーブルを生成します。

.. _`Meta inheritance`:

``Meta`` の継承
~~~~~~~~~~~~~~~~~~~~

抽象ベースクラスを作成するとき、 Django は抽象ベースクラスの内部クラス
:ref:`Meta <meta-options>` をクラス属性として参照できるようにします。子クラ
スで :ref:`Meta <meta-options>` クラスを定義しない場合、親クラスの
:ref:`Meta <meta-options>` がそのまま継承されます。子クラスで 
:ref:`Meta <meta-options>` を拡張したければ、親クラスをサブクラス化できます。
以下に例を示しましょう::

    class CommonInfo(models.Model):
        ...
        class Meta:
            abstract = True
            ordering = ['name']

    class Student(CommonInfo):
        ...
        class Meta(CommonInfo.Meta):
            db_table = 'student_info'

Django は抽象ベースクラスの :ref:`Meta <meta-options>` クラスを生成するとき
に一つだけ手を加えます。すなわち、 :ref:`Meta <meta-options>` の属性を組み
込む前に、 ``abstract=False`` を設定するのです。これにより、抽象ベースクラ
スの子クラスが自動的に非抽象ベースクラスになります。もちろん、他の抽象ベー
スクラスを継承した新たな抽象ベースクラスも定義できます。継承するには、明示
的に ``abstract=True`` をセットしてください。

:ref:`Meta <meta-options>` クラスの属性の中には、抽象ベースクラスで定義して
も意味のないものもあります。例えば、 ``db_table`` を抽象ベースクラスの
:ref:`Meta <meta-options>` で定義すると、その子クラス全て (で、独自に
:ref:`Meta <meta-options>` を定義しないもの) が、同じデータベーステーブルを
使おうとしてしまいます。

.. _abstract-related-name:
.. _`Be careful with related_name`:

``related_name`` に注意
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

:class:`~django.db.models.fields.ForeignKey` や
:class:`~django.db.models.fields.ManyToManyField` に ``related_name`` 属性
を使っている場合には、フィールドの *一意な* 逆リレーション名を指定してくだ
さい。抽象ベースクラスのフィールドは
(:attr:`~django.db.models.ForeignKey.related_name` の設定値を含み) 子クラス
にそのまま組み込まれるので、 子クラスで同じ
:attr:`~django.db.models.ForeignKey.related_name` のフィールドができてしま
うため、問題を引き起こします。

この問題を回避するには、抽象ベースクラスで
:attr:`~django.db.models.ForeignKey.related_name` を使うときに(かつその時に
限り)、文字列の一部に ``'%(class)s'`` を付加してください。そうすると、
``'%(class)s'`` は子クラスでクラスの小文字名に置き換えられます。各クラスは
個別の名前をもっているので、結果的にリレーション名は個別の名前に
なります。例えば::

    class Base(models.Model):
        m2m = models.ManyToMany(OtherModel, related_name="%(class)s_related")

        class Meta:
            abstract = True

    class ChildA(Base):
        pass

    class ChildB(Base):
        pass

この例で、 ``ChildA.m2m`` フィールドの逆リレーション名は ``childa_related``
になり、 ``ChildB.m2m`` フィールドの逆リレーション名は ``childb_related``
になります。逆リレーション名の定義で ``'%(class)s'`` をどう使うかはユーザ次
第ですが、 ``'%(class)s'`` を使いわすれると、モデルの検証時 (または
:djadmin:`syncdb` 時) に例外を送出します。

抽象ベースクラスのフィールドに
:attr:`~django.db.models.ForeignKey.related_name`
属性を指定しない場合、子クラスの名前に ``'_set'`` をつけた名前をデフォルト
の逆リレーション名として使います。これは子クラスで直接リレーションフィール
ドを定義した場合と同じ挙動です。例えば、上のコードで
:attr:`~django.db.models.ForeignKey.related_name` 属性を省略すると、
``m2m`` フィールドの逆リレーション名は ``ChildA`` では ``childa_set`` 、
``ChildB`` では ``childb_set`` です。

.. _multi-table-inheritance:
.. _Multi-table inheritance:

マルチテーブル継承
-----------------------

Django では、継承の各階層にいるクラスが抽象クラスでない実際のモデルであるよ
うな、もう一つのタイプのモデル継承をサポートしています。各モデルはそれぞれ
が一個のデータベーステーブルを表現していて、個別にクエリを発行したり、イン
スタンスを生成したりできます。継承の関係によって、親クラスと子クラスの間に
は (自動生成された :class:`~django.db.models.fields.OneToOneField` によって)
リンクが張られます。以下の例で説明しましょう::

    class Place(models.Model):
        name = models.CharField(max_length=50)
        address = models.CharField(max_length=80)

    class Restaurant(Place):
        serves_hot_dogs = models.BooleanField()
        serves_pizza = models.BooleanField()

``Place`` の全てのフィールドは、 ``Restaurant`` からも使えます。しかし、そ
れぞれのフィールドのデータは別々のテーブルに格納されます。従って、以下のよ
うな操作をどちらも実行できます::

    >>> Place.objects.filter(name="Bob's Cafe")
    >>> Restaurant.objects.filter(name="Bob's Cafe")

例えば、 ``Place`` であり、かつ ``Restaurant`` でもあるようなオブジェクトが
あれば、モデル名を小文字にした属性を使って、 ``Place`` から ``Restaurant``
を取り出せます::

    >>> p = Place.objects.filter(name="Bob's Cafe")
    # Bob's Cafe が Restaurant オブジェクトなら、子クラスを返す:
    >>> p.restaurant
    <Restaurant: ...>

ただし、上の ``p`` が ``Restaurant`` クラスで *ない* のなら (``Place`` から
直接生成されたオブジェクトや、他のクラスの親クラスなら)  ``p.restaurant``
はエラーを引き起こします。

.. _`Meta and multi-table inheritance`:

``Meta`` とマルチテーブル継承
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

マルチテーブル継承では、子クラスが親クラスの :ref:`Meta <meta-options>` ク
ラスを継承する意味がありません。 :ref:`Meta <meta-options>` オプションは全
て親クラスだけに適用されるべきもので、他のクラスに同じ内容を適用しても、矛
盾した振る舞いを引き起こすだけです(これは、独自のテーブルを持たない抽象ベー
スクラスと対照的な部分です)。

従って、マルチテーブル継承の子クラスは親クラスの :ref:`Meta <meta-options>`
クラスにアクセスする方法を持ちません。ただし、限られたケースで、子クラスが
親クラスの挙動を継承する場合があります。それは、子クラスで 
:attr:`django.db.models.Options.ordering` または
:attr:`django.db.models.Options.get_latest_by` 属性を指定していない場合に、
親クラスの属性を継承するというものです。

親クラスで整列カラムが指定されていて、子クラス側で整列カラムを指定したくな
い場合は、明示的に空の整列カラムを指定してください::

    class ChildModel(ParentModel):
        ...
        class Meta:
            # 親クラスの整列カラム設定の効果を除去する
            ordering = []

.. _Inheritance and reverse relations:

継承と逆リレーション
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

マルチテーブル継承は親クラスと子クラスを暗黙の
:class:`~django.db.models.fields.OneToOneField` でリンクするので、前述の例
のように、親クラスから子クラスをたどれます。しかし、子クラスをたどるときに
使う名前は、 :class:`~django.db.models.fields.ForeignKey` や
:class:`~django.db.models.fields.ManyToManyField` リレーションを定義したと
きのデフォルトの :attr:`~django.db.models.ForeignKey.related_name` と同じ値
を使っています。従って、子クラスで
:class:`~django.db.models.fields.ForeignKey` や
:class:`~django.db.models.fields.ManyToManyField` を別のクラスに向けて張る
ときには、 **必ず** :attr:`~django.db.models.ForeignKey.related_name` をフィー
ルドに指定せねばなりません。指定し忘れると、 Django は 
:djadmin:`manage.py validate <validate>` や :djadmin:`syncdb` 時にエラーを
送出します。

例えば、上の ``Place`` クラスに対して、
:class:`~django.db.models.fields.ManyToManyField` を持った別のサブクラスを
定義するには、以下のように書きます::

    class Supplier(Place):
        # Must specify related_name on all relations.
        customers = models.ManyToManyField(Restaurant,
                related_name='provider')


.. _Specifying the parent link field:

親クラスのリンクフィールドを定義する
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

すでに触れたように、 Django は子クラスと抽象クラスでない親クラスにリンクし
た :class:`~django.db.models.fields.OneToOneField` を自動的に生成します。親
クラスへのリンク名を操作したければ、自分で
:class:`~django.db.models.fields.OneToOneField` を作成し、パラメタに
:attr:`parent_link=True <django.db.models.fields.OneToOneField.parent_link>`
を渡してください。

.. _Multiple inheritance:

多重継承
----------

Python のサブクラスと同様、 Django のモデルも複数の親モデルクラスを継承でき
ます。クラス内の名前解決には、 Python の通常の名前解決規則が適用されるので
注意してください。子クラスで特定の名前 (例えば :ref:`Meta <meta-options>`)
を参照する場合、その名前を定義している最初のベースクラスの定義を使い、最初
に名前が見つかった時点で、それ以降同じ名前のオブジェクトの解決は行われませ
ん。従って、複数の親クラスで別々に :ref:`Meta <meta-options>` クラスを定義
していても、最初のベースクラスの :ref:`Meta <meta-options>` だけが使われ、
それ以外は全て無視されます。

通常は、モデルの多重継承は必要ないでしょう。多重継承が便利なのは、主に特定
のフィールドやメソッドを追加するための ''mix-in'' クラスを使う場合です。
継承の階層構造はできるだけ単純に、分かりやすくしておきましょう。さもないと、
子クラスで扱っている情報が、どの親クラスから来たか調べるために四苦八苦する
はめになるでしょう。
